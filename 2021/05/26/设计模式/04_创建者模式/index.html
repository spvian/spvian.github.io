<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="spvian"><meta name="copyright" content="spvian"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>04_创建者模式 | spvian</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link class="aplayer-style-marker" rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script class="aplayer-script-marker" src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" defer></script><script class="meting-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js" defer></script><link rel="icon" href="/yun"><link rel="mask-icon" href="/yun" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"永远相信未来","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"想要搜些什么？","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="创建者模式1. 概述1234567创建型模式的主要关注点是 “ 怎样创建对象？ ”，它的主要特点是 “ 将对象的创建与使用分离 ”。	创建型模式分为：           * 单例模式           * 工厂方法模式           * 抽象工程模式           * 原型模式           * 建造者模式    2. 单例模式2.1 实现方式123单例设计模式分类两种：">
<meta property="og:type" content="article">
<meta property="og:title" content="04_创建者模式">
<meta property="og:url" content="http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04_%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="spvian">
<meta property="og:description" content="创建者模式1. 概述1234567创建型模式的主要关注点是 “ 怎样创建对象？ ”，它的主要特点是 “ 将对象的创建与使用分离 ”。	创建型模式分为：           * 单例模式           * 工厂方法模式           * 抽象工程模式           * 原型模式           * 建造者模式    2. 单例模式2.1 实现方式123单例设计模式分类两种：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-26T10:32:18.311Z">
<meta property="article:modified_time" content="2021-05-19T12:23:18.730Z">
<meta property="article:author" content="spvian">
<meta property="article:tag" content="设计">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="spvian"><img width="96" loading="lazy" src="/aya" alt="spvian"></a><div class="site-author-name"><a href="/about/">spvian</a></div><span class="site-name">spvian</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">64</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/spvain" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">创建者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 懒汉式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 破坏单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 序列化反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%8F%8D%E5%B0%84"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 反射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 单例模式的示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3. 工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 简单工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4.  原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">5. 建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">6. 工厂模式与建造者模式的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 工厂模式与建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E4%B8%8E%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 抽象工厂与建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.6.3.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/Linux/" style="font-size: 15.6px; color: #7a92a9">Linux</a> <a href="/tags/SpringBoot/" style="font-size: 30px; color: #0078e7">SpringBoot</a> <a href="/tags/java/" style="font-size: 22.8px; color: #3d85c8">java</a> <a href="/tags/spring/" style="font-size: 12px; color: #999">spring</a> <a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 19.2px; color: #5c8cb8">教程</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 22.8px; color: #3d85c8">笔记</a> <a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 26.4px; color: #1f7fd7">设计</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04_%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="spvian"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="spvian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">04_创建者模式</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-05-26 18:32:18" itemprop="dateCreated datePublished" datetime="2021-05-26T18:32:18+08:00">2021-05-26</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2021-05-19 20:23:18" itemprop="dateModified" datetime="2021-05-19T20:23:18+08:00">2021-05-19</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">3k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">10m</span></span></span><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">设计模式</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%BE%E8%AE%A1/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">设计</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建型模式的主要关注点是 “ 怎样创建对象？ ”，它的主要特点是 “ 将对象的创建与使用分离 ”。</span><br><span class="line">	创建型模式分为：</span><br><span class="line">           * 单例模式</span><br><span class="line">           * 工厂方法模式</span><br><span class="line">           * 抽象工程模式</span><br><span class="line">           * 原型模式</span><br><span class="line">           * 建造者模式</span><br></pre></td></tr></table></figure>



<h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><h3 id="2-1-实现方式"><a href="#2-1-实现方式" class="headerlink" title="2.1 实现方式"></a>2.1 实现方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单例设计模式分类两种：</span><br><span class="line">    饿汉式：类加载就会导致该单实例对象被创建	</span><br><span class="line">    懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-饿汉式"><a href="#2-1-1-饿汉式" class="headerlink" title="2.1.1 饿汉式"></a>2.1.1 饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提前创建号实例，需要该实例时，直接返回</span><br><span class="line">       1. 静态变量方式：</span><br><span class="line">       2，静态代码块方式</span><br></pre></td></tr></table></figure>



<h4 id="2-1-2-懒汉式"><a href="#2-1-2-懒汉式" class="headerlink" title="2.1.2 懒汉式"></a>2.1.2 懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">需要改实例时，判断该实例是否存在，若不存在则创建该实例并返回，若存在，直接返回该实例</span><br><span class="line">	在多线程下存在线程安全问题</span><br><span class="line">		解决办法：</span><br><span class="line">			1. synchronized ：修饰提供实例的方法</span><br><span class="line">				问题：在多线程会影响执行效率</span><br><span class="line">			2. 双重检查锁：在判断实例是否为空后，添加 synchronized 锁，在进行判断</span><br><span class="line">				把判空的方法放在锁外，在多线程大大提高了执行效率，但因为 JVM 实例化对象时，会优化指令和指令重排而导致空指针异常</span><br><span class="line">			3. volatile：在双重检查锁的基础上，使用 volatile 修饰成员变量，以保证可见性和有序性。</span><br><span class="line">			4. 静态内部类：因 JVM 在加载外部类的过程中, 不会加载静态内部类, 只有内部类的属性/方法被调用时才会被加载,静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。</span><br><span class="line">			5. 枚举方式：枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</span><br></pre></td></tr></table></figure>



<h3 id="2-2-破坏单例模式"><a href="#2-2-破坏单例模式" class="headerlink" title="2.2 破坏单例模式"></a>2.2 破坏单例模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单例类（Singleton）可以创建多个对象，枚举方式除外。</span><br><span class="line">	两种方式：序列化、反射 </span><br></pre></td></tr></table></figure>



<h4 id="2-2-1-序列化反序列化"><a href="#2-2-1-序列化反序列化" class="headerlink" title="2.2.1 序列化反序列化"></a>2.2.1 序列化反序列化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">破坏单例模式：</span><br><span class="line">	通过 ObjectOutputStream 中 writeObject() 方法把对象写入到文件中，再通过 ObjectInputStream 中 readObject() 方法从文件中读取对象</span><br><span class="line">解决办法：</span><br><span class="line">	在单例类中添加 readResolve() 方法，该方法返回的是单例对象。</span><br><span class="line">原理：		</span><br><span class="line">	ObjectInputStream 的 readObject() 方法在读取对象时，会先判断是否有 readResolve() 方法，若有，则通过反射调用该方法获取对象</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-反射"><a href="#2-2-2-反射" class="headerlink" title="2.2.2 反射"></a>2.2.2 反射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">破坏单例模式：</span><br><span class="line">	通过 Class 获取构造方法（clazz.getDeclaredConstructor），并取消权限检查（setAccessible(true) ）, 获取实例（ constructor.newInstance()）</span><br><span class="line">解决办法：</span><br><span class="line">	在构造方法中判断是否是第一次实例化，否则抛出异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-单例模式的示例"><a href="#2-3-单例模式的示例" class="headerlink" title="2.3 单例模式的示例"></a>2.3 单例模式的示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JDK 中的 Runtime 类</span><br><span class="line">	部分代码</span><br><span class="line">	</span><br><span class="line">       private static Runtime currentRuntime = new Runtime();</span><br><span class="line">       /**</span><br><span class="line">       * Returns the runtime object associated with the current Java application.</span><br><span class="line">       * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="line">       * methods and must be invoked with respect to the current runtime object.</span><br><span class="line">       *</span><br><span class="line">       * @return  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="line">       *          Java application.</span><br><span class="line">       */</span><br><span class="line">       public static Runtime getRuntime() &#123;</span><br><span class="line">       return currentRuntime;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用工厂模式来创建对象，而不是直接的 new 对象，这样做是为了降低耦合性</span><br><span class="line">       * 简单工厂模式（不属于GOF的23种经典设计模式）</span><br><span class="line">       * 工厂方法模式</span><br><span class="line">       * 抽象工厂模式</span><br></pre></td></tr></table></figure>



<h3 id="3-1-简单工厂"><a href="#3-1-简单工厂" class="headerlink" title="3.1 简单工厂"></a>3.1 简单工厂</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简单工厂包含如下角色：</span><br><span class="line">    * 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">    * 具体产品 ：实现或者继承抽象产品的子类</span><br><span class="line">    * 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品</span><br><span class="line">优点：</span><br><span class="line">	封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开</span><br><span class="line">缺点：</span><br><span class="line">	违背了开闭原则</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-2-工厂方法模式"><a href="#3-2-工厂方法模式" class="headerlink" title="3.2 工厂方法模式"></a>3.2 工厂方法模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</span><br><span class="line">工厂方法模式的主要角色：</span><br><span class="line">       * 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</span><br><span class="line">       * 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</span><br><span class="line">       * 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">       * 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</span><br><span class="line">       </span><br><span class="line">   优点：</span><br><span class="line">       用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</span><br><span class="line">       在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">	每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-3-抽象工厂模式"><a href="#3-3-抽象工厂模式" class="headerlink" title="3.3 抽象工厂模式"></a>3.3 抽象工厂模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</span><br><span class="line">抽象工厂模式的主要角色如下：</span><br><span class="line">       * 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</span><br><span class="line">       * 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class="line">       * 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class="line">       * 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</span><br><span class="line">       </span><br><span class="line">	优点：</span><br><span class="line">	当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">	当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</span><br><span class="line">	</span><br><span class="line">   使用场景：</span><br><span class="line">       * 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</span><br><span class="line">       * 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</span><br><span class="line">       * 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</span><br><span class="line">       如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-4-扩展"><a href="#3-4-扩展" class="headerlink" title="3.4 扩展"></a>3.4 扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单工厂+ 配置文件解除耦合</span><br><span class="line">在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</span><br></pre></td></tr></table></figure>



<h2 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.  原型模式"></a>4.  原型模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象</span><br><span class="line">原型模式包含如下角色：</span><br><span class="line">       * 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</span><br><span class="line">       * 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</span><br><span class="line">       * 访问类：使用具体原型类中的 clone() 方法来复制新的对象。</span><br><span class="line">  使用场景：</span><br><span class="line">  		* 对象的创建非常复杂，可以使用原型模式快捷的创建对象。</span><br><span class="line">	* 性能和安全要求比较高。		</span><br></pre></td></tr></table></figure>



<h3 id="4-1-实现"><a href="#4-1-实现" class="headerlink" title="4.1 实现"></a>4.1 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	原型模式的克隆分为浅克隆和深克隆。</span><br><span class="line">		浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</span><br><span class="line">		深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">注意：Java 中的 Object 类中提供了 clone() 方法来实现浅克隆，java 提供了 Cloneable 接口</span><br><span class="line">	 深克隆可以通过序列化来实现</span><br></pre></td></tr></table></figure>



<h2 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5. 建造者模式"></a>5. 建造者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	将一个复杂对象的构建与表示分离</span><br><span class="line">	建造者（Builder）模式包含如下角色：</span><br><span class="line">        * 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </span><br><span class="line">        * 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </span><br><span class="line">        * 产品类（Product）：要创建的复杂对象。</span><br><span class="line">        * 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </span><br><span class="line">       </span><br><span class="line">    优点：</span><br><span class="line">         建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</span><br><span class="line">        在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</span><br><span class="line">        可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</span><br><span class="line">        建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</span><br><span class="line">    缺点：</span><br><span class="line">   		 创造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</span><br><span class="line">   		 </span><br><span class="line">   使用场景：建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</span><br><span class="line">        - 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</span><br><span class="line">        - 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</span><br><span class="line"></span><br><span class="line">注意：可以采用链式编程的方式实现建造者模式，但对程序员的要求较高</span><br></pre></td></tr></table></figure>



<h2 id="6-工厂模式与建造者模式的区别"><a href="#6-工厂模式与建造者模式的区别" class="headerlink" title="6. 工厂模式与建造者模式的区别"></a>6. 工厂模式与建造者模式的区别</h2><h3 id="6-1-工厂模式与建造者模式"><a href="#6-1-工厂模式与建造者模式" class="headerlink" title="6.1 工厂模式与建造者模式"></a>6.1 工厂模式与建造者模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工厂模式：注重的是对整体对象的创建，是方式</span><br><span class="line">建造者模式：注重的是对对象创建的顺序，是过程</span><br></pre></td></tr></table></figure>



<h3 id="6-2-抽象工厂与建造者模式"><a href="#6-2-抽象工厂与建造者模式" class="headerlink" title="6.2 抽象工厂与建造者模式"></a>6.2 抽象工厂与建造者模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂：关注的是产品，而不是对象，是一个产品族的概念</span><br><span class="line">建造者模式：关注的是产品的组成，</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>spvian</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04_%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/" title="04_创建者模式">http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04_%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03_%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" rel="prev" title="03_设计原则"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">03_设计原则</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/05/26/%E8%AE%BA%E5%9D%9B/%E6%B1%87%E6%80%BB/" rel="next" title=""><span class="post-nav-text"></span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> spvian</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="Total Visitors"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="Search"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="想要搜些什么？" value=""></div><div id="local-search-result"></div></div><div class="aplayer no-destroy" id="aplayer" data-id="308168565" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>