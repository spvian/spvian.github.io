<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="spvian"><meta name="copyright" content="spvian"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>05_结构型模式 | spvian</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"永远相信未来","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="结构型模式1. 概述123456789结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。结构型模式分为以下 7 种：       * 代理模式       * 适配器模式       * 装饰者模式       * 桥接模式       * 外观模式       * 组合模式       * 享元">
<meta property="og:type" content="article">
<meta property="og:title" content="05_结构型模式">
<meta property="og:url" content="http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="spvian">
<meta property="og:description" content="结构型模式1. 概述123456789结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。结构型模式分为以下 7 种：       * 代理模式       * 适配器模式       * 装饰者模式       * 桥接模式       * 外观模式       * 组合模式       * 享元">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-26T10:32:18.326Z">
<meta property="article:modified_time" content="2021-05-19T12:23:37.981Z">
<meta property="article:author" content="spvian">
<meta property="article:tag" content="设计">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="spvian"><img width="96" loading="lazy" src="/yun.png" alt="spvian"></a><div class="site-author-name"><a href="/about/">spvian</a></div><span class="site-name">spvian</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">55</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/spvain" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 静态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-JDK-%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 JDK 代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-CGLIB-%E4%BB%A3%E7%90%86"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 CGLIB 代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 代理方式的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3. 适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 类适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 对象适配器模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4. 装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">5. 桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">6. 外观模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">7. 组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">8. 享元模式</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="spvian"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="spvian"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">05_结构型模式</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-05-26 18:32:18" itemprop="dateCreated datePublished" datetime="2021-05-26T18:32:18+08:00">2021-05-26</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2021-05-19 20:23:37" itemprop="dateModified" datetime="2021-05-19T20:23:37+08:00">2021-05-19</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">设计模式</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E8%AE%BE%E8%AE%A1/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">设计</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</span><br><span class="line">结构型模式分为以下 7 种：</span><br><span class="line">       * 代理模式</span><br><span class="line">       * 适配器模式</span><br><span class="line">       * 装饰者模式</span><br><span class="line">       * 桥接模式</span><br><span class="line">       * 外观模式</span><br><span class="line">       * 组合模式</span><br><span class="line">       * 享元模式</span><br></pre></td></tr></table></figure>



<h2 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   由于某些原因需要给对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</span><br><span class="line">   Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在 Java运行时动态生成。动态代理又有 JDK 代理和 CGLib 代理两种。</span><br><span class="line">   结构:</span><br><span class="line">       代理（Proxy）模式分为三种角色：</span><br><span class="line">           * 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</span><br><span class="line">           * 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</span><br><span class="line">           * 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</span><br><span class="line">   优点：</span><br><span class="line">       - 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</span><br><span class="line">       - 代理对象可以扩展目标对象的功能；</span><br><span class="line">       - 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">	 增加了系统的复杂度；</span><br></pre></td></tr></table></figure>



<h3 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被代理类聚合、组合到代理类中，两者实现相同的接口，访问者调用代理类总的方法，实际上调用的是被代理类的方法</span><br></pre></td></tr></table></figure>



<h3 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h3><h4 id="2-2-1-JDK-代理"><a href="#2-2-1-JDK-代理" class="headerlink" title="2.2.1 JDK 代理"></a>2.2.1 JDK 代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java 中提供了一个动态代理类 Proxy，Proxy 并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</span><br><span class="line"></span><br><span class="line">Proxy.newProxyInstance(ClassLoader,</span><br><span class="line">    Interfaces, <span class="comment">// 被代理类的接口</span></span><br><span class="line">    <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">   		 <span class="comment">/*</span></span><br><span class="line"><span class="comment">            InvocationHandler中invoke 方法参数说明：</span></span><br><span class="line"><span class="comment">            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//执行真实对象</span></span><br><span class="line">        Object result = method.invoke(station, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="2-2-2-CGLIB-代理"><a href="#2-2-2-CGLIB-代理" class="headerlink" title="2.2.2 CGLIB 代理"></a>2.2.2 CGLIB 代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为 JDK 的动态代理提供了很好的补充。</span><br><span class="line">  CGLIB是第三方提供的包，所以需要引入jar包的坐标：</span><br><span class="line">  		&lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          </span><br><span class="line">      Enhancer enhancer =new Enhancer();</span><br><span class="line">      //设置父类的字节码对象</span><br><span class="line">      enhancer.setSuperclass(target.getClass());</span><br><span class="line">      //设置回调函数</span><br><span class="line">      enhancer.setCallback(new MethodInterceptor()&#123;</span><br><span class="line">	/*</span><br><span class="line">          	intercept方法参数说明：</span><br><span class="line">              o ： 代理对象</span><br><span class="line">              method ： 真实对象中的方法的Method实例</span><br><span class="line">              args ： 实际参数</span><br><span class="line">              methodProxy ：代理对象中的方法的method实例</span><br><span class="line">  		 */</span><br><span class="line">          public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">              return = (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;);</span><br><span class="line">      //创建代理对象</span><br><span class="line">      return   enhancer.create();</span><br></pre></td></tr></table></figure>



<h3 id="2-3-代理方式的对比"><a href="#2-3-代理方式的对比" class="headerlink" title="2.3 代理方式的对比"></a>2.3 代理方式的对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动态代理和静态代理：</span><br><span class="line">	动态代理把代理对象的方法统一集中处理，而像静态代理针对每个方法都要实现</span><br><span class="line">JDK 代理与 CGLIB 代理：</span><br><span class="line">	JDK 代理是基于代理对象的接口来实现的，而 CGLIB 代理是基于对象的类实现的</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-适配器模式"><a href="#3-适配器模式" class="headerlink" title="3. 适配器模式"></a>3. 适配器模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</span><br><span class="line">   适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构。</span><br><span class="line">   结构</span><br><span class="line">   	适配器模式（Adapter）包含以下主要角色：</span><br><span class="line">           * 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</span><br><span class="line">           * 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</span><br><span class="line">           * 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</span><br><span class="line">   应用场景</span><br><span class="line">       * 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</span><br><span class="line">       * 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</span><br><span class="line">JDK 中的示例</span><br><span class="line">	Reader（字符流）、InputStream（字节流）的适配使用的是 InputStreamReader。</span><br><span class="line">	InputStreamReader 继承自 java.io 包中的 Reader，对他中的抽象的未实现的方法给出实现，实现是由 sun.nio.cs.StreamDecoder类</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-1-类适配器"><a href="#3-1-类适配器" class="headerlink" title="3.1 类适配器"></a>3.1 类适配器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现方式：适配器需要继承需要适配的类和所需要目标接口</span><br></pre></td></tr></table></figure>



<h3 id="3-2-对象适配器模式"><a href="#3-2-对象适配器模式" class="headerlink" title="3.2 对象适配器模式"></a>3.2 对象适配器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</span><br></pre></td></tr></table></figure>



<h2 id="4-装饰者模式"><a href="#4-装饰者模式" class="headerlink" title="4. 装饰者模式"></a>4. 装饰者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</span><br><span class="line">结构</span><br><span class="line">	装饰（Decorator）模式中的角色：</span><br><span class="line">           * 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</span><br><span class="line">           * 具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</span><br><span class="line">           * 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</span><br><span class="line">           * 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</span><br><span class="line">   使用场景</span><br><span class="line">       * 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</span><br><span class="line">             不能采用继承的情况主要有两类：</span><br><span class="line">                 * 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</span><br><span class="line">                 * 第二类是因为类定义不能继承（如 final 类）</span><br><span class="line">       * 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</span><br><span class="line">       * 当对象的功能要求可以动态地添加，也可以再动态地撤销时。</span><br><span class="line">  好处：</span><br><span class="line"></span><br><span class="line">       * 装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</span><br><span class="line">       * 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</span><br><span class="line">    代理和装饰者的区别：</span><br><span class="line">    	相同点：</span><br><span class="line">    		- 都要实现与目标类相同的业务接口</span><br><span class="line">    		- 在两个类中都要声明目标对象</span><br><span class="line">    		- 都可以在不修改目标类的前提下增强目标方法</span><br><span class="line">    	不同点：</span><br><span class="line">    		- 目的不同：代理是为了隐藏对象，装饰着是增强对象</span><br><span class="line">    		- 创建对象的方式不同：代理是在内部创建，装饰着是由外部传入</span><br></pre></td></tr></table></figure>



<h2 id="5-桥接模式"><a href="#5-桥接模式" class="headerlink" title="5. 桥接模式"></a>5. 桥接模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</span><br><span class="line">结构 </span><br><span class="line">   	桥接（Bridge）模式包含以下主要角色：</span><br><span class="line">           * 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</span><br><span class="line">           * 扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</span><br><span class="line">           * 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</span><br><span class="line">           * 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</span><br><span class="line">    好处：</span><br><span class="line">    	* 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</span><br><span class="line">	* 实现细节对客户透明</span><br><span class="line"> 使用场景</span><br><span class="line">       * 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</span><br><span class="line">       * 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</span><br><span class="line">       * 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</span><br></pre></td></tr></table></figure>



<h2 id="6-外观模式"><a href="#6-外观模式" class="headerlink" title="6. 外观模式"></a>6. 外观模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。外观（Facade）模式是“迪米特法则”的典型应用</span><br><span class="line">  结构</span><br><span class="line">外观（Facade）模式包含以下主要角色：</span><br><span class="line">          * 外观（Facade）角色：为多个子系统对外提供一个共同的接口。</span><br><span class="line">          * 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</span><br><span class="line">   好处：</span><br><span class="line">      * 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</span><br><span class="line">      * 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</span><br><span class="line">   缺点：</span><br><span class="line">      * 不符合开闭原则，修改很麻烦</span><br><span class="line">   使用场景</span><br><span class="line">      * 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</span><br><span class="line">      * 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</span><br><span class="line">      * 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</span><br></pre></td></tr></table></figure>

<h2 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7. 组合模式"></a>7. 组合模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构</span><br><span class="line">结构</span><br><span class="line">       组合模式主要包含三种角色：</span><br><span class="line">           * 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</span><br><span class="line">           * 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</span><br><span class="line">           * 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</span><br><span class="line">   优点</span><br><span class="line">       * 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</span><br><span class="line">       * 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</span><br><span class="line">       * 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</span><br><span class="line">       * 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</span><br><span class="line">   使用场景</span><br><span class="line">       组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</span><br><span class="line">    分类：</span><br><span class="line">    	透明组合：在根节点中定义了管理成员对象的所有方法，透明组合是组合模式的标准形式</span><br><span class="line">    	安全组合：根节点和叶子节点是分开定义的，客户端不能完成针对抽象编程，必须区别对待叶子节点和容器构件</span><br></pre></td></tr></table></figure>



<h2 id="8-享元模式"><a href="#8-享元模式" class="headerlink" title="8. 享元模式"></a>8. 享元模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</span><br><span class="line">   结构</span><br><span class="line">       享元（Flyweight ）模式中存在以下两种状态：</span><br><span class="line">           1. 内部状态，即不会随着环境的改变而改变的可共享部分。</span><br><span class="line">           2. 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</span><br><span class="line"></span><br><span class="line">       享元模式的主要有以下角色：</span><br><span class="line">           * 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</span><br><span class="line">           * 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</span><br><span class="line">           * 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</span><br><span class="line">           * 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</span><br><span class="line">    优点</span><br><span class="line">	- 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</span><br><span class="line">	- 享元模式中的外部状态相对独立，且不影响内部状态</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">	为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</span><br><span class="line">使用场景：</span><br><span class="line">       - 一个系统有大量相同或者相似的对象，造成内存的大量耗费。</span><br><span class="line">       - 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</span><br><span class="line">       - 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式</span><br></pre></td></tr></table></figure>

</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>spvian</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" title="05_结构型模式">http://example.com/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" rel="prev" title="06_行为型模式"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">06_行为型模式</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_UML%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9B%BE/" rel="next" title="02_UML"><span class="post-nav-text">02_UML</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> spvian</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><div class="aplayer no-destroy" id="aplayer" data-id="308168565" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay data-theme="#0078E7" data-loop="all" data-order="list" data-preload="auto" data-volume="0.7" data-mutex data-lrctype="0" data-listmaxheight="340px" data-storagename="metingjs"></div></div></body></html>