<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="2021/06/02/JVM/05_%E5%A0%86/"/>
      <url>2021/06/02/JVM/05_%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">参数链接</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个 JVM 实例只存在一个堆内存，是 Java 内存管理的核心区域</span><br><span class="line">堆内存的大小在 JVM 启动时确定的，是 JVM 管理的最大的内存空间，堆空间在启动前是可以调节的，内存在物理上可以是不连续的，在逻辑上是连续的</span><br><span class="line">堆被所有的线程共享，在堆中可以划分线程的私有缓冲区（Thread Local Allocation Buffer，TLAB）一个进程只有一个对空间</span><br><span class="line">       -XX:+PrintFlagsInitial  //查看所有的参数的默认初始值</span><br><span class="line">       -XX:+PrintFlagsFinal  //查看所有的参数的最终值（可能会存在修改，不再是初始值）</span><br><span class="line">       -Xms  //初始堆空间内存（默认为物理内存的1/64）</span><br><span class="line">       -Xmx  //最大堆空间内存（默认为物理内存的1/4）</span><br><span class="line">       -Xmn  //设置新生代的大小。（初始值及最大值）</span><br><span class="line">       -XX:NewRatio  //配置新生代与老年代在堆结构的占比</span><br><span class="line">       -XX:SurvivorRatio  //设置新生代中Eden和S0/S1空间的比例</span><br><span class="line">       -XX:MaxTenuringThreshold  //设置新生代垃圾的最大年龄</span><br><span class="line">       -XX:+PrintGCDetails //输出详细的GC处理日志</span><br><span class="line">       //打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</span><br><span class="line">       -XX:HandlePromotionFalilure：//是否设置空间分配担保</span><br></pre></td></tr></table></figure><img src="04_堆.assets/image-20210602144712044.png" alt="image-20210602144712044" style="zoom:67%;" / loading="lazy"><h2 id="2-内存分配"><a href="#2-内存分配" class="headerlink" title="2. 内存分配"></a>2. 内存分配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms：用于表示堆区的起始内存，等价于 -XX:InitialHeapSize</span><br><span class="line">-Xmx：用于表示堆区的最大内存，等价于 -XX:MaxHeapSize</span><br><span class="line">两者一般设置为同等大小，避免 java 垃圾回收机制清理堆区后不需要重新分隔计算堆区的大小，从而提高性能。</span><br><span class="line">默认大小：</span><br><span class="line">• 初始内存大小：物理电脑内存大小 / 64</span><br><span class="line">• 最大内存大小：物理电脑内存大小 / 4</span><br></pre></td></tr></table></figure><img src="05_堆.assets/image-20210602150441065.png" alt="image-20210602150441065" style="zoom:67%;" / loading="lazy"><h3 id="2-1-年轻代与老年代"><a href="#2-1-年轻代与老年代" class="headerlink" title="2.1 年轻代与老年代"></a>2.1 年轻代与老年代</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java 对象在 JVM 中被分为两类：</span><br><span class="line">年轻代：生命周期较短的瞬时对象，对象的创建和消亡都非常迅速</span><br><span class="line">老年代：对象的生命周期非常长，在某些极端的情况下能够与　JVM　的生命周期保持一致</span><br><span class="line">内存比例：</span><br><span class="line">默认-XX:NewRatio=2，表示新生代占　1，老年代占　2，新生代占整个堆的　1/3</span><br><span class="line">在　HotSpot　中，Eden　空间和另外两个　survivor　空间缺省所占的比例是　8：1：1，-xx:SurvivorRatio＝８</span><br><span class="line">分配策略：</span><br><span class="line">新生代的　Java　对象在年龄为　15　时，会被晋升到老年代</span><br><span class="line">年龄限制：-Xx:MaxTenuringThreshold= N。默认为　15</span><br></pre></td></tr></table></figure><h2 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3. 垃圾回收"></a>3. 垃圾回收</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收指清除不在使用的 java 对象</span><br><span class="line">Hotspot VM 的 GC 按照回收区域分为两大种类型：部分收集（Partial GC）、整堆收集（FullGC）</span><br><span class="line">整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾。</span><br><span class="line">部分收集：不是完整的整个 Java 堆的垃圾收集。其中又分为：</span><br><span class="line">• 新生代收集（Minor GC / Young GC）：新生代的垃圾收集</span><br><span class="line">在新生代内存不足时触发</span><br><span class="line">           • 老年代收集（Major GC / Old GC）：老年代的垃圾收集。</span><br><span class="line">           在老年代内存不足时触发</span><br><span class="line">           目前，只有 CMS GC 会有单独收集老年代的行为。</span><br><span class="line">          注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</span><br><span class="line">           • 混合收集（MixedGC）：收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 GC 会有这种行为</span><br></pre></td></tr></table></figure><h2 id="4-空间分代"><a href="#4-空间分代" class="headerlink" title="4. 空间分代"></a>4. 空间分代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不同对象的生命周期不同。70%-99% 的对象是临时对象。分代是为了区分临时对象，在为回收临时对象避免全局扫描，在进行全局扫描时是非常耗时的，会降低吞吐量或者高延迟</span><br></pre></td></tr></table></figure><h2 id="5-TLAB"><a href="#5-TLAB" class="headerlink" title="5. TLAB"></a>5. TLAB</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread Local Allocation Buffer</span><br><span class="line">通过 -XX:UseTLAB 设置是否开启 TLAB 空间，默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，通过 -XX:TLABWasteTargetPercent 设置 TLAB 空间的百分比大小。</span><br><span class="line">对象的创建在 JVM 中非常频繁，在并发环境下从堆区中划分内存空间是线程不安全的，为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</span><br><span class="line">JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。</span><br><span class="line">在多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，将这种内存分配方式称之为快速分配策略。</span><br><span class="line">通过 -XX:UseTLAB 设置是否开启 TLAB 空间</span><br></pre></td></tr></table></figure><h2 id="6-对象分配"><a href="#6-对象分配" class="headerlink" title="6. 对象分配"></a>6. 对象分配</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么 “ 绝对 ” 了。</span><br></pre></td></tr></table></figure><h3 id="6-1-逃逸分析"><a href="#6-1-逃逸分析" class="headerlink" title="6.1 逃逸分析"></a>6.1 逃逸分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 JDK1.6 之后默认开启</span><br><span class="line">是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</span><br><span class="line">逃逸分析的基本行为就是分析对象动态作用域：</span><br><span class="line">• 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸</span><br><span class="line">• 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/02/JVM/04_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>2021/06/02/JVM/04_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存放运行时程序所需要的数据</span><br></pre></td></tr></table></figure><img src="04_运行时数据区.assets/image-20210602171646349.png" alt="image-20210602171646349" style="zoom:67%;" / loading="lazy"><h2 id="2-线程私有"><a href="#2-线程私有" class="headerlink" title="2. 线程私有"></a>2. 线程私有</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序计数器、本地方法栈、java 栈</span><br></pre></td></tr></table></figure><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是一块很小的内存空间，几乎可以忽略不记，是运行速度最快的存储区域。</span><br><span class="line">JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟。用来存储指向下一条指令的地址，是将要执行的指令代码。由执行引擎读取下一条指令，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，</span><br><span class="line">JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令</span><br></pre></td></tr></table></figure><h2 id="3-线程间共享"><a href="#3-线程间共享" class="headerlink" title="3. 线程间共享"></a>3. 线程间共享</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">堆、方法区</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/02/JVM/01_JVM/"/>
      <url>2021/06/02/JVM/01_JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HotSpot VM是目前市面上高性能虚拟机的代表作之一，它采用解释器与即时编译器并存的架构。</span><br><span class="line">JVM 是一种基于栈的指令集架构</span><br><span class="line">特点：</span><br><span class="line">• 设计和实现更简单，适用于资源受限的系统</span><br><span class="line">        • 避开了寄存器的分配难题：使用零地址指令方式分配</span><br><span class="line">        • 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</span><br><span class="line">        • 不需要硬件支持，可移植性更好，更好实现跨平台</span><br></pre></td></tr></table></figure><img src="内存分析.assets/image-20210601220016088.png" alt="image-20210601220016088" style="zoom: 50%;" / loading="lazy"><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动：通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</span><br><span class="line">执行：随着程序的开始而开始，程序的结束而结束</span><br><span class="line">退出：正常退出、遇到异常或错误、手动退出（调用 System.exit（））、操作系统的错误</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/02/JVM/02_%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>2021/06/02/JVM/02_%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>参考 <a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a></p><p>全文只为便于个人理解和记忆</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM 针对各种操作系统、平台都进行了定制，无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供 JVM 使用</span><br><span class="line">节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取</span><br><span class="line">字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益</span><br></pre></td></tr></table></figure><h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.class 文件打开后是十六进制数</span><br><span class="line">JVM 规范要求每一个字节码文件都要由十部分按照固定的顺序组成</span><br></pre></td></tr></table></figure><img src="字节码.assets/image-20210531225201096.png" alt="image-20210531225201096" style="zoom:67%;" / loading="lazy"><h3 id="2-1-魔数（Magic-Number）"><a href="#2-1-魔数（Magic-Number）" class="headerlink" title="2.1 魔数（Magic Number）"></a>2.1 魔数（Magic Number）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">魔数（Magic Number）：所有的 .class 文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE</span><br></pre></td></tr></table></figure><h3 id="2-2-版本号"><a href="#2-2-版本号" class="headerlink" title="2.2 版本号"></a>2.2 版本号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）</span><br></pre></td></tr></table></figure><h3 id="2-3-常量池（Constant-Pool）"><a href="#2-3-常量池（Constant-Pool）" class="headerlink" title="2.3 常量池（Constant Pool）"></a>2.3 常量池（Constant Pool）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">紧接着主版本号之后的字节为常量池入口。常量池中存储两类常量：字面量与符号引用。字面量为代码中声明为 Final 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分：常量池计数器以及常量池数据区</span><br><span class="line">常量池计数器：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。</span><br><span class="line">常量池数据区：数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。</span><br><span class="line">通过 javap -verbose 可通过反编译查看常量池</span><br></pre></td></tr></table></figure><p>​    <a href="https://p0.meituan.net/travelcube/f5bdc7e8203ec666a531fcd19cdbcddc519208.png">数据区参照表</a></p><img src="字节码.assets/ac90457d635b90e2c08bf7659b0b7dfd50229.png" style="zoom:50%;" / loading="lazy"><img src="https://p1.meituan.net/travelcube/a230e57d6737ff00b1fa38d5265255db301604.png" style="zoom: 50%;" / loading="lazy"><h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="2.4 访问标志"></a>2.4 访问标志</h3><p><a href="https://p0.meituan.net/travelcube/7a750dfc34fa8f54f45c261bc8dd67f4222300.png">修饰符</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 Public、Abstract、Final 等修饰符修饰。</span><br><span class="line">JVM 没有穷举所有的访问标志，而是使用按位或操作来进行描述的</span><br><span class="line">某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010 =0x0011</span><br></pre></td></tr></table></figure><h3 id="2-5-当前类名"><a href="#2-5-当前类名" class="headerlink" title="2.5 当前类名"></a>2.5 当前类名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问标志后的两个字节，描述的是当前类的全限定名，为常量池中的索引值</span><br></pre></td></tr></table></figure><h3 id="2-6-父类名称"><a href="#2-6-父类名称" class="headerlink" title="2.6 父类名称"></a>2.6 父类名称</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前类名后的两个字节，描述父类的全限定名，为常量池中的索引值</span><br></pre></td></tr></table></figure><h3 id="2-7-接口信息"><a href="#2-7-接口信息" class="headerlink" title="2.7 接口信息"></a>2.7 接口信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量，后 n 个字节是所有接口名称的字符串常量的索引值。</span><br></pre></td></tr></table></figure><h3 id="2-8-字段表"><a href="#2-8-字段表" class="headerlink" title="2.8 字段表"></a>2.8 字段表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量</span><br><span class="line">   字段表也分为两部分：</span><br><span class="line">   第一部分为两个字节，描述字段个数</span><br><span class="line">   第二部分是每个字段的详细信息 fields_info</span><br></pre></td></tr></table></figure><img src="https://p0.meituan.net/travelcube/0f795d2b2b28ce96b5963efb2e564e5a197874.png" style="zoom:67%;" / loading="lazy"><h3 id="2-9-方法表"><a href="#2-9-方法表" class="headerlink" title="2.9 方法表"></a>2.9 方法表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字段表结束后为方法表，方法表也是由两部分组成</span><br><span class="line">第一部分为两个字节描述方法的个数</span><br><span class="line">第二部分为每个方法的详细信息</span><br><span class="line">Code 区：源代码对应的 JVM 指令操作码，在进行字节码增强时重点操作的就是 Code 区这一部分。</span><br><span class="line">LineNumberTable：行号表，将 Code 区的操作码和源代码中的行号对应，Debug 时会起到作用（源代码走一行，需要走多少个JVM 指令操作码）。</span><br><span class="line">LocalVariableTable：本地变量表，包含 This 和局部变量，之所以可以在每一个方法内部都可以调用 This，是因为 JVM 将This 作为每一个方法的第一个参数隐式进行传入。当然，这是针对非 Static 方法而言。</span><br></pre></td></tr></table></figure><img src="字节码.assets/d84d5397da84005d9e21d5289afa29e755614.png" style="zoom:67%;" / loading="lazy"><img src="字节码.assets/image-20210531233642006.png" alt="image-20210531233642006" style="zoom: 50%;" / loading="lazy"><h3 id="2-10-附加属性表"><a href="#2-10-附加属性表" class="headerlink" title="2.10 附加属性表"></a>2.10 附加属性表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息</span><br></pre></td></tr></table></figure><h2 id="3-字节码操作集合"><a href="#3-字节码操作集合" class="headerlink" title="3. 字节码操作集合"></a>3. 字节码操作集合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code 区的红色编号 0～4，就是 .java 中的方法源代码编译后让 JVM 真正执行的操作码，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看 Oracle 官方文档进行了解</span><br></pre></td></tr></table></figure><p><img src="%E5%AD%97%E8%8A%82%E7%A0%81.assets/image-20210601105154274.png" alt="image-20210601105154274" loading="lazy"></p><h2 id="4-操作数栈和字节码"><a href="#4-操作数栈和字节码" class="headerlink" title="4. 操作数栈和字节码"></a>4. 操作数栈和字节码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM 的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个 FILO 结构，需要频繁压栈出栈），由于栈是在内存实现的，而寄存器是在CPU的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/02/JVM/03_ClassLoader/"/>
      <url>2021/06/02/JVM/03_ClassLoader/</url>
      
        <content type="html"><![CDATA[<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 类加载器子系统负责从文件系统或者网络中加载 class 文件，class 文件在文件开头有特定的文件标识。</span><br><span class="line"> 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</span><br><span class="line">JVM 支持两种类型的类加载器</span><br><span class="line">引导类加载器（Bootstrap ClassLoader）、自定义类加载器（User-Defined ClassLoader）</span><br><span class="line"> 启动类加载器（引导类加载器，Bootstrap ClassLoader）</span><br><span class="line"> 使用 C/C++ 语言实现的，嵌套在 JVM 内部，只加载包名为java、javax、sun等开头的类</span><br><span class="line"> 扩展类加载器（Extension ClassLoader</span><br><span class="line"> Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现，从 java.ext.dirs 系统属性所指定的目录中加载类库</span><br><span class="line"> 应用程序类加载器（系统类加载器，AppClassLoader）</span><br><span class="line"> java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现，它负责加载环境变量 classpath 或系统属性 ava.class.path 指定路径下的类库，该类加载是程序中默认的类加载器</span><br></pre></td></tr></table></figure><img src="ClassLoader.assets/image-20210602083038400.png" alt="image-20210602083038400" style="zoom: 67%;" / loading="lazy"><h2 id="2-加载"><a href="#2-加载" class="headerlink" title="2. 加载"></a>2. 加载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过类的全限定类名加载 .class 为二进制流中，把静态存储结构转为方法区的运行时结构，生成 java.lang.Class 对象，作为方法区数据的访问入口</span><br></pre></td></tr></table></figure><h2 id="3-链接"><a href="#3-链接" class="headerlink" title="3. 链接"></a>3. 链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分为三个阶段</span><br><span class="line">验证：保证 .class 文件的正确性，验证方式：文件格式验证、元数据验证、字节码验证、符号引用验证</span><br><span class="line">准备：为类变量分配内存并设置默认值，不包含 final 修饰的 static，final 修饰的在编译期间分配内存，在准备阶段显示初始化。不会为实例变量初始化</span><br><span class="line">解析：将常量池中的符号引用转为直接引用，事实上常在 JVM 完成初始化完成后执行</span><br></pre></td></tr></table></figure><h2 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行类构造器方法 &lt;clinit&gt;() 的过程，此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。保证一个类的 &lt;clinit&gt;() 方法在多线程下被同步加锁</span><br></pre></td></tr></table></figure><h2 id="5-双亲委派机制"><a href="#5-双亲委派机制" class="headerlink" title="5. 双亲委派机制"></a>5. 双亲委派机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类加载器在加载 .class 时，先把这个任务交给父类，如果父类有它的父类，一直向上委派，直到加载器为引用类加载器。若引用类能加载则加载，若不能则交给子类加载，若子类不能，子类交给它的子类，直到初始加载器，若也不能加载，则报错</span><br></pre></td></tr></table></figure><h2 id="6-判断对象的相等"><a href="#6-判断对象的相等" class="headerlink" title="6. 判断对象的相等"></a>6. 判断对象的相等</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM中 表示两个class 对象是否为同一个类，需要类的全限定类名相同，类的加载器也相同，</span><br></pre></td></tr></table></figure><h2 id="7-类的主动和被动"><a href="#7-类的主动和被动" class="headerlink" title="7. 类的主动和被动"></a>7. 类的主动和被动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java 程序对类的使用方式分为：主动使用和被动使用。</span><br><span class="line">主动使用，又分为七种情况：</span><br><span class="line">创建类实例、调用静态变量、调用静态方法、放射、初始化子类、jvm 启动时被标明为启动类的类、动态语言的支持</span><br><span class="line">被动使用：指不会进行类的初始化</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01_%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/"/>
      <url>2021/06/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01_%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1. 线性表"></a>1. 线性表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线性表是具有 n 个相同类型元素的有限序列（ n ≥ 0 ）</span><br><span class="line">常见的线性表：</span><br><span class="line">数组、链表、栈、队列、哈希表（散列表）</span><br></pre></td></tr></table></figure><p><img src="Untitled.assets/image-20210525093437460.png" alt="image-20210525093437460" loading="lazy"></p><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是一种顺序存储的线性表，所有元素的内存地址是连续的，但无法动态修改容量</span><br></pre></td></tr></table></figure><h3 id="2-1-动态数组"><a href="#2-1-动态数组" class="headerlink" title="2.1 动态数组"></a>2.1 动态数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JDK 中内置了一个动态数组类：java.util.ArrayList</span><br><span class="line">接口设计：</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;<span class="comment">// 是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;<span class="comment">// 添加元素到最后面</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">// 返回index位置对应的元素</span></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 设置index位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 往index位置添加元素</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">// 删除index位置对应的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;<span class="comment">// 查看元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">// 清除所有元素</span></span><br></pre></td></tr></table></figure><h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的</span><br></pre></td></tr></table></figure><p>习题：</p><p>​    <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a>、<a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>、<a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>、<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a>、<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a>、<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></p><h3 id="3-1-单项链表"><a href="#3-1-单项链表" class="headerlink" title="3.1 单项链表"></a>3.1 单项链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">链表的大部分接口和动态数组是一致的</span><br><span class="line">接口设计：</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>;<span class="comment">// 是否包含某个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>;<span class="comment">// 添加元素到最后面</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">// 返回index位置对应的元素</span></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 设置index位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 往index位置添加元素</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">// 删除index位置对应的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>;<span class="comment">// 查看元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">// 清除所有元素</span></span><br></pre></td></tr></table></figure><img src="Untitled.assets/image-20210525092916609.png" alt="image-20210525092916609" style="zoom:50%;" / loading="lazy"><h3 id="3-2-双向链表"><a href="#3-2-双向链表" class="headerlink" title="3.2 双向链表"></a>3.2 双向链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK 中的 java.util.LinkedLis 是双向链表</span><br><span class="line">接口同单项链表</span><br></pre></td></tr></table></figure><img src="Untitled.assets/image-20210525093552452.png" alt="image-20210525093552452" style="zoom: 50%;" / loading="lazy"><h4 id="3-2-1-对比动态数组"><a href="#3-2-1-对比动态数组" class="headerlink" title="3.2.1 对比动态数组"></a>3.2.1 对比动态数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 动态数组：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）</span><br><span class="line">双向链表：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费</span><br><span class="line">使用事项：</span><br><span class="line">       频繁在尾部进行添加、删除操作，动态数组、双向链表均可选择</span><br><span class="line">       频繁在头部进行添加、删除操作，建议选择使用双向链表</span><br><span class="line">       频繁的（在任意位置）添加、删除操作，建议选择使用双向链表</span><br><span class="line">       频繁的查询操作（随机访问操作），建议选择使用动态数组</span><br></pre></td></tr></table></figure><h3 id="3-3-单向循环链表"><a href="#3-3-单向循环链表" class="headerlink" title="3.3 单向循环链表"></a>3.3 单向循环链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在单向链表的基础上添加了一条由尾部指向头部的索引</span><br></pre></td></tr></table></figure><img src="Untitled.assets/image-20210525094307436.png" alt="image-20210525094307436" style="zoom:50%;" / loading="lazy"><h3 id="3-4-双向循序链表"><a href="#3-4-双向循序链表" class="headerlink" title="3.4 双向循序链表"></a>3.4 双向循序链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在双向链表的基础上添加了一条由尾部指向头部的索引</span><br></pre></td></tr></table></figure><img src="Untitled.assets/image-20210525095021943.png" alt="image-20210525095021943" style="zoom: 50%;" / loading="lazy"><h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4. 栈"></a>4. 栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">栈是一种特殊的线性表，只能在一端进行操作。后进先出的原则，Last In First Out，LIFO</span><br><span class="line">接口设计：        </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">// 元素的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">// 是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E element)</span></span>;<span class="comment">// 入栈</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;<span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">E <span class="title">top</span><span class="params">()</span></span>;<span class="comment">// 获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">// 清空</span></span><br></pre></td></tr></table></figure><img src="Untitled.assets/image-20210525100133137.png" alt="image-20210525100133137" style="zoom:50%;" / loading="lazy"><p>习题：</p><p>​    <a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a>、<a href="https://leetcode-cn.com/problems/score-of-parentheses/">856. 括号的分数</a>、<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>、<a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></p><h2 id="5-队列"><a href="#5-队列" class="headerlink" title="5. 队列"></a>5. 队列</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">队列是一种特殊的线性表，只能在头尾两端进行操作,从队尾添加元素,从队头移除元素.先进先出的原则，First In First Out，FIFO</span><br><span class="line">接口设计：</span><br><span class="line">    int size(); // 元素的数量</span><br><span class="line">    boolean isEmpty(); // 是否为空</span><br><span class="line">    void clear(); // 清空</span><br><span class="line">    void enQueue(E element) // 入队</span><br><span class="line">    E deQueue(); // 出队</span><br><span class="line">    E front(); // 获取队列的头元素</span><br></pre></td></tr></table></figure><p><img src="Untitled.assets/image-20210525100114806.png" alt="image-20210525100114806" loading="lazy"></p><p>习题：</p><p>​    <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>、<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></p><h3 id="5-1-双端队列"><a href="#5-1-双端队列" class="headerlink" title="5.1 双端队列"></a>5.1 双端队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">双端队列是能在头尾两端添加、删除的队列</span><br><span class="line">接口设计：</span><br><span class="line">    int size();// 元素的数量</span><br><span class="line">    boolean isEmpty();// 是否为空</span><br><span class="line">    void clear();// 清空</span><br><span class="line">    void enQueueRear(E element);// 从队尾入队</span><br><span class="line">    E deQueueFront();// 从队头出队</span><br><span class="line">    void enQueueFront(E element);// 从队头入队</span><br><span class="line">    E deQueueRear();// 从队尾出队</span><br><span class="line">    E front(); // 获取队列的头元素</span><br><span class="line">    E rear(); // 获取队列的尾元</span><br></pre></td></tr></table></figure><h3 id="5-2-循环队列"><a href="#5-2-循环队列" class="headerlink" title="5.2 循环队列"></a>5.2 循环队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以进行两端添加、删除操作的循环队列</span><br><span class="line">尽量避免使用乘*、除/、模%、浮点数运算，效率低下</span><br><span class="line">n % m 等价于 n – (m &gt; n ? 0 : m) 的前提条件：n &lt; 2m</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/01/JVM/%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>2021/06/01/JVM/%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>参考 <a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a></p><p>全文只为便于个人理解和记忆</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM 针对各种操作系统、平台都进行了定制，无论在什么平台，都可以编译生成固定格式的字节码（.class文件）供 JVM 使用</span><br><span class="line">节码文件由十六进制值组成，而 JVM 以两个十六进制值为一组，即以字节为单位进行读取</span><br><span class="line">字节码增强技术在 Spring AOP、各种 ORM 框架、热部署中的应用屡见不鲜，深入理解其原理对于我们来说大有裨益</span><br></pre></td></tr></table></figure><h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.class 文件打开后是十六进制数</span><br><span class="line">JVM 规范要求每一个字节码文件都要由十部分按照固定的顺序组成</span><br></pre></td></tr></table></figure><img src="字节码.assets/image-20210531225201096.png" alt="image-20210531225201096" style="zoom:67%;" / loading="lazy"><h3 id="2-1-魔数（Magic-Number）"><a href="#2-1-魔数（Magic-Number）" class="headerlink" title="2.1 魔数（Magic Number）"></a>2.1 魔数（Magic Number）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">魔数（Magic Number）：所有的 .class 文件的前四个字节都是魔数，魔数的固定值为：0xCAFEBABE</span><br></pre></td></tr></table></figure><h3 id="2-2-版本号"><a href="#2-2-版本号" class="headerlink" title="2.2 版本号"></a>2.2 版本号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）</span><br></pre></td></tr></table></figure><h3 id="2-3-常量池（Constant-Pool）"><a href="#2-3-常量池（Constant-Pool）" class="headerlink" title="2.3 常量池（Constant Pool）"></a>2.3 常量池（Constant Pool）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">紧接着主版本号之后的字节为常量池入口。常量池中存储两类常量：字面量与符号引用。字面量为代码中声明为 Final 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分：常量池计数器以及常量池数据区</span><br><span class="line">常量池计数器：由于常量的数量不固定，所以需要先放置两个字节来表示常量池容量计数值。</span><br><span class="line">常量池数据区：数据区是由（constant_pool_count-1）个 cp_info 结构组成，一个 cp_info 结构对应一个常量。</span><br><span class="line">通过 javap -verbose 可通过反编译查看常量池</span><br></pre></td></tr></table></figure><p>​    <a href="https://p0.meituan.net/travelcube/f5bdc7e8203ec666a531fcd19cdbcddc519208.png">数据区参照表</a></p><img src="字节码.assets/ac90457d635b90e2c08bf7659b0b7dfd50229.png" style="zoom:50%;" / loading="lazy"><img src="https://p1.meituan.net/travelcube/a230e57d6737ff00b1fa38d5265255db301604.png" style="zoom: 50%;" / loading="lazy"><h3 id="2-4-访问标志"><a href="#2-4-访问标志" class="headerlink" title="2.4 访问标志"></a>2.4 访问标志</h3><p><a href="https://p0.meituan.net/travelcube/7a750dfc34fa8f54f45c261bc8dd67f4222300.png">修饰符</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常量池结束之后的两个字节，描述该 Class 是类还是接口，以及是否被 Public、Abstract、Final 等修饰符修饰。</span><br><span class="line">JVM 没有穷举所有的访问标志，而是使用按位或操作来进行描述的</span><br><span class="line">某个类的修饰符为 Public Final，则对应的访问修饰符的值为 ACC_PUBLIC | ACC_FINAL，即 0x0001 | 0x0010 =0x0011</span><br></pre></td></tr></table></figure><h3 id="2-5-当前类名"><a href="#2-5-当前类名" class="headerlink" title="2.5 当前类名"></a>2.5 当前类名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问标志后的两个字节，描述的是当前类的全限定名，为常量池中的索引值</span><br></pre></td></tr></table></figure><h3 id="2-6-父类名称"><a href="#2-6-父类名称" class="headerlink" title="2.6 父类名称"></a>2.6 父类名称</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前类名后的两个字节，描述父类的全限定名，为常量池中的索引值</span><br></pre></td></tr></table></figure><h3 id="2-7-接口信息"><a href="#2-7-接口信息" class="headerlink" title="2.7 接口信息"></a>2.7 接口信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类名称后为两字节的接口计数器，描述了该类或父类实现的接口数量，后 n 个字节是所有接口名称的字符串常量的索引值。</span><br></pre></td></tr></table></figure><h3 id="2-8-字段表"><a href="#2-8-字段表" class="headerlink" title="2.8 字段表"></a>2.8 字段表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量</span><br><span class="line">   字段表也分为两部分：</span><br><span class="line">   第一部分为两个字节，描述字段个数</span><br><span class="line">   第二部分是每个字段的详细信息 fields_info</span><br></pre></td></tr></table></figure><img src="https://p0.meituan.net/travelcube/0f795d2b2b28ce96b5963efb2e564e5a197874.png" style="zoom:67%;" / loading="lazy"><h3 id="2-9-方法表"><a href="#2-9-方法表" class="headerlink" title="2.9 方法表"></a>2.9 方法表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字段表结束后为方法表，方法表也是由两部分组成</span><br><span class="line">第一部分为两个字节描述方法的个数</span><br><span class="line">第二部分为每个方法的详细信息</span><br><span class="line">Code 区：源代码对应的 JVM 指令操作码，在进行字节码增强时重点操作的就是 Code 区这一部分。</span><br><span class="line">LineNumberTable：行号表，将 Code 区的操作码和源代码中的行号对应，Debug 时会起到作用（源代码走一行，需要走多少个JVM 指令操作码）。</span><br><span class="line">LocalVariableTable：本地变量表，包含 This 和局部变量，之所以可以在每一个方法内部都可以调用 This，是因为 JVM 将This 作为每一个方法的第一个参数隐式进行传入。当然，这是针对非 Static 方法而言。</span><br></pre></td></tr></table></figure><img src="字节码.assets/d84d5397da84005d9e21d5289afa29e755614.png" style="zoom:67%;" / loading="lazy"><img src="字节码.assets/image-20210531233642006.png" alt="image-20210531233642006" style="zoom: 50%;" / loading="lazy"><h3 id="2-10-附加属性表"><a href="#2-10-附加属性表" class="headerlink" title="2.10 附加属性表"></a>2.10 附加属性表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息</span><br></pre></td></tr></table></figure><h2 id="3-字节码操作集合"><a href="#3-字节码操作集合" class="headerlink" title="3. 字节码操作集合"></a>3. 字节码操作集合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code 区的红色编号 0～4，就是 .java 中的方法源代码编译后让 JVM 真正执行的操作码，反编译后看到的是十六进制操作码所对应的助记符，十六进制值操作码与助记符的对应关系，以及每一个操作码的用处可以查看 Oracle 官方文档进行了解</span><br></pre></td></tr></table></figure><p><img src="%E5%AD%97%E8%8A%82%E7%A0%81.assets/image-20210601105154274.png" alt="image-20210601105154274" loading="lazy"></p><h2 id="4-操作数栈和字节码"><a href="#4-操作数栈和字节码" class="headerlink" title="4. 操作数栈和字节码"></a>4. 操作数栈和字节码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM 的指令集是基于栈而不是寄存器，基于栈可以具备很好的跨平台性（因为寄存器指令集往往和硬件挂钩），但缺点在于，要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈只是一个 FILO 结构，需要频繁压栈出栈），由于栈是在内存实现的，而寄存器是在CPU的高速缓存区，相较而言，基于栈的速度要慢很多，这也是为了跨平台性而做出的牺牲。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/06/01/Java/Java-04_IO/"/>
      <url>2021/06/01/Java/Java-04_IO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java-IO"></a>Java-IO</h1><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java 的 I/O 可以分成以下几类：</span><br><span class="line">    磁盘操作：File</span><br><span class="line">    字节操作：InputStream 和 OutputStream</span><br><span class="line">    字符操作：Reader 和 Writer</span><br><span class="line">    对象操作：Serializable</span><br><span class="line">    网络操作：Socket</span><br><span class="line">    新的输入/输出：NIO</span><br></pre></td></tr></table></figure><h2 id="2-磁盘操作"><a href="#2-磁盘操作" class="headerlink" title="2. 磁盘操作"></a>2. 磁盘操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。从 Java7 开始，可以使用 Paths 和 Files 代替 File。</span><br></pre></td></tr></table></figure><h2 id="3-字节操作"><a href="#3-字节操作" class="headerlink" title="3. 字节操作"></a>3. 字节操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顶级接口：InputStream 和 OutputStream </span><br><span class="line">常见实现类：FileInputStream、FileInputStream</span><br><span class="line">设计模式：装饰者模式</span><br><span class="line">修饰类：BufferedInputStream、BufferedOutputStream</span><br></pre></td></tr></table></figure><h2 id="4-字符操作"><a href="#4-字符操作" class="headerlink" title="4. 字符操作"></a>4. 字符操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">顶级接口：Reader 和 Writer</span><br><span class="line">常用实现类：FilterWriter、FilterWriter</span><br><span class="line">修饰类：BufferedReader、BufferedWriter</span><br><span class="line">编码：</span><br><span class="line">       GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</span><br><span class="line">       UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</span><br><span class="line">       UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</span><br></pre></td></tr></table></figure><p><img src="Java-04_IO.assets/image-20210522202918479.png" alt="image-20210522202918479" loading="lazy"></p><h2 id="5-字节与字符的转换"><a href="#5-字节与字符的转换" class="headerlink" title="5. 字节与字符的转换"></a>5. 字节与字符的转换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader 实现从字节流解码成字符流；</span><br><span class="line">OutputStreamWriter 实现字符流编码成为字节流。</span><br></pre></td></tr></table></figure><h2 id="6-容器中的-IO"><a href="#6-容器中的-IO" class="headerlink" title="6. 容器中的 IO"></a>6. 容器中的 IO</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Properties 继承于 Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串</span><br><span class="line">public void load(InputStream inStream) ： 从字节输入流中读取键值对。</span><br></pre></td></tr></table></figure><h2 id="7-序列化"><a href="#7-序列化" class="headerlink" title="7. 序列化"></a>7. 序列化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   将一个对象转换成字节序列，方便存储和传输。</span><br><span class="line">   序列化：ObjectOutputStream.writeObject()</span><br><span class="line">反序列化：ObjectInputStream.readObject()</span><br><span class="line">序列化的类需要实现 Serializable 接口，transient 关键字可以使一些属性不会被序列化。</span><br></pre></td></tr></table></figure><h2 id="8-网络"><a href="#8-网络" class="headerlink" title="8. 网络"></a>8. 网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java 中的网络支持：</span><br><span class="line">    InetAddress：用于表示网络上的硬件资源，即 IP 地址；</span><br><span class="line">    URL：统一资源定位符；</span><br><span class="line">    Sockets：使用 TCP 协议实现网络通信；</span><br><span class="line">    Datagram：使用 UDP 协议实现网络通信</span><br></pre></td></tr></table></figure><h3 id="8-1-InetAddress"><a href="#8-1-InetAddress" class="headerlink" title="8.1 InetAddress"></a>8.1 InetAddress</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表示互联网协议 (IP) 地址。 </span><br><span class="line">IP 地址是 IP 使用的 32 位或 128 位无符号数字，它是一种低级协议，UDP 和 TCP 协议都是在它的基础上构建的。</span><br><span class="line">没有公有的构造函数，只能通过静态方法来创建实例。</span><br><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(byte[] address);</span><br></pre></td></tr></table></figure><h3 id="8-2-URL"><a href="#8-2-URL" class="headerlink" title="8.2 URL"></a>8.2 URL</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用</span><br><span class="line"> 建议使用 URI 管理 URL 的编码和解码，并使用 toURI() 和 URI.toURL() 实现这两个类之间的转换。也可以使用 URLEncoder 和 URLDecoder 类，但是只适用于 HTML 形式的编码</span><br><span class="line">public URL(String protocol, String host,int port, String file)throws MalformedURLException</span><br><span class="line">参数：</span><br><span class="line">         protocol - 要使用的协议名称。</span><br><span class="line">         host - 主机名称。</span><br><span class="line">         port - 主机端口号。</span><br><span class="line">         file - 主机上的文件 </span><br></pre></td></tr></table></figure><h3 id="8-3-Sockets"><a href="#8-3-Sockets" class="headerlink" title="8.3 Sockets"></a>8.3 Sockets</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket：服务器端类</span><br><span class="line">   Socket：客户端类</span><br><span class="line">   服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</span><br><span class="line">   SocketImpl</span><br><span class="line">创建客户端和服务器套接字都可以使用它</span><br></pre></td></tr></table></figure><img src="Java-04_IO.assets/image-20210522204915995.png" alt="image-20210522204915995" style="zoom:67%;" / loading="lazy"><h3 id="8-4-Datagram"><a href="#8-4-Datagram" class="headerlink" title="8.4 Datagram"></a>8.4 Datagram</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket：通信类</span><br><span class="line">DatagramPacket：数据包类</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="2021/06/01/Java/Java-02_%E5%AE%B9%E5%99%A8/"/>
      <url>2021/06/01/Java/Java-02_%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器主要包括 单列集合（Collection） 和 双列集合（Map） 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</span><br></pre></td></tr></table></figure><h2 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2. Collection"></a>2. Collection</h2><h3 id="2-1-Set"><a href="#2-1-Set" class="headerlink" title="2.1 Set"></a>2.1 Set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set 的特点是元素无序，而且不可重复</span><br><span class="line">TreeSet：基于红黑树的实现，支持有序操作</span><br><span class="line">HashSet：基于哈希表的实现，支持快速查找，不支持有序性操作</span><br><span class="line">LinkedHashSet：具有 HashSet 的查找效率，内部使用双向链表维护元素的插入顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List 的特点是元素有序、元素可重复</span><br><span class="line">ArrayLsit：基于动态数据的实现，支持随机访问</span><br><span class="line">Vector：和 ArrayList 相似，但它是线程安全的</span><br><span class="line">LinkedLsit：基于双向链表的实现，只能顺序访问，但可以快速的在链表中添加、删除元素，由于使用双向链表，可作为栈、队列、双向队列</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3 Queue"></a>2.3 Queue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList：基于双向链表的队列</span><br><span class="line">PriorityQueue：基于堆结构实现的队列，可用做优先队列</span><br></pre></td></tr></table></figure><h3 id="2-5-Map"><a href="#2-5-Map" class="headerlink" title="2.5 Map"></a>2.5 Map</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap：基于红黑树的实现</span><br><span class="line">HashMap：基于哈希表的实现</span><br><span class="line">HashTable：和 HashMap 相似，它是线程安全的，但被遗弃了，使用 ConcurrentHashMap 来代替，使用了分段锁，因此效率更高</span><br><span class="line">LinkHashMap：使用双向链表维护元素的顺序，为插入顺序、最少使用顺序</span><br></pre></td></tr></table></figure><h2 id="3-使用的设计模式"><a href="#3-使用的设计模式" class="headerlink" title="3. 使用的设计模式"></a>3. 使用的设计模式</h2><h3 id="3-1-迭代器模式"><a href="#3-1-迭代器模式" class="headerlink" title="3.1 迭代器模式"></a>3.1 迭代器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection 接口继承 Iterable 接口，Iterable 中的 iterator（）方法返回一个 iterator 对象，该对象能够遍历 Collection 中的元素，在 JDK1.5 之口，使用 foreach（）方法遍历 iterable 接口的聚合对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-适配器模式"><a href="#3-2-适配器模式" class="headerlink" title="3.2 适配器模式"></a>3.2 适配器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 java.util.Arrays 类中的 asList（）方法能够把数组转为 List，参数为泛型的可变长参数 </span><br><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br></pre></td></tr></table></figure><h2 id="4-查看源码"><a href="#4-查看源码" class="headerlink" title="4. 查看源码"></a>4. 查看源码</h2><h3 id="4-1-ArrayList"><a href="#4-1-ArrayList" class="headerlink" title="4.1 ArrayList"></a>4.1 ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList 是基于动态数组实现的，RandomAccess 接口标识着该类支持快速随机访问。默认初始容量为 <span class="number">10</span> ，每次扩容为 原来的 <span class="number">1.5</span> 倍</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">序列化：<span class="keyword">transient</span> 修饰的属性，并不会被序列化，并且实现了 writeObject（）和 readObject（）来控制只读序列化数组中有元素的部分</span><br><span class="line">       <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">Fail-Fast：modCount 用来记录 ArrayList 结构发生变化的次数，在进行序列化或者迭代操作时，比较 modCount 是否改变，若发生改变则抛出异常 ConcurrentModificationException</span><br></pre></td></tr></table></figure><h3 id="4-2-Vector"><a href="#4-2-Vector" class="headerlink" title="4.2 Vector"></a>4.2 Vector</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector 与 ArrayList 相似，但它使用了 synchronized 进行同步，</span><br><span class="line">Vector 在扩容时，根据构造函数传入的参数 capacityIncrement 是由大于等于 0，若不等于，在原来的容量基础上增加 capacityIncrement 的容量，若没有或调用默认的则扩容为原来的两倍</span><br><span class="line">可选方案：</span><br><span class="line">使用 Collections.synchronizedList()，该方法可以得到安全的 ArrayList </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-CopyOnWriteArrayList"><a href="#4-3-CopyOnWriteArrayList" class="headerlink" title="4.3 CopyOnWriteArrayList"></a>4.3 CopyOnWriteArrayList</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">读写分离：内存一致性</span><br><span class="line">读：在原始的数组上读</span><br><span class="line">写：使用一个新数组，待数据写完（加锁），在把原始数组指向当前数组</span><br><span class="line">使用场景：适合读多写少</span><br><span class="line">缺点：</span><br><span class="line">内存占用很高，变为原来的两倍。</span><br><span class="line">数据的实时性：不能读取刚写如的书库</span><br></pre></td></tr></table></figure><h3 id="4-4-LinkedList"><a href="#4-4-LinkedList" class="headerlink" title="4.4 LinkedList"></a>4.4 LinkedList</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用链表实现List 接口，是双向链表，因此可以作为堆栈、队列、双端队列</span><br><span class="line">线程不安全的，可以使用 Collections.synchronizedList（） 方法来保证线程安全</span><br><span class="line">不允许在迭代时，除了迭代器自身的 remove 或 add 方法，其它的添加、删除操作将会抛出 ConcurrentModificationException 异常</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-5-HashMap"><a href="#4-5-HashMap" class="headerlink" title="4.5  HashMap"></a>4.5  HashMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基于哈希表的 Map 接口的实现，不保证映射的顺序，特别是它不保证该顺序恒久不变。有两个参数影响其性能：初始容量 和加载因子。 </span><br><span class="line">HashMap 的默认初始容量 (16) 和默认加载因子 (0.75) </span><br><span class="line">线程不安全的，可以使用 Collections.synchronizedList（） 方法来保证线程安全</span><br><span class="line">不允许在迭代时，除了迭代器自身的 remove 或 add 方法，其它的添加、删除操作将会抛出 ConcurrentModificationException 异常</span><br><span class="line">在 JDK1.8 后，桶中链表的长度大于 8 会转为红黑树树</span><br></pre></td></tr></table></figure><h2 id="4-6-ConcurrentHashMap"><a href="#4-6-ConcurrentHashMap" class="headerlink" title="4.6 ConcurrentHashMap"></a>4.6 ConcurrentHashMap</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">与 Hashtable 相似，但与 HashMap 不同，它不允许将 null 用作键或值。</span><br><span class="line">默认初始容量 (16)、加载因子 (0.75)</span><br><span class="line">ConcurrentHashMap 使用分段锁（Segment），提高了并发的访问效率，并发数取决于分段锁，默认的 Segment 为 16。Segment 实际上是一个未受保护的 String</span><br><span class="line">在调用 Size（）方法时，会统计 Segment 的数量，如果两次连续的结果一致，则不对 Segmenet 加锁</span><br><span class="line">在 JDK1.8 后使用 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-7-LinkedHashMap"><a href="#4-7-LinkedHashMap" class="headerlink" title="4.7 LinkedHashMap"></a>4.7 LinkedHashMap</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用 哈希表和链表实现，具有可预知的迭代顺序，与 HashMap 相似，不同在于使用双重链表维护了一个迭代顺序，或者 LRU 顺序</span><br><span class="line">线程不安全</span><br><span class="line">LRUCache&lt;K, V&gt; </span><br><span class="line">设定最大缓存空间 MAX_ENTRIES 为 3</span><br><span class="line">使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</span><br></pre></td></tr></table></figure><h2 id="4-8-WeakHashMap"><a href="#4-8-WeakHashMap" class="headerlink" title="4.8 WeakHashMap"></a>4.8 WeakHashMap</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以弱键基于哈希表实现的 Map，与 HashMap 相似</span><br><span class="line">线程不安全</span><br><span class="line">equals 方法使用 == 运算符来测试对象标识</span><br><span class="line">WeakHashMap 类的行为部分取决于垃圾回收器的动作</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2021/05/26/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机系统发展阶段"><a href="#计算机系统发展阶段" class="headerlink" title="计算机系统发展阶段"></a>计算机系统发展阶段</h2><ol><li>程序设计阶段：个体化生产</li><li>程序系统阶段：作坊式生产，软件危机的出现，软件工程的出现</li><li>软件工程阶段：工程化思想，分布式系统</li><li>面向对象阶段：硬件与软件综合软件开发</li></ol><h2 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h2><p>是指在计算机软件的开发和维护过程中所遇到的一系列严重问题</p><h3 id="典型表现："><a href="#典型表现：" class="headerlink" title="典型表现："></a>典型表现：</h3><ol><li>对软件开发成本和进度的估计常常不准确</li><li>软件常常是不可维护的</li><li>软件通常没有适当的文档资料</li></ol><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ol><li>与软件本身特点有关</li><li>与软件开发和维护的方法不正确有关</li></ol><h3 id="消除软件危机"><a href="#消除软件危机" class="headerlink" title="消除软件危机"></a>消除软件危机</h3><ol><li>对计算机软件有正确的认识</li><li>使用在实践中总结出来的的开发软件的成功技术和方法</li></ol><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><p>是指导计算机软件开发和维护的一门工程学科，采用工程的概念、原理、技术个方法来开发与维护软件</p><h3 id="技术本质"><a href="#技术本质" class="headerlink" title="技术本质"></a>技术本质</h3><ol><li>关注大型程序的构造</li><li>控制复杂性</li><li>开发效率：软件开发成熟度</li><li>产品质量：反映实体满足明确的和隐含的需求的能力的特性综合</li></ol><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在给定成本、进度的前提下，开发出具有可修改行、有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性和可互操作行，并且满足用户需求</p><h2 id="软件工程基本原理"><a href="#软件工程基本原理" class="headerlink" title="软件工程基本原理"></a>软件工程基本原理</h2><p>确保软件成品质量和开发效率的原理的最小集合</p><ol><li>用分阶段的生命周期计划严格管理</li><li>严格按照计划对软件的开发与维护工作进行管理</li><li>实行严格的产品控制</li><li>采用现代化程序设计技术</li><li>结果应能清楚的审查</li><li>开发小组人员应该少而精</li><li>承认不软改进软件工程实践的必要性</li></ol><h2 id="软件工程方法学"><a href="#软件工程方法学" class="headerlink" title="软件工程方法学"></a>软件工程方法学</h2><blockquote><p>软件工程包括技术和管理两方面的内容</p><ul><li>管理：通过计划、组织和控制等一系列活动，合理的配置和使用各种资源已达到既定目标的过程</li><li>技术（软件工程方法学）：通常把在软件生命周期全过程中使用一整套技术方法的集合称为方法学，也称为范型</li></ul></blockquote><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p><strong>方法</strong>：是完成软件开发的各项任务的技术方法，是回答‘怎样做’的问题</p><p><strong>工具：</strong>是为运用方法提供的自动的或半自动的软件工程支持环境</p><p><strong>过程：</strong>需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="传统方法学"><a href="#传统方法学" class="headerlink" title="传统方法学"></a>传统方法学</h4><p>也称生命周期方法学或结构化范型—-强调自顶向下</p><p><strong>优点：</strong></p><ol><li>采用结构化技术来完成软件</li><li>划分软干个阶段，然后顺序的完成每个阶段的任务，每个阶段任务相对独立，而且比较简单，降低了整个软件开发的困难程度</li><li>前一个阶段是后一个阶段的前提和基础，而后一个的解法更具体、细节更多</li><li>每个阶段结束前必须从技术和管理两个方面，面对这个阶段的开发成果进行严格的检查，通过之后这个阶段才算结束</li></ol><p><strong>缺点：</strong></p><ol><li>软件规模庞大或者对软件的需求是模糊的或会随时间变化而变化的软件，使用传统方法学开发软件是往往不成功的</li><li>使用传统方法学开发出的软件，维护起来仍然很困难</li><li> 数据与操作相分离</li></ol><h3 id="面向对象方法学—–强调主动多次反复的迭代"><a href="#面向对象方法学—–强调主动多次反复的迭代" class="headerlink" title="面向对象方法学—–强调主动多次反复的迭代"></a>面向对象方法学—–强调主动多次反复的迭代</h3><p>把数据和行为看成同等重要，它是一种以数据为主线，把数据和对数据的操作紧密的结合起来</p><p><strong>四要点：</strong></p><ol><li>对象（Object）：融合了数据及数据上的操作行为</li><li>类（class）：类是 对具有相同数据和相同操作的一组相似对象的定义</li><li>继承：按照父类与子类的关系，把若干个的相关类组成一个层次结构的系统</li><li>消息：对象彼此间仅通过发送消息相互联系</li></ol><p><strong>优点：</strong></p><ol><li>尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程</li><li>面向对象方法学开发软件的过程是一个主动的多次反复迭代的演化过程，保证了在各项开发活动之间的平滑过渡</li><li>促进了软件的重用</li></ol><h3 id="形式化方法学"><a href="#形式化方法学" class="headerlink" title="形式化方法学"></a>形式化方法学</h3><p>是一种基于形式化数字变换的，它可将系统的规格说明转换为可执行的程序</p><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>由软件定义、软件开发和运行维护（软件维护）三个时期组成，每个时期有进一步划分成若干个阶段</p><p><strong>软件定义：</strong></p><ol><li>问题定义</li><li>可行性盐焗</li><li>需求分析</li></ol><p><strong>软件开发:</strong></p><blockquote><p>4、5：系统设计，6、7：系统实现</p></blockquote><ol><li>概要设计</li><li>详细设计</li><li>编码和单元测试</li><li>综合测试</li></ol><p><strong>软件维护：</strong></p><ol><li>运行维护</li></ol><p><strong>八个阶段：</strong></p><ol><li><p>问题定义</p><ol><li>任务：问题是什么</li><li>过程：<ol><li>通过对客户的访问调查，系统分析员扼要的写出关于问题性质、工程目标和工程规模的书面报告</li><li>经过讨论和必要的修改之后的报告得到用户确认</li></ol></li><li>结果：关于系统规模和目标的报告书</li></ol></li><li><p>可行性研究</p><ol><li>任务：有可行的解决方案吗？</li><li>过程：<ol><li>系统分析员需要进行一次大大压缩和简化了系统分析和设计过程</li><li>研究问题的范围，探索这个问题是否值得去解，是否有可行的解决方法</li></ol></li><li>结果：<ol><li>系统的高层逻辑模型（数据流图】成本效益分析）</li><li>可行性论证报告（立即进行 | 推迟进行 | 不能或不值得进行）</li></ol></li></ol></li><li><p>需求分析</p><ol><li>任务： 必须做什么</li><li>过程：<ol><li>主要是确定目标必须具备那些功能</li><li>系统分析员必须和用户密切配合，充分交流信息，以得出经过用户确认的系统逻辑模型</li></ol></li><li>结果：<ol><li>系统的逻辑模型（数据流图、数据字典、简要的算法描述）</li><li>用规格说明书准确的记录对目标系统的要求</li></ol></li></ol></li><li><p>总体设计</p><ol><li>任务：如何解决已提出的问题</li><li>过程：<ol><li>设计出实现目标系统的几种可能的方案（低、中、高成本）</li><li>推荐最佳方案，制定详细计划，程序体系结构的设计</li></ol></li><li>结果：<ol><li>可能的结果方案（系统流程图、成本效益分析）</li><li>推荐的系统体系结构（层次图或结构图）</li></ol></li></ol></li><li><p>详细设计、模块设计</p><ol><li>任务：怎样具体实现系统</li><li>过程：详细的设计每个模块，设计出程序的详细的规格说明，确定实现模块功能所需要的算法和数据结构</li><li>结果：每个模块的算法和数据结构（程序流程图、PAD图、N-S图）</li></ol></li><li><p>编码和单元测试</p><ol><li>任务：得到正确的程序模块</li><li>过程：选取一种适当的高级程序设计语言，把详细设计的结果翻译成用选定语言书写的程序</li><li>结果：代码和测试报告</li></ol></li><li><p>综合测试</p><ol><li>任务：得到符合要求的软件</li><li>过程：<ol><li>通过集成测试，验收测试，现场测试，平行运行等方法，对目标系统进一步测试检验</li><li>通过对软件测试结果的分析，可以预测软件的可靠性。反之，根据对软件可靠性的要求，也可以决定测试和调试过程中什么时候可以结</li></ol></li><li>结果：<ol><li>测试计划：详细测试方案以及实际测试结果</li><li>完整一致的软件配置</li></ol></li></ol></li><li><p>软件维护</p><ol><li>任务：使系统持久的满足用户的需要</li><li>过程：<ol><li>改正性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li><li>每一项维护活动的实质是经历了一次压缩和简化了的软件定义和开发的全过程</li></ol></li><li>结果：完整准确的维护记录</li></ol><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><p>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的步骤</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>需求分析</p><p>规格说明</p><p>设计</p><p>编码</p><p>综合测试</p><p><strong>特点</strong></p><ol><li><p>阶段间具有顺序性和依赖性：前一个工程结束，在开始下一个</p></li><li><p>推迟实现的观点</p></li><li><p>质量保证的观点：每个阶段都必须完成规定的文档，是‘文档驱动’模型</p></li></ol><p><strong>优点</strong></p><ol><li><p>可强迫开发人员采用规范的方法</p></li><li><p>严格地规定每个阶段必须提交的文档</p></li><li><p>要求每个阶段交出的所有产品都必须经过质量保证</p></li></ol><p><strong>适用于</strong></p><ol><li>需求是预知的</li><li>软件实现方法是成熟的</li><li>项目周期较短</li></ol></li></ol><h2 id="可行性研究任务"><a href="#可行性研究任务" class="headerlink" title="可行性研究任务"></a>可行性研究任务</h2><p><strong>目的</strong></p><ol><li><p>用最小的代价尽可能短的时间内确定问题是否能够解决</p></li><li><p>确定任务是否值得去解决，找出最优解</p></li></ol><p><strong>实质 ：</strong>进行一次大大压缩简化了的系统分析和设计的过程也就是在较高层次上比较抽象的方式进行的系统分析和设计过程</p><p><strong>内容：</strong></p><ol><li>首先进一步分析和澄清问题的定义，导出系统的逻辑模型</li><li>从系统逻辑模型出发，探索若干种可供选择的主要解法</li><li>对每种解法都研究它的可行性，至少从是三个方面研究</li><li>主要方面<ul><li>技术可行性</li><li>经济可行性</li><li>操作可行性</li></ul></li><li>其他方面<ol><li>运行可行性        </li><li>法律可行性</li><li>实现进度表</li></ol></li></ol><h4 id="可行性研究过程"><a href="#可行性研究过程" class="headerlink" title="可行性研究过程"></a>可行性研究过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 复查系统规模和目标</span><br><span class="line">2. 研究目前正在使用的系统</span><br><span class="line">3. 导出新系统的高层逻辑模型： 现有物理系统（系统流程图） -&gt; 现有系统的逻辑模型（数据流图 + 数据字典） -&gt; 目标系统的逻辑模型 -&gt; 新的物理系统</span><br><span class="line">4. 进一步定义问题</span><br><span class="line">5. 导出和评价供选的解法</span><br><span class="line">6. 推荐行动方针</span><br><span class="line">7. 草拟开发计划</span><br><span class="line">8. 书写文档提交审查：把可行性研究各个步骤的工作结果写成清晰的文档</span><br></pre></td></tr></table></figure><h2 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是概括的描绘物理系统的传统工具，用图形符号以黑盒子形式描绘组成系统的每个部件，表达的是数据在系统各部件之间的流动，而不是对数据的处理</span><br><span class="line"></span><br><span class="line">审题思维：输入是什么？ 输出是什么？处理是什么？ 存储是什么？</span><br><span class="line"></span><br><span class="line">部件：包括程序、文档、数据库、人工过程等</span><br></pre></td></tr></table></figure><h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data Flow Diagram ，简称 DFD 图，是一种图形化技术，它描绘信息和数据从输入移动到输出的过程中所经过的变换，是一种功能模型</span><br></pre></td></tr></table></figure><p><img src="%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210521145813205.png" alt="image-20210521145813205" loading="lazy"></p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是关于数据的信息的集合，也就是对数据流程图中包含的所有元素的定义的集合【数据流图和数据字典共同构成系统的逻辑模型】</span><br></pre></td></tr></table></figure><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任务：</span><br><span class="line">   准确的回答 ”系统必须做什么“</span><br><span class="line">       对目标系统提出完整、准确、清晰、具体的要求</span><br><span class="line">       写出软件需求规格说明书、</span><br></pre></td></tr></table></figure><h3 id="需求分析的结构化方法（SA）"><a href="#需求分析的结构化方法（SA）" class="headerlink" title="需求分析的结构化方法（SA）"></a>需求分析的结构化方法（SA）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据模型（E-R 图）、功能模型（DFD 图）、行为模型（状态转换图）</span><br><span class="line">方法：正向需求和逆向需求分析方法</span><br><span class="line">指导思想：自定向下，逐步求精</span><br><span class="line">原则：抽象和分解</span><br></pre></td></tr></table></figure><h3 id="软件需求的正确性"><a href="#软件需求的正确性" class="headerlink" title="软件需求的正确性"></a>软件需求的正确性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一致性、完整性、现实性、有效性</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>06_行为型模式</title>
      <link href="2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06_%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</span><br><span class="line"></span><br><span class="line">行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</span><br><span class="line"></span><br><span class="line">行为型模式分为：模板方法模式和解释器模式是类行为型模式，其他的属于对象行为型模式。</span><br><span class="line">    * 模板方法模式</span><br><span class="line">    * 策略模式</span><br><span class="line">    * 命令模式</span><br><span class="line">    * 职责链模式</span><br><span class="line">    * 状态模式</span><br><span class="line">    * 观察者模式</span><br><span class="line">    * 中介者模式</span><br><span class="line">    * 迭代器模式</span><br><span class="line">    * 访问者模式</span><br><span class="line">    * 备忘录模式</span><br><span class="line">    * 解释器模式</span><br></pre></td></tr></table></figure><h2 id="2-模板方法模式"><a href="#2-模板方法模式" class="headerlink" title="2. 模板方法模式"></a>2. 模板方法模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</span><br><span class="line">   结构</span><br><span class="line">   模板方法（Template Method）模式包含以下主要角色：</span><br><span class="line">           * 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</span><br><span class="line">             * 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</span><br><span class="line">             * 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</span><br><span class="line">                   * 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</span><br><span class="line">                   * 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</span><br><span class="line">                   * 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</span><br><span class="line">           * 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</span><br><span class="line">   优点：</span><br><span class="line">       * 提高代码复用性</span><br><span class="line">         将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</span><br><span class="line">       * 实现了反向控制</span><br><span class="line">         通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">       * 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</span><br><span class="line">       * 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</span><br><span class="line">适用场景</span><br><span class="line">* 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</span><br><span class="line">* 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3. 策略模式"></a>3. 策略模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</span><br><span class="line">结构</span><br><span class="line">       策略模式的主要角色如下：</span><br><span class="line">           * 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</span><br><span class="line">           * 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</span><br><span class="line">           * 环境（Context）类：持有一个策略类的引用，最终给客户端调用。</span><br><span class="line">   优点：</span><br><span class="line">       * 策略类之间可以自由切换</span><br><span class="line">       * 易于扩展</span><br><span class="line">       * 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</span><br><span class="line">   缺点：</span><br><span class="line">       * 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</span><br><span class="line">       * 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</span><br><span class="line">使用场景</span><br><span class="line">       * 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</span><br><span class="line">       * 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</span><br><span class="line">       * 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</span><br><span class="line">       * 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</span><br><span class="line">       * 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-命令模式"><a href="#4-命令模式" class="headerlink" title="4. 命令模式"></a>4. 命令模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</span><br><span class="line">结构</span><br><span class="line">       命令模式包含以下主要角色：</span><br><span class="line">           * 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</span><br><span class="line">           * 具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</span><br><span class="line">           * 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</span><br><span class="line">           * 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</span><br><span class="line">   优点：</span><br><span class="line">       * 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</span><br><span class="line">       * 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</span><br><span class="line">       * 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</span><br><span class="line">       * 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</span><br><span class="line">   缺点：</span><br><span class="line">       * 使用命令模式可能会导致某些系统有过多的具体命令类。</span><br><span class="line">       * 系统结构更加复杂。</span><br><span class="line">使用场景</span><br><span class="line">       * 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</span><br><span class="line">       * 系统需要在不同的时间指定请求、将请求排队和执行请求。</span><br><span class="line">       * 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05_结构型模式</title>
      <link href="2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05_%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</span><br><span class="line">结构型模式分为以下 7 种：</span><br><span class="line">       * 代理模式</span><br><span class="line">       * 适配器模式</span><br><span class="line">       * 装饰者模式</span><br><span class="line">       * 桥接模式</span><br><span class="line">       * 外观模式</span><br><span class="line">       * 组合模式</span><br><span class="line">       * 享元模式</span><br></pre></td></tr></table></figure><h2 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2. 代理模式"></a>2. 代理模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   由于某些原因需要给对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</span><br><span class="line">   Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在 Java运行时动态生成。动态代理又有 JDK 代理和 CGLib 代理两种。</span><br><span class="line">   结构:</span><br><span class="line">       代理（Proxy）模式分为三种角色：</span><br><span class="line">           * 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</span><br><span class="line">           * 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</span><br><span class="line">           * 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</span><br><span class="line">   优点：</span><br><span class="line">       - 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</span><br><span class="line">       - 代理对象可以扩展目标对象的功能；</span><br><span class="line">       - 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"> 增加了系统的复杂度；</span><br></pre></td></tr></table></figure><h3 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被代理类聚合、组合到代理类中，两者实现相同的接口，访问者调用代理类总的方法，实际上调用的是被代理类的方法</span><br></pre></td></tr></table></figure><h3 id="2-2-动态代理"><a href="#2-2-动态代理" class="headerlink" title="2.2 动态代理"></a>2.2 动态代理</h3><h4 id="2-2-1-JDK-代理"><a href="#2-2-1-JDK-代理" class="headerlink" title="2.2.1 JDK 代理"></a>2.2.1 JDK 代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java 中提供了一个动态代理类 Proxy，Proxy 并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</span><br><span class="line"></span><br><span class="line">Proxy.newProxyInstance(ClassLoader,</span><br><span class="line">    Interfaces, <span class="comment">// 被代理类的接口</span></span><br><span class="line">    <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            InvocationHandler中invoke 方法参数说明：</span></span><br><span class="line"><span class="comment">            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//执行真实对象</span></span><br><span class="line">        Object result = method.invoke(station, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-2-2-CGLIB-代理"><a href="#2-2-2-CGLIB-代理" class="headerlink" title="2.2.2 CGLIB 代理"></a>2.2.2 CGLIB 代理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为 JDK 的动态代理提供了很好的补充。</span><br><span class="line">  CGLIB是第三方提供的包，所以需要引入jar包的坐标：</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">          &lt;/dependency&gt;</span><br><span class="line">          </span><br><span class="line">      Enhancer enhancer =new Enhancer();</span><br><span class="line">      //设置父类的字节码对象</span><br><span class="line">      enhancer.setSuperclass(target.getClass());</span><br><span class="line">      //设置回调函数</span><br><span class="line">      enhancer.setCallback(new MethodInterceptor()&#123;</span><br><span class="line">/*</span><br><span class="line">          intercept方法参数说明：</span><br><span class="line">              o ： 代理对象</span><br><span class="line">              method ： 真实对象中的方法的Method实例</span><br><span class="line">              args ： 实际参数</span><br><span class="line">              methodProxy ：代理对象中的方法的method实例</span><br><span class="line">   */</span><br><span class="line">          public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">              return = (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;);</span><br><span class="line">      //创建代理对象</span><br><span class="line">      return   enhancer.create();</span><br></pre></td></tr></table></figure><h3 id="2-3-代理方式的对比"><a href="#2-3-代理方式的对比" class="headerlink" title="2.3 代理方式的对比"></a>2.3 代理方式的对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">动态代理和静态代理：</span><br><span class="line">动态代理把代理对象的方法统一集中处理，而像静态代理针对每个方法都要实现</span><br><span class="line">JDK 代理与 CGLIB 代理：</span><br><span class="line">JDK 代理是基于代理对象的接口来实现的，而 CGLIB 代理是基于对象的类实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-适配器模式"><a href="#3-适配器模式" class="headerlink" title="3. 适配器模式"></a>3. 适配器模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</span><br><span class="line">   适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构。</span><br><span class="line">   结构</span><br><span class="line">   适配器模式（Adapter）包含以下主要角色：</span><br><span class="line">           * 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</span><br><span class="line">           * 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</span><br><span class="line">           * 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</span><br><span class="line">   应用场景</span><br><span class="line">       * 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</span><br><span class="line">       * 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</span><br><span class="line">JDK 中的示例</span><br><span class="line">Reader（字符流）、InputStream（字节流）的适配使用的是 InputStreamReader。</span><br><span class="line">InputStreamReader 继承自 java.io 包中的 Reader，对他中的抽象的未实现的方法给出实现，实现是由 sun.nio.cs.StreamDecoder类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-1-类适配器"><a href="#3-1-类适配器" class="headerlink" title="3.1 类适配器"></a>3.1 类适配器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现方式：适配器需要继承需要适配的类和所需要目标接口</span><br></pre></td></tr></table></figure><h3 id="3-2-对象适配器模式"><a href="#3-2-对象适配器模式" class="headerlink" title="3.2 对象适配器模式"></a>3.2 对象适配器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</span><br></pre></td></tr></table></figure><h2 id="4-装饰者模式"><a href="#4-装饰者模式" class="headerlink" title="4. 装饰者模式"></a>4. 装饰者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</span><br><span class="line">结构</span><br><span class="line">装饰（Decorator）模式中的角色：</span><br><span class="line">           * 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</span><br><span class="line">           * 具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</span><br><span class="line">           * 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</span><br><span class="line">           * 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</span><br><span class="line">   使用场景</span><br><span class="line">       * 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</span><br><span class="line">             不能采用继承的情况主要有两类：</span><br><span class="line">                 * 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</span><br><span class="line">                 * 第二类是因为类定义不能继承（如 final 类）</span><br><span class="line">       * 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</span><br><span class="line">       * 当对象的功能要求可以动态地添加，也可以再动态地撤销时。</span><br><span class="line">  好处：</span><br><span class="line"></span><br><span class="line">       * 装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</span><br><span class="line">       * 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</span><br><span class="line">    代理和装饰者的区别：</span><br><span class="line">    相同点：</span><br><span class="line">    - 都要实现与目标类相同的业务接口</span><br><span class="line">    - 在两个类中都要声明目标对象</span><br><span class="line">    - 都可以在不修改目标类的前提下增强目标方法</span><br><span class="line">    不同点：</span><br><span class="line">    - 目的不同：代理是为了隐藏对象，装饰着是增强对象</span><br><span class="line">    - 创建对象的方式不同：代理是在内部创建，装饰着是由外部传入</span><br></pre></td></tr></table></figure><h2 id="5-桥接模式"><a href="#5-桥接模式" class="headerlink" title="5. 桥接模式"></a>5. 桥接模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</span><br><span class="line">结构 </span><br><span class="line">   桥接（Bridge）模式包含以下主要角色：</span><br><span class="line">           * 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</span><br><span class="line">           * 扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</span><br><span class="line">           * 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</span><br><span class="line">           * 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</span><br><span class="line">    好处：</span><br><span class="line">    * 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</span><br><span class="line">* 实现细节对客户透明</span><br><span class="line"> 使用场景</span><br><span class="line">       * 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</span><br><span class="line">       * 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</span><br><span class="line">       * 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</span><br></pre></td></tr></table></figure><h2 id="6-外观模式"><a href="#6-外观模式" class="headerlink" title="6. 外观模式"></a>6. 外观模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。外观（Facade）模式是“迪米特法则”的典型应用</span><br><span class="line">  结构</span><br><span class="line">外观（Facade）模式包含以下主要角色：</span><br><span class="line">          * 外观（Facade）角色：为多个子系统对外提供一个共同的接口。</span><br><span class="line">          * 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</span><br><span class="line">   好处：</span><br><span class="line">      * 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</span><br><span class="line">      * 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</span><br><span class="line">   缺点：</span><br><span class="line">      * 不符合开闭原则，修改很麻烦</span><br><span class="line">   使用场景</span><br><span class="line">      * 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</span><br><span class="line">      * 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</span><br><span class="line">      * 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</span><br></pre></td></tr></table></figure><h2 id="7-组合模式"><a href="#7-组合模式" class="headerlink" title="7. 组合模式"></a>7. 组合模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构</span><br><span class="line">结构</span><br><span class="line">       组合模式主要包含三种角色：</span><br><span class="line">           * 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</span><br><span class="line">           * 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</span><br><span class="line">           * 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</span><br><span class="line">   优点</span><br><span class="line">       * 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</span><br><span class="line">       * 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</span><br><span class="line">       * 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</span><br><span class="line">       * 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</span><br><span class="line">   使用场景</span><br><span class="line">       组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</span><br><span class="line">    分类：</span><br><span class="line">    透明组合：在根节点中定义了管理成员对象的所有方法，透明组合是组合模式的标准形式</span><br><span class="line">    安全组合：根节点和叶子节点是分开定义的，客户端不能完成针对抽象编程，必须区别对待叶子节点和容器构件</span><br></pre></td></tr></table></figure><h2 id="8-享元模式"><a href="#8-享元模式" class="headerlink" title="8. 享元模式"></a>8. 享元模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</span><br><span class="line">   结构</span><br><span class="line">       享元（Flyweight ）模式中存在以下两种状态：</span><br><span class="line">           1. 内部状态，即不会随着环境的改变而改变的可共享部分。</span><br><span class="line">           2. 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</span><br><span class="line"></span><br><span class="line">       享元模式的主要有以下角色：</span><br><span class="line">           * 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</span><br><span class="line">           * 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</span><br><span class="line">           * 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</span><br><span class="line">           * 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</span><br><span class="line">    优点</span><br><span class="line">- 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</span><br><span class="line">- 享元模式中的外部状态相对独立，且不影响内部状态</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</span><br><span class="line">使用场景：</span><br><span class="line">       - 一个系统有大量相同或者相似的对象，造成内存的大量耗费。</span><br><span class="line">       - 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</span><br><span class="line">       - 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02_UML</title>
      <link href="2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_UML%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9B%BE/"/>
      <url>2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02_UML%20%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">统一建模语言（Unified Modeling Language）是用来设计软件的可视化建模语言。特点是简单、统一、图形化、能表达设计中的动态和静态信息。</span><br><span class="line">UML 从不同角度定义了：例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图共 九 种图。</span><br></pre></td></tr></table></figure><h2 id="2-类图"><a href="#2-类图" class="headerlink" title="2. 类图"></a>2. 类图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类图（Class Diagram）是显示模型的静态结构，特别是模型中存在的类、类的内部结构和其它类的关系等。类图不显示暂时性的信息，类图是面向对象建模的主要组成部分。</span><br><span class="line">作用：</span><br><span class="line">    - 在软件工程中，类图是一种静态的结构图，描述了系统的类的集合、类的属性和类之间的关系，简化了人们对系统的理解。</span><br><span class="line">    - 类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型</span><br></pre></td></tr></table></figure><h3 id="2-1-类的表示"><a href="#2-1-类的表示" class="headerlink" title="2.1 类的表示"></a>2.1 类的表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 UML 类图中，类使用包含类名、属性和方法且带有分割线的矩形来表示。</span><br><span class="line">UML 类图中表示可见性的符号有三种：</span><br><span class="line">         + ：表示 public</span><br><span class="line">         - ：表示 private</span><br><span class="line">         # ：表示 protected</span><br><span class="line">         </span><br><span class="line">属性的完整表示：可见性 名称 ：类型 【缺省值】</span><br><span class="line">方法的完整表示：可见性 名称(参数) ：返回类型</span><br></pre></td></tr></table></figure><h3 id="2-2-类之间的关系"><a href="#2-2-类之间的关系" class="headerlink" title="2.2 类之间的关系"></a>2.2 类之间的关系</h3><h4 id="2-2-1-关联关系"><a href="#2-2-1-关联关系" class="headerlink" title="2.2.1 关联关系"></a>2.2.1 关联关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系。</span><br><span class="line">关联又可以分为单向关联、双向关联、自关联</span><br></pre></td></tr></table></figure><h5 id="2-2-1-1-单向关联"><a href="#2-2-1-1-单向关联" class="headerlink" title="2.2.1.1 单向关联"></a>2.2.1.1 单向关联</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 UML 类图中单向关联用一个带箭头的实线表示。</span><br><span class="line">由关联方指向被关联方</span><br></pre></td></tr></table></figure><h5 id="2-2-1-2-双向关联"><a href="#2-2-1-2-双向关联" class="headerlink" title="2.2.1.2 双向关联"></a>2.2.1.2 双向关联</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 UML 类图中，双向关联用一个不带箭头的直线表示</span><br><span class="line">两者都是关联方与被关联方</span><br></pre></td></tr></table></figure><p>2.2.1.2 自关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 UML 类图中自关联用一个带有箭头且指向自身的实线表示。</span><br><span class="line">关联方与被关联方是自己本身</span><br></pre></td></tr></table></figure><h4 id="2-2-2-聚合关系"><a href="#2-2-2-聚合关系" class="headerlink" title="2.2.2 聚合关系"></a>2.2.2 聚合关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</span><br><span class="line">在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，空心菱形实线由被聚合方指向聚合方</span><br></pre></td></tr></table></figure><h4 id="2-2-3-组合关系"><a href="#2-2-3-组合关系" class="headerlink" title="2.2.3 组合关系"></a>2.2.3 组合关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</span><br><span class="line">在 UML 类图中，组合关系可以用带实心菱形的实线来表示，实心菱形实线由被聚合方指向聚合方</span><br></pre></td></tr></table></figure><h4 id="2-2-4-依赖关系"><a href="#2-2-4-依赖关系" class="headerlink" title="2.2.4 依赖关系"></a>2.2.4 依赖关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。</span><br><span class="line">在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用方指向被使用方。</span><br></pre></td></tr></table></figure><p>2.2.5 继承关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">继承关系是对象之间耦合度最大的一种关系，类似于父与子的关系。</span><br><span class="line">在 UML 类图中，继承关系（泛化关系）用带空心三角箭头的实线来表示，箭头从子类指向父类。</span><br></pre></td></tr></table></figure><p>2.2.6 实现关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</span><br><span class="line">在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03_设计原则</title>
      <link href="2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03_%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03_%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</span><br></pre></td></tr></table></figure><h2 id="2-开闭原则"><a href="#2-开闭原则" class="headerlink" title="2. 开闭原则"></a>2. 开闭原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对扩展开放，对修改关闭：</span><br><span class="line">在程序需要进行拓展的时候，不能去修改原有的代码，实现开闭原则需要使用接口和抽象类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-里氏代换原则"><a href="#3-里氏代换原则" class="headerlink" title="3. 里氏代换原则"></a>3. 里氏代换原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">里氏代换原则是面向对象设计的基本原则之一。</span><br><span class="line">里氏代换原则：任何基类（父类）可以出现的地方，子类一定可以出现。</span><br><span class="line">子类可以扩展父类的功能，但不能改变父类原有的功能。</span><br></pre></td></tr></table></figure><h2 id="4-依赖倒转原则"><a href="#4-依赖倒转原则" class="headerlink" title="4. 依赖倒转原则"></a>4. 依赖倒转原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</span><br><span class="line">对抽象进行编程，不要对实现类进行编程</span><br></pre></td></tr></table></figure><h2 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不应该依赖它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</span><br></pre></td></tr></table></figure><h2 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6. 迪米特法则"></a>6. 迪米特法则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">迪米特法则又叫最少知识原则。</span><br><span class="line">如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，</span><br></pre></td></tr></table></figure><h2 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7. 合成复用原则"></a>7. 合成复用原则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</span><br><span class="line">类的复用分为继承复用和合成复用</span><br><span class="line">继承复用：简单易于实现，但破坏了类的封装性，子类和父类的耦合度较高，灵活性较差</span><br><span class="line">合成复用：维持了类的封装性，降低对象间的耦合对，灵活性较高</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04_创建者模式</title>
      <link href="2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04_%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04_%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建型模式的主要关注点是 “ 怎样创建对象？ ”，它的主要特点是 “ 将对象的创建与使用分离 ”。</span><br><span class="line">创建型模式分为：</span><br><span class="line">           * 单例模式</span><br><span class="line">           * 工厂方法模式</span><br><span class="line">           * 抽象工程模式</span><br><span class="line">           * 原型模式</span><br><span class="line">           * 建造者模式</span><br></pre></td></tr></table></figure><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h2><h3 id="2-1-实现方式"><a href="#2-1-实现方式" class="headerlink" title="2.1 实现方式"></a>2.1 实现方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单例设计模式分类两种：</span><br><span class="line">    饿汉式：类加载就会导致该单实例对象被创建</span><br><span class="line">    懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</span><br></pre></td></tr></table></figure><h4 id="2-1-1-饿汉式"><a href="#2-1-1-饿汉式" class="headerlink" title="2.1.1 饿汉式"></a>2.1.1 饿汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提前创建号实例，需要该实例时，直接返回</span><br><span class="line">       1. 静态变量方式：</span><br><span class="line">       2，静态代码块方式</span><br></pre></td></tr></table></figure><h4 id="2-1-2-懒汉式"><a href="#2-1-2-懒汉式" class="headerlink" title="2.1.2 懒汉式"></a>2.1.2 懒汉式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">需要改实例时，判断该实例是否存在，若不存在则创建该实例并返回，若存在，直接返回该实例</span><br><span class="line">在多线程下存在线程安全问题</span><br><span class="line">解决办法：</span><br><span class="line">1. synchronized ：修饰提供实例的方法</span><br><span class="line">问题：在多线程会影响执行效率</span><br><span class="line">2. 双重检查锁：在判断实例是否为空后，添加 synchronized 锁，在进行判断</span><br><span class="line">把判空的方法放在锁外，在多线程大大提高了执行效率，但因为 JVM 实例化对象时，会优化指令和指令重排而导致空指针异常</span><br><span class="line">3. volatile：在双重检查锁的基础上，使用 volatile 修饰成员变量，以保证可见性和有序性。</span><br><span class="line">4. 静态内部类：因 JVM 在加载外部类的过程中, 不会加载静态内部类, 只有内部类的属性/方法被调用时才会被加载,静态属性由于被 static 修饰，保证只被实例化一次，并且严格保证实例化顺序。</span><br><span class="line">5. 枚举方式：枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</span><br></pre></td></tr></table></figure><h3 id="2-2-破坏单例模式"><a href="#2-2-破坏单例模式" class="headerlink" title="2.2 破坏单例模式"></a>2.2 破坏单例模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单例类（Singleton）可以创建多个对象，枚举方式除外。</span><br><span class="line">两种方式：序列化、反射 </span><br></pre></td></tr></table></figure><h4 id="2-2-1-序列化反序列化"><a href="#2-2-1-序列化反序列化" class="headerlink" title="2.2.1 序列化反序列化"></a>2.2.1 序列化反序列化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">破坏单例模式：</span><br><span class="line">通过 ObjectOutputStream 中 writeObject() 方法把对象写入到文件中，再通过 ObjectInputStream 中 readObject() 方法从文件中读取对象</span><br><span class="line">解决办法：</span><br><span class="line">在单例类中添加 readResolve() 方法，该方法返回的是单例对象。</span><br><span class="line">原理：</span><br><span class="line">ObjectInputStream 的 readObject() 方法在读取对象时，会先判断是否有 readResolve() 方法，若有，则通过反射调用该方法获取对象</span><br></pre></td></tr></table></figure><h4 id="2-2-2-反射"><a href="#2-2-2-反射" class="headerlink" title="2.2.2 反射"></a>2.2.2 反射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">破坏单例模式：</span><br><span class="line">通过 Class 获取构造方法（clazz.getDeclaredConstructor），并取消权限检查（setAccessible(true) ）, 获取实例（ constructor.newInstance()）</span><br><span class="line">解决办法：</span><br><span class="line">在构造方法中判断是否是第一次实例化，否则抛出异常</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-单例模式的示例"><a href="#2-3-单例模式的示例" class="headerlink" title="2.3 单例模式的示例"></a>2.3 单例模式的示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JDK 中的 Runtime 类</span><br><span class="line">部分代码</span><br><span class="line"></span><br><span class="line">       private static Runtime currentRuntime = new Runtime();</span><br><span class="line">       /**</span><br><span class="line">       * Returns the runtime object associated with the current Java application.</span><br><span class="line">       * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="line">       * methods and must be invoked with respect to the current runtime object.</span><br><span class="line">       *</span><br><span class="line">       * @return  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="line">       *          Java application.</span><br><span class="line">       */</span><br><span class="line">       public static Runtime getRuntime() &#123;</span><br><span class="line">       return currentRuntime;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用工厂模式来创建对象，而不是直接的 new 对象，这样做是为了降低耦合性</span><br><span class="line">       * 简单工厂模式（不属于GOF的23种经典设计模式）</span><br><span class="line">       * 工厂方法模式</span><br><span class="line">       * 抽象工厂模式</span><br></pre></td></tr></table></figure><h3 id="3-1-简单工厂"><a href="#3-1-简单工厂" class="headerlink" title="3.1 简单工厂"></a>3.1 简单工厂</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">简单工厂包含如下角色：</span><br><span class="line">    * 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">    * 具体产品 ：实现或者继承抽象产品的子类</span><br><span class="line">    * 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品</span><br><span class="line">优点：</span><br><span class="line">封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开</span><br><span class="line">缺点：</span><br><span class="line">违背了开闭原则</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-工厂方法模式"><a href="#3-2-工厂方法模式" class="headerlink" title="3.2 工厂方法模式"></a>3.2 工厂方法模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</span><br><span class="line">工厂方法模式的主要角色：</span><br><span class="line">       * 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</span><br><span class="line">       * 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</span><br><span class="line">       * 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</span><br><span class="line">       * 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</span><br><span class="line">       </span><br><span class="line">   优点：</span><br><span class="line">       用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</span><br><span class="line">       在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-抽象工厂模式"><a href="#3-3-抽象工厂模式" class="headerlink" title="3.3 抽象工厂模式"></a>3.3 抽象工厂模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</span><br><span class="line">抽象工厂模式的主要角色如下：</span><br><span class="line">       * 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</span><br><span class="line">       * 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</span><br><span class="line">       * 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</span><br><span class="line">       * 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</span><br><span class="line">       </span><br><span class="line">优点：</span><br><span class="line">当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</span><br><span class="line"></span><br><span class="line">   使用场景：</span><br><span class="line">       * 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</span><br><span class="line">       * 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</span><br><span class="line">       * 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</span><br><span class="line">       如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-扩展"><a href="#3-4-扩展" class="headerlink" title="3.4 扩展"></a>3.4 扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单工厂+ 配置文件解除耦合</span><br><span class="line">在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</span><br></pre></td></tr></table></figure><h2 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4.  原型模式"></a>4.  原型模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象</span><br><span class="line">原型模式包含如下角色：</span><br><span class="line">       * 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</span><br><span class="line">       * 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</span><br><span class="line">       * 访问类：使用具体原型类中的 clone() 方法来复制新的对象。</span><br><span class="line">  使用场景：</span><br><span class="line">  * 对象的创建非常复杂，可以使用原型模式快捷的创建对象。</span><br><span class="line">* 性能和安全要求比较高。</span><br></pre></td></tr></table></figure><h3 id="4-1-实现"><a href="#4-1-实现" class="headerlink" title="4.1 实现"></a>4.1 实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原型模式的克隆分为浅克隆和深克隆。</span><br><span class="line">浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</span><br><span class="line">深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：Java 中的 Object 类中提供了 clone() 方法来实现浅克隆，java 提供了 Cloneable 接口</span><br><span class="line"> 深克隆可以通过序列化来实现</span><br></pre></td></tr></table></figure><h2 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5. 建造者模式"></a>5. 建造者模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">将一个复杂对象的构建与表示分离</span><br><span class="line">建造者（Builder）模式包含如下角色：</span><br><span class="line">        * 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </span><br><span class="line">        * 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </span><br><span class="line">        * 产品类（Product）：要创建的复杂对象。</span><br><span class="line">        * 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </span><br><span class="line">       </span><br><span class="line">    优点：</span><br><span class="line">         建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</span><br><span class="line">        在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</span><br><span class="line">        可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</span><br><span class="line">        建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</span><br><span class="line">    缺点：</span><br><span class="line">    创造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</span><br><span class="line">    </span><br><span class="line">   使用场景：建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</span><br><span class="line">        - 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</span><br><span class="line">        - 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</span><br><span class="line"></span><br><span class="line">注意：可以采用链式编程的方式实现建造者模式，但对程序员的要求较高</span><br></pre></td></tr></table></figure><h2 id="6-工厂模式与建造者模式的区别"><a href="#6-工厂模式与建造者模式的区别" class="headerlink" title="6. 工厂模式与建造者模式的区别"></a>6. 工厂模式与建造者模式的区别</h2><h3 id="6-1-工厂模式与建造者模式"><a href="#6-1-工厂模式与建造者模式" class="headerlink" title="6.1 工厂模式与建造者模式"></a>6.1 工厂模式与建造者模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工厂模式：注重的是对整体对象的创建，是方式</span><br><span class="line">建造者模式：注重的是对对象创建的顺序，是过程</span><br></pre></td></tr></table></figure><h3 id="6-2-抽象工厂与建造者模式"><a href="#6-2-抽象工厂与建造者模式" class="headerlink" title="6.2 抽象工厂与建造者模式"></a>6.2 抽象工厂与建造者模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">抽象工厂：关注的是产品，而不是对象，是一个产品族的概念</span><br><span class="line">建造者模式：关注的是产品的组成，</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E8%AE%BA%E5%9D%9B/%E6%B1%87%E6%80%BB/"/>
      <url>2021/05/26/%E8%AE%BA%E5%9D%9B/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://juejin.cn/">掘金</a></li><li><a href="https://segmentfault.com/">思否</a></li><li><a href="https://github.com/">github</a>： 全球最大的代码仓库。</li><li><a href="https://stackoverflow.com/questions">overflow</a>: 问答社区。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN</a>: web 文档，一个开放的开发者社区创造。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01_设计模式</title>
      <link href="2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01_%E6%A6%82%E8%BF%B0/"/>
      <url>2021/05/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01_%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、被多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。换句话说，它是解决特定问题的固定思路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</span><br></pre></td></tr></table></figure><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建者模式：</span><br><span class="line">   用于描述 “ 怎样创建对象 ” ，主要的特点是将 “ 对象的创建和使用分离 ” 。GoF 的书中描述了单例、原型、工厂方法、抽象工厂、建造者 五 种创建型模式。</span><br><span class="line">结构型模式：</span><br><span class="line">   用于描述怎样将 “ 类或对象按某种布局组成更大的结构 ” ，GoF 的书中描述了代理、适配器、桥接、装饰、外观、享元、组合共 七 种结构型模式。</span><br><span class="line">行为模式：</span><br><span class="line">   用于描述 “ 类或对象之间怎样共同完成单个对象无法完成的任务 ”，GoF 的书中描述了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器共 十一 种行为模式</span><br></pre></td></tr></table></figure><h2 id="3-好处"><a href="#3-好处" class="headerlink" title="3. 好处"></a>3. 好处</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设计模式是面向对象的设计原则的实际运用，是对类的封装、继承、多态以及类的关联和组合关系的充分理解。</span><br><span class="line">    - 可以提高思维能力、编程能力、设计能力</span><br><span class="line">    - 能让程序设计趋向于标准化、代码编制趋向于工程化，是软件开发效率大大提高，以此来缩短软件的开发周期。</span><br><span class="line">    - 能够让代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E6%9E%B6/spring/"/>
      <url>2021/05/26/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A1%86%E6%9E%B6/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="spring-ioc"><a href="#spring-ioc" class="headerlink" title="spring-ioc"></a>spring-ioc</h2><img src="assets/image-20210514071228690.png" alt="image-20210514071228690" style="zoom:67%;" / loading="lazy"><h3 id="封装标签"><a href="#封装标签" class="headerlink" title="封装标签"></a>封装标签</h3><p>​    <img src="assets/image-20210514071431091.png" alt="image-20210514071431091" style="zoom: 80%;" / loading="lazy"></p><h4 id="PropertyValue"><a href="#PropertyValue" class="headerlink" title="PropertyValue"></a>PropertyValue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    用来封装 property 标签中的属性：</span><br><span class="line">        name、ref、value</span><br><span class="line">        </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放 bean 的子标签 property 属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String ref;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, String ref, String value&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>.name = name;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>.ref = ref;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">this</span>.value = value;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> String getName()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(String ref)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MutablePropertyValues"><a href="#MutablePropertyValues" class="headerlink" title="MutablePropertyValues"></a>MutablePropertyValues</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">一个 bean 可能有多个 property 标签，MutablePropertyValues 中定义 List 集合来管理propertyValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一个 bean 可能由多个 property</span><br><span class="line"> */</span><br><span class="line">public class MutablePropertyValues implements Iterable&lt;PropertyValue&gt; &#123;</span><br><span class="line">    private List&lt;PropertyValue&gt; propertyValues;</span><br><span class="line"></span><br><span class="line">    public MutablePropertyValues() &#123;</span><br><span class="line">        this(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MutablePropertyValues(List&lt;PropertyValue&gt; propertyValues) &#123;</span><br><span class="line">        this.propertyValues= propertyValues == null ? new ArrayList&lt;&gt;() : propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PropertyValue[] getPropertyValues()&#123;</span><br><span class="line">        return propertyValues.toArray(new PropertyValue[0]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PropertyValue getPropertiesValue(String name)&#123;</span><br><span class="line">        for (PropertyValue value : propertyValues) &#123;</span><br><span class="line">            if(value.getName().equals(name))&#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 采用链式编程的方式</span><br><span class="line">     */</span><br><span class="line">    public MutablePropertyValues add(PropertyValue pv)&#123;</span><br><span class="line">        for (int i = 0; i &lt; propertyValues.size(); i++) &#123;</span><br><span class="line">            if(propertyValues.get(i).getName() == pv.getName())&#123;</span><br><span class="line">                propertyValues.set(i,pv);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        propertyValues.add(pv);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty()&#123;</span><br><span class="line">        return propertyValues.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean contains(String name)&#123;</span><br><span class="line">        return getPropertiesValue(name) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;PropertyValue&gt; iterator() &#123;</span><br><span class="line">        return propertyValues.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinition 接口用来封装 bean 的属性，并包含 MutablePropertyValues </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  bean 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutablePropertyValues mutablePropertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">getMutablePropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mutablePropertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMutablePropertyValues</span><span class="params">(MutablePropertyValues mutablePropertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mutablePropertyValues = mutablePropertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义注册表"><a href="#定义注册表" class="headerlink" title="定义注册表"></a>定义注册表</h3><p><img src="assets/image-20210514070742830.png" alt="image-20210514070742830" loading="lazy"></p><h4 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">定义注册表的相关操作规范，用来管理 BeanDefinition</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义操作 bean 的规范</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 BeanDefinition 对象到注册表中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从注册表中删除指定名称的 BeanDefinition 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称从注册表中获取 BeanDefinition 对象</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SimpleBeanDefinitionRegistry"><a href="#SimpleBeanDefinitionRegistry" class="headerlink" title="SimpleBeanDefinitionRegistry"></a>SimpleBeanDefinitionRegistry</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionRegistry 的实现类，使用 Map 来管理 BeanDefinition</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,BeanDefinition&gt; beanDefinitionMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(beanName,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanDefinitionMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p><img src="assets/image-20210514070817608.png" alt="image-20210514070817608" loading="lazy"></p><h4 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionReader 接口定义了解析配置文件并在注册表中注册 BeanDefinition</span><br><span class="line">* 获取注册表的功能，让外界可以通过该对象获取注册表对象。</span><br><span class="line">* 加载配置文件，并注册 BeanDefinition 数据。</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义解析 bean 的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取注册表对象</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//加载配置文件并在注册表中进行注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionReader 的实现类，用来解析 xml 配置文件</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 dom4j 解析 xml 配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registry = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        InputStream in = XmlBeanDefinitionReader.class.getClassLoader().getResourceAsStream(configLocation);</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = reader.read(in);</span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        parseBean(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBean</span><span class="params">(Element rootElement)</span> </span>&#123;</span><br><span class="line">        List&lt;Element&gt; beanElement = rootElement.elements(<span class="string">&quot;bean&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : beanElement) &#123;</span><br><span class="line">            String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String className = element.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">            beanDefinition.setId(id);</span><br><span class="line">            beanDefinition.setClassName(className);</span><br><span class="line">            List&lt;Element&gt; propertyElements = element.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">            MutablePropertyValues mutablePropertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">            <span class="keyword">for</span> (Element property : propertyElements) &#123;</span><br><span class="line">                String name = property.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String ref = property.attributeValue(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                String value = property.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue(name, ref, value);</span><br><span class="line">                mutablePropertyValues.add(propertyValue);</span><br><span class="line">            &#125;</span><br><span class="line">            beanDefinition.setMutablePropertyValues(mutablePropertyValues);</span><br><span class="line">            registry.registerBeanDefinition(beanDefinition.getId(), beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><img src="assets/image-20210514070846094.png" alt="image-20210514070846094" style="zoom:67%;" / loading="lazy"><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    BeanFactory 接口，定义获取 bean 的统一规范</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义获取 bean 对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据bean对象的名称获取bean对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据bean对象的名称获取bean对象，并进行类型转换</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    ApplicationContext 接口，继承于 BeanFactory，规定 bena 对象的创建为非延时的</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//进行配置文件加载并进行对象创建</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext 抽象类实现 ApplicationContext，使用 Map 来管理 bean 对象，并声明 BeanDefinitionReader 接口，用来解析 xml 配置。 BeanDefinitionReader 接口的实现类由子类实现</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> BeanDefinitionReader beanDefinitionReader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String,Object&gt; singletonObject=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String configuraion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(configuraion);</span><br><span class="line">        finishBeanInitialization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">finishBeanInitialization</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();</span><br><span class="line">        String[] definitionNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String definitionName : definitionNames) &#123;</span><br><span class="line">            getBean(definitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext 类实现 AbstractApplicationContext 抽象类， bean 对象的创建并存储在容器中</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configuraion = configuration;</span><br><span class="line">        beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            refresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span>  </span>&#123;</span><br><span class="line">        Object o = singletonObject.get(name);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();</span><br><span class="line">        BeanDefinition beanDefinition = registry.getBeanDefinition(name);</span><br><span class="line">        String className = beanDefinition.getClassName();</span><br><span class="line">        String id = beanDefinition.getId();</span><br><span class="line">        MutablePropertyValues mutablePropertyValues = beanDefinition.getMutablePropertyValues();</span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        Object instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(className);</span><br><span class="line">            instance = clazz.newInstance();</span><br><span class="line">            singletonObject.put(id, instance);</span><br><span class="line">            <span class="keyword">for</span> (PropertyValue propertyValue : mutablePropertyValues) &#123;</span><br><span class="line">                String propertyName = propertyValue.getName();</span><br><span class="line">                String ref = propertyValue.getRef();</span><br><span class="line">                String methodName = StringUtils.getClassMethod(propertyName);</span><br><span class="line">                <span class="keyword">if</span> (ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(ref)) &#123;</span><br><span class="line">                    Object bean = getBean(ref);</span><br><span class="line">                    Method[] methods = clazz.getMethods();</span><br><span class="line">                    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (method.getName().equals(methodName)) &#123;</span><br><span class="line">                            method.invoke(instance, bean);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String value = propertyValue.getValue();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                    Method method = clazz.getMethod(methodName, String.class);</span><br><span class="line">                    method.invoke(instance, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span></span>&#123;</span><br><span class="line">        Object bean = getBean(name);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用的设计模式：</span><br><span class="line">1. 工厂模式：简单工厂 + 配置文件</span><br><span class="line">2. 单例模式：spring 容器创建的对象都是单例的，只创建一次</span><br><span class="line">3. 模板方法模式：AbstractApplicationContext 抽象类中的 finishBeanInitialization（）调用了子类的 getBean（）方法，而 getBean（）的实现和环境有关</span><br><span class="line">4. 迭代器模式：在 MutablePropertyValues 类中使用了迭代器模式，该类存储并管理 PropertyValue 对象，也是一个容器</span><br><span class="line"></span><br><span class="line">spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/"/>
      <url>2021/05/26/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-对象模型"><a href="#Git-对象模型" class="headerlink" title="Git 对象模型"></a>Git 对象模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有用来表示项目历史信息的文件,是通过一个 40 个字符的（40-digit）“对象名”来索引的, 每一个“对象名”都是对“对象”内容做SHA1哈希计算得来的</span><br><span class="line">好处：</span><br><span class="line">1. Git只要比较对象名，就可以很快的判断两个对象是否相同。</span><br><span class="line">2. 如果同样的内容存在两个不同的仓库中，就会存在相同的“对象名”下。</span><br><span class="line">3. Git 还可以通过检查对象内容的 SHA1 的哈希值和“对象名”是否相同，来判断对象内容是否正确</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个对象(object) 包括三个部分：类型、大小、内容，大小指的是内容的大小，内容取决于对象的类型。</span><br><span class="line">四种类型的对象: </span><br><span class="line">1. blob:用来存储文件数据，通常是一个文件。</span><br><span class="line">    2. tree: 有点像一个目录，它管理一些 tree 或是 blob（就像文件和子目录）</span><br><span class="line">    3. commit: 一个 commit 只指向一个 tree ，它用来的标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如时间戳、最近一次提交的作者、指前上次提交（commits）的指针等等。</span><br><span class="line">    4. tag: 一个 tag 是来标记某一个提交(commit) 的方法</span><br></pre></td></tr></table></figure><h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个 blob 通常用来存储文件的内容.可以使用 git show 命令来查看一个 blob 对象里的内容。</span><br><span class="line"></span><br><span class="line">git show 6ff87c4664 //假设一个对现象的 SHA1 的哈希值为 6ff87c4664</span><br><span class="line"></span><br><span class="line">blob 对象内容全部都是数据，如两个文件在一个目录树（或是一个版本仓库）中有同样的数据内容，那么它们将会共享同一个 blob 对象。Blob 对象和其所对应的文件所在路径、文件名是否改被更改都完全没有关系。</span><br></pre></td></tr></table></figure><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个 tree 对象有一串(bunch)指向 blob 对象或是其它 tree 对象的指针，它一般用来来表示内容之间的目录层次关系。</span><br><span class="line">git show 命令可以用来查看 tree 对象，但是 git ls-tree 能让你看到更多的细节。如果我们有一个 tree 对象的SHA1 哈希值为 6ff87c4664</span><br><span class="line"></span><br><span class="line">git ls-tree 6ff87c4664</span><br><span class="line"></span><br><span class="line">一个 tree 对象包括一串(list)条目，每一个条目包括：mode、对象类型、SHA1 值 和名字(这串条目是按名字排序的)。它用来表示一个目录树的内容。</span><br></pre></td></tr></table></figure><h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commit 对象指向一个 tree 对象, 并且带有相关的描述信息</span><br><span class="line">可以用 --pretty=raw 参数来配合 git show 或 git <span class="built_in">log</span> 去查看某个提交(commit)</span><br><span class="line"></span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line"></span><br><span class="line">一个 commit 提交包含以下部分：</span><br><span class="line">• 一个 tree 对象: tree 对象的 SHA1 签名, 代表着目录在某一时间点的内容.</span><br><span class="line">       • 父对象 (parent(s)): 提交(commit)的 SHA1 签名代表着当前提交前一步的项目历史。合并的提交(merge commits)可能会有不只一个父对象. 如果一个提交没有父对象, 那么我们就叫它“根提交<span class="string">&quot;(root commit), 它就代表着项目最初的一个版本(revision). 每个项目必须有至少有一个“根提交&quot;</span>(root commit). 一个项目可能有多个<span class="string">&quot;根提交“，虽然这并不常见(这不是好的作法).</span></span><br><span class="line"><span class="string">       • 作者 : 做了此次修改的人的名字, 还有修改日期.</span></span><br><span class="line"><span class="string">       • 提交者（committer): 实际创建提交(commit)的人的名字, 同时也带有提交日期. TA 可能会和作者不是同一个人; 例如作者写一个补丁(patch)并把它用邮件发给提交者, 由他来创建提交(commit).</span></span><br></pre></td></tr></table></figure><h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&gt;tree</span><br><span class="line">|-- README</span><br><span class="line">-- lib</span><br><span class="line">        |-- inc</span><br><span class="line">        | -- tricks.rb</span><br><span class="line">-- mylib.rb</span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure><h3 id="标签对象"><a href="#标签对象" class="headerlink" title="标签对象"></a>标签对象</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个标签对象包括一个对象名(译者注:就是SHA1签名), 对象类型, 标签名, 标签创建人的名字(<span class="string">&quot;tagger&quot;</span>), 还有一条可能包含有签名(signature)的消息. 你可以用 git cat-file 命令来查看这些信息:</span><br><span class="line">git cat-file tag v1.5.0</span><br></pre></td></tr></table></figure><h2 id="Git-目录"><a href="#Git-目录" class="headerlink" title="Git 目录"></a>Git 目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Git 目录是为你的项目存储所有历史和元信息的目录 - 包括所有的对象(commits,tress,blobs,tags), 这些对象指向不同的分支.</span><br><span class="line">每一个项目只能有一个 Git 目录(这和 SVN,CVS 的每个子目录中都有此类目录相反), 这个叫 .git 的目录在你项目的根目录下(这是默认设置,但并不是必须的). 如果你查看这个目录的内容, 你可以看所有的重要文件:</span><br><span class="line">|-- HEAD # 这个git项目当前处在哪个分支里</span><br><span class="line">|-- config # 项目的配置信息，git config命令会改动它</span><br><span class="line">|-- description # 项目的描述信息</span><br><span class="line">|-- hooks/ # 系统默认钩子脚本目录</span><br><span class="line">|-- index # 索引文件</span><br><span class="line">|-- logs/ # 各个refs的历史信息</span><br><span class="line">|-- objects/ # Git本地仓库的所有对象 (commits, trees, blobs, tags)</span><br><span class="line">`-- refs/ # 标识你项目里的每个分支指向了哪个提交(commit)。</span><br></pre></td></tr></table></figure><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git 的 &#x27;工作目录&#x27; 存储着你现在签出(checkout)来用来编辑的文件. 当你在项目的不同分支间切换时, 工作目录里的文件经常会被替换和删除. 所有历史信息都保存在 &#x27;Git目录&#x27;中 ; 工作目录只用来临时保存签出(checkout) 文件的地方, 你可以编辑工作目录的文件直到下次提交(commit)为止.</span><br></pre></td></tr></table></figure><h2 id="Git-索引"><a href="#Git-索引" class="headerlink" title="Git 索引"></a>Git 索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git 索引是一个在你的工作目录和项目仓库间的暂存区(staging area). 有了它, 你可以把许多内容的修改一起提交(commit). 如果你创建了一个提交(commit), 那么提交的是当前索引(index)里的内容, 而不是工作目录中的内容.</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 git status 命令是查看索引内容的最简单办法. 你运行 git status命令, 就可以看到: 哪些文件被暂存了(就是在你的Git索引中), 哪些文件被修改了但是没有暂存, 还有哪些文件没有被跟踪(untracked).</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\版本控制\assets\image-20210512171514021.png" alt="image-20210512171514021" loading="lazy"></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="Git-仓库"><a href="#Git-仓库" class="headerlink" title="Git 仓库"></a>Git 仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">有两种方法可以得到它：</span><br><span class="line">一种是从已有的Git仓库中clone (克隆，复制)；</span><br><span class="line">一种是新建一个仓库，把未进行版本控制的文件进行版本控制。</span><br></pre></td></tr></table></figure><h4 id="Clone-仓库"><a href="#Clone-仓库" class="headerlink" title="Clone 仓库"></a>Clone 仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Git 能在许多协议下使用，所以 GitURL 可能以ssh://, http(s)://, git://,或是只是以一个用户名（git 会认为这是一个 ssh 地址）为前辍. 有些仓库可以通过不只一种协议来访问</span><br><span class="line">git://</span><br><span class="line">git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/git/git.git</span><br><span class="line"></span><br><span class="line">http://</span><br><span class="line">git <span class="built_in">clone</span> http://www.kernel.org/pub/scm/git/git.git</span><br></pre></td></tr></table></figure><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现在假设有一个叫 ”project.tar.gz” 的压缩文件里包含了你的一些文件，你可以用下面的命令让它置于 Git 的版本控制管理之下.</span><br><span class="line">       $ tar xzf project.tar.gz</span><br><span class="line">       $ <span class="built_in">cd</span> project</span><br><span class="line">       $ git ini</span><br></pre></td></tr></table></figure><h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改文件，将它们更新的内容添加到索引中.</span><br><span class="line"></span><br><span class="line">$ git add file1 file2 file3</span><br><span class="line"></span><br><span class="line">可以使用 git diff 命令再加上 --cached 参数 ,看看哪些文件将被提交(commit)。如果没有--cached参数，git diff 会显示当前你所有已做的但没有加入到索引里的修改.) 你也可以用 git status 命令来获得当前项目的一个状况， Git跟踪的是内容不是文件跟踪的是内容不是文件</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 注释最好以一行短句子作为开头，来简要描述一下这次 commit 所作的修改(最好不要超过50个字符)；然后空一行再把详细的注释写清楚。这样就可以很方便的用工具把commit释变成email通知，第一行作为标题，剩下的部分就作email的正文.</span><br><span class="line">$ git commit xxxx（说明)</span><br><span class="line">$ git commit -a  //自动所有内容被修改的文件(不包括新创建的文件)都添加到索引中，并且提交</span><br></pre></td></tr></table></figure><h3 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一个 Git 仓库可以维护很多开发分支</span><br><span class="line">$ git branch experimental  // 创建名为 experimental 的分支</span><br><span class="line"></span><br><span class="line">$ git branch //会列出所有的分支列表</span><br><span class="line"></span><br><span class="line">$ git checkout experimental // 切换分支</span><br><span class="line"></span><br><span class="line">$ git merge experimental // 合并分支 ，experimental 合并到当前的支线中</span><br><span class="line">如果这个两个分支间的修改没有冲突(conflict), 那么合并就完成了。如有有冲突，输入 $ git diff 命令就可以查看当前有哪些文件产生了冲突，当你编辑了有冲突的文件，解决了冲突后就可以提交了：$ git commit -a。使用 $ git status 会显示这些文件没有合并(unmerged),并会在冲突的文件中添加标识符</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD:file.txt</span></span><br><span class="line"><span class="string">   Hello world</span></span><br><span class="line"><span class="string">   =======</span></span><br><span class="line"><span class="string">   Goodbye</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt;&gt;&gt;&gt;&gt; 77976da35a11db4580b80ae27e8d65caf5208086:file.txt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ gitk // 显示项目的历史</span></span><br><span class="line"><span class="string">$ git branch -d experimental // 已经被当前分支的合并的分支，</span></span><br><span class="line"><span class="string">$ git branch -D crazy-idea //强制删除分支</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="Git-仓库-1"><a href="#Git-仓库-1" class="headerlink" title="Git 仓库"></a>Git 仓库</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E6%AF%95%E8%AE%BE/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/05/26/%E6%AF%95%E8%AE%BE/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="理论基础和主要技术"><a href="#理论基础和主要技术" class="headerlink" title="理论基础和主要技术"></a>理论基础和主要技术</h2><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="设计说明"><a href="#设计说明" class="headerlink" title="设计说明"></a>设计说明</h3><p>​        在软件中，会有很多的数据需要存储，如用户的个人信息、群组信息、好友信息等。如何存储及快速获取信息是考虑的重点。在这里我们使用 MySQL 关系型数据库，主要因为 MySQL 是开源免费的数据库，而且功能强大，可以使用 SQL 语句进行管理 DBMS（DataBase Management System）。</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>​        IM 即时聊天的数据库库设计的步骤：</p><ol><li>需求分析：分析软件中需要存储哪些数据，这些数据又有哪些字段。</li><li>逻辑设计：用 E-R 图来展示这些需要存储数据的逻辑模型。</li><li>物理设计：使用 SQL 语句根据逻辑模型创建表。</li><li>维护与优化：大表拆分，索引优化。</li></ol><h4 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h4><p>​    该软件中需要的实体有用户、群组、消息、关注等。 用户与群组之间是多对多的关系，</p><p>用户与用户之间的消息是一对一的关系，用户与群组之间的是多对多的关系。有了实体对象和实体与实体之间的关系，我们还需要具体的实体属性，三者齐全后，我们可以用 E-R 图来进行逻辑上的表示。</p><h4 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h4><p>​        <strong>E-R 图——用户</strong></p><p><img src="C:\Users\97797\OneDrive\笔记\毕设\assets\image-20210511185828749.png" alt="image-20210511185828749" loading="lazy"></p><h4 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h4><p>​        <strong>用户表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `m_user` (</span><br><span class="line">  `id` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `PASSWORD` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `portrait` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `description` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;自我描述&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `token` <span class="type">VARCHAR</span>(<span class="number">255</span>)  <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;密钥&#x27;</span>,</span><br><span class="line">  `push_id` <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;推送id&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT<span class="string">&#x27; 创建时间&#x27;</span>,</span><br><span class="line">  `update_time` DATETIME  COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `last_login` DATETIME  COMMENT <span class="string">&#x27;上次登录时间&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据实现"><a href="#数据实现" class="headerlink" title="数据实现"></a>数据实现</h4><p><img src="C:\Users\97797\OneDrive\笔记\毕设\assets\image-20210511224452155.png" alt="image-20210511224452155" loading="lazy"></p><h2 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h2><h3 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h3><p>​        用户需要登录后才能使用该软件</p><ul><li><p>流程图</p><p><img src="C:\Users\97797\OneDrive\笔记\毕设\assets\login.png" alt="login" loading="lazy"></p></li></ul><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01_MySQL</title>
      <link href="2021/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
      <url>2021/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-数据库的基本概念"><a href="#1-数据库的基本概念" class="headerlink" title="1. 数据库的基本概念"></a>1. 数据库的基本概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 数据库的英文单词： DataBase 简称 ： DB</span><br><span class="line">2. 什么数据库？</span><br><span class="line">   * 用于存储和管理数据的仓库。</span><br><span class="line"></span><br><span class="line">3. 数据库的特点：</span><br><span class="line">   1. 持久化存储数据的。数据库是一个文件系统</span><br><span class="line">   2. 方便存储和管理数据</span><br><span class="line">   3. 使用了统一的方式操作数据库 -- SQL</span><br></pre></td></tr></table></figure><h2 id="2-SQL-语句"><a href="#2-SQL-语句" class="headerlink" title="2. SQL 语句"></a>2. SQL 语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.什么是 SQL？</span><br><span class="line">Structured Query Language：结构化查询语言</span><br><span class="line">其实是定义了操作所有关系型数据库的规则。每一种数据库操作的方式有不一样的地方，称为“方言”。</span><br><span class="line"></span><br><span class="line">2.SQL 通用语法</span><br><span class="line">1. SQL 语句可以单行或多行书写，以分号结尾。</span><br><span class="line">2. 可使用空格和缩进来增强语句的可读性。</span><br><span class="line">3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</span><br><span class="line">4. 3 种注释</span><br><span class="line">* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) </span><br><span class="line">* 多行注释: /* 注释 */</span><br><span class="line"></span><br><span class="line">3. SQL分类</span><br><span class="line">1) DDL(Data Definition Language)数据定义语言</span><br><span class="line">用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</span><br><span class="line">2) DML(Data Manipulation Language)数据操作语言</span><br><span class="line">用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</span><br><span class="line">3) DQL(Data Query Language)数据查询语言</span><br><span class="line">用来查询数据库中表的记录(数据)。关键字：select, where 等</span><br><span class="line">4) DCL(Data Control Language)数据控制语言(了解)</span><br><span class="line">用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</span><br></pre></td></tr></table></figure><h2 id="3-DDL"><a href="#3-DDL" class="headerlink" title="3. DDL"></a>3. DDL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Data Definition Language) 数据定义语言,对数据库和表的操作</span><br></pre></td></tr></table></figure><h3 id="3-1-DB-–-CRUD"><a href="#3-1-DB-–-CRUD" class="headerlink" title="3.1 DB – CRUD"></a>3.1 DB – CRUD</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">操作数据库：CRUD</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">C(Create):创建</span></span><br><span class="line"><span class="meta">*</span> <span class="string">创建数据库：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">create database 数据库名称;</span></span><br><span class="line"><span class="meta">*</span> <span class="string">创建数据库，判断不存在，再创建：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">create database if not exists 数据库名称;</span></span><br><span class="line"><span class="meta">*</span> <span class="string">创建数据库，并指定字符集</span></span><br><span class="line"><span class="meta">*</span> <span class="string">create database 数据库名称 character set 字符集名;</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">R(Retrieve)：查询</span></span><br><span class="line"><span class="meta">*</span> <span class="string">查询所有数据库的名称:</span></span><br><span class="line"><span class="meta">*</span> <span class="string">show databases;</span></span><br><span class="line"><span class="meta">*</span> <span class="string">查询某个数据库的字符集:查询某个数据库的创建语句</span></span><br><span class="line"><span class="meta">*</span> <span class="string">show create database 数据库名称;</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">U(Update):修改</span></span><br><span class="line"><span class="meta">*</span> <span class="string">修改数据库的字符集</span></span><br><span class="line"><span class="meta">*</span> <span class="string">alter database 数据库名称 character set 字符集名称;</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">D(Delete):删除</span></span><br><span class="line"><span class="meta">*</span> <span class="string">删除数据库</span></span><br><span class="line"><span class="meta">*</span> <span class="string">drop database 数据库名称;</span></span><br><span class="line"><span class="meta">*</span> <span class="string">判断数据库存在，存在再删除</span></span><br><span class="line"><span class="meta">*</span> <span class="string">drop database if exists 数据库名称;</span></span><br><span class="line"><span class="meta">5.</span> <span class="string">使用数据库</span></span><br><span class="line"><span class="meta">*</span> <span class="string">查询当前正在使用的数据库名称</span></span><br><span class="line"><span class="meta">*</span> <span class="string">select database();</span></span><br><span class="line"><span class="meta">*</span> <span class="string">使用数据库</span></span><br><span class="line"><span class="meta">*</span> <span class="string">use 数据库名称;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Tables-–-CRUD"><a href="#3-2-Tables-–-CRUD" class="headerlink" title="3.2 Tables – CRUD"></a>3.2 Tables – CRUD</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">操作表-CRUD</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">C(Create):创建</span></span><br><span class="line"><span class="attr">create</span> <span class="string">table 表名(</span></span><br><span class="line"><span class="meta">列名1</span> <span class="string">数据类型1,</span></span><br><span class="line"><span class="meta">列名2</span> <span class="string">数据类型2,</span></span><br><span class="line"><span class="attr">....</span></span><br><span class="line"><span class="meta">列名n</span> <span class="string">数据类型n</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：最后一列，不需要加逗号（,）</span></span><br><span class="line"><span class="meta">*</span> <span class="string">数据库常用类型类型：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">int：整数类型</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">double：小数类型</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">date：日期，只包含年月日，yyyy-MM-dd</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">datetime：日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">5.</span> <span class="string">timestamp：时间错类型包含年月日时分秒 yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">*</span> <span class="string">如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</span></span><br><span class="line"><span class="meta">6.</span> <span class="string">varchar：字符串</span></span><br><span class="line">            <span class="meta">*</span> <span class="string">复制表：</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">create table 表名 like 被复制的表名;</span></span><br><span class="line">                </span><br><span class="line"><span class="meta">2.</span> <span class="string">R(Retrieve)：查询</span></span><br><span class="line">            <span class="meta">*</span> <span class="string">查询某个数据库中所有的表名称</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">show tables;</span></span><br><span class="line">            <span class="meta">*</span> <span class="string">查询表结构</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">desc 表名;</span></span><br><span class="line">                </span><br><span class="line"> <span class="meta">3.</span> <span class="string">U(Update):修改</span></span><br><span class="line">            <span class="meta">1.</span> <span class="string">修改表名</span></span><br><span class="line">                <span class="attr">alter</span> <span class="string">table 表名 rename to 新的表名;</span></span><br><span class="line">            <span class="meta">2.</span> <span class="string">修改表的字符集</span></span><br><span class="line">                <span class="attr">alter</span> <span class="string">table 表名 character set 字符集名称;</span></span><br><span class="line">            <span class="meta">3.</span> <span class="string">添加一列</span></span><br><span class="line">                <span class="attr">alter</span> <span class="string">table 表名 add 列名 数据类型;</span></span><br><span class="line">            <span class="meta">4.</span> <span class="string">修改列名称 类型</span></span><br><span class="line">                <span class="attr">alter</span> <span class="string">table 表名 change 列名 新列别 新数据类型;</span></span><br><span class="line">                <span class="attr">alter</span> <span class="string">table 表名 modify 列名 新数据类型;</span></span><br><span class="line">            <span class="meta">5.</span> <span class="string">删除列</span></span><br><span class="line">                <span class="attr">alter</span> <span class="string">table 表名 drop 列名;</span></span><br><span class="line">                </span><br><span class="line"> <span class="meta">4.</span> <span class="string">D(Delete):删除</span></span><br><span class="line">            <span class="meta">*</span> <span class="string">drop table 表名;</span></span><br><span class="line">            <span class="meta">*</span> <span class="string">drop table  if exists 表名 ;</span></span><br></pre></td></tr></table></figure><h2 id="4-DML"><a href="#4-DML" class="headerlink" title="4. DML"></a>4. DML</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DML(Data Manipulation Language)数据操作语言</span><br></pre></td></tr></table></figure><h3 id="4-1-CRUD"><a href="#4-1-CRUD" class="headerlink" title="4.1 CRUD"></a>4.1 CRUD</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">添加数据：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);</span></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">列名和值要一一对应。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">如果表名后，不定义列名，则默认给所有列添加值</span></span><br><span class="line"><span class="attr">insert</span> <span class="string">into 表名 values(值1,值2,...值n);</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">除了数字类型，其他类型需要使用引号(单双都可以)引起来</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">删除数据：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">delete from 表名 [where 条件]</span></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">如果不加条件，则删除表中所有记录。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">如果要删除所有记录</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">修改数据：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">如果不加任何条件，则会将表中所有记录全部修改。</span></span><br></pre></td></tr></table></figure><h2 id="5-DQL"><a href="#5-DQL" class="headerlink" title="5. DQL"></a>5. DQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DQL(Data Query Language)数据查询语言</span><br></pre></td></tr></table></figure><h3 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">select</span> <span class="string">* from 表名;</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">语法：</span></span><br><span class="line"><span class="attr">select</span></span><br><span class="line"><span class="attr">字段列表</span></span><br><span class="line"><span class="attr">from</span></span><br><span class="line"><span class="attr">表名列表</span></span><br><span class="line"><span class="attr">where</span></span><br><span class="line"><span class="attr">条件列表</span></span><br><span class="line"><span class="attr">group</span> <span class="string">by</span></span><br><span class="line"><span class="attr">分组字段</span></span><br><span class="line"><span class="attr">having</span></span><br><span class="line"><span class="attr">分组之后的条件</span></span><br><span class="line"><span class="attr">order</span> <span class="string">by</span></span><br><span class="line"><span class="attr">排序</span></span><br><span class="line"><span class="attr">limit</span></span><br><span class="line"><span class="attr">分页限定</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-基础查询"><a href="#5-2-基础查询" class="headerlink" title="5.2 基础查询"></a>5.2 基础查询</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.</span> <span class="string">基础查询</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">多个字段的查询</span></span><br><span class="line"><span class="attr">select</span> <span class="string">字段名1，字段名2... from 表名；</span></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">如果查询所有字段，则可以使用*来替代字段列表。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">去除重复：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">distinct</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">计算列</span></span><br><span class="line"><span class="meta">*</span> <span class="string">一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</span></span><br><span class="line"><span class="meta">*</span> <span class="string">ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null</span></span><br><span class="line"><span class="meta">*</span> <span class="string">表达式1：哪个字段需要判断是否为null</span></span><br><span class="line"><span class="meta">*</span> <span class="string">如果该字段为null后的替换值。</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">起别名：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">as：as也可以省略</span></span><br></pre></td></tr></table></figure><h3 id="5-3-条件查询"><a href="#5-3-条件查询" class="headerlink" title="5.3 条件查询"></a>5.3 条件查询</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">3.</span> <span class="string">条件查询</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">where子句后跟条件</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">运算符</span></span><br><span class="line"><span class="meta">*</span> <span class="string">&gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</span></span><br><span class="line"><span class="meta">*</span> <span class="string">BETWEEN...AND  </span></span><br><span class="line"><span class="meta">*</span> <span class="string">IN( 集合) </span></span><br><span class="line"><span class="meta">*</span> <span class="string">LIKE：模糊查询</span></span><br><span class="line"><span class="meta">*</span> <span class="string">占位符：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">_:单个任意字符</span></span><br><span class="line"><span class="meta">*</span> <span class="string">%：多个任意字符</span></span><br><span class="line"><span class="meta">*</span> <span class="string">IS NULL  </span></span><br><span class="line"><span class="meta">*</span> <span class="string">and  或 &amp;&amp;</span></span><br><span class="line"><span class="meta">*</span> <span class="string">or  或 || </span></span><br><span class="line"><span class="meta">*</span> <span class="string">not  或 !</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-排序查询"><a href="#5-4-排序查询" class="headerlink" title="5.4 排序查询"></a>5.4 排序查询</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">排序查询</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：order by 子句</span></span><br><span class="line"><span class="meta">*</span> <span class="string">order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">*</span> <span class="string">排序方式：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">ASC：升序，默认的。</span></span><br><span class="line"><span class="meta">*</span> <span class="string">DESC：降序。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</span></span><br></pre></td></tr></table></figure><h3 id="5-5-聚合函数"><a href="#5-5-聚合函数" class="headerlink" title="5.5 聚合函数"></a>5.5 聚合函数</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.</span> <span class="string">聚合函数：将一列数据作为一个整体，进行纵向的计算。</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">count：计算个数</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">一般选择非空的列：主键</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">count(*)</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">max：计算最大值</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">min：计算最小值</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">sum：计算和</span></span><br><span class="line"><span class="meta">5.</span> <span class="string">avg：计算平均值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">*</span> <span class="string">注意：聚合函数的计算，排除null值。</span></span><br><span class="line"><span class="attr">解决方案：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">选择不包含非空的列进行计算</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">IFNULL 函数</span></span><br></pre></td></tr></table></figure><h3 id="5-6-分组查询"><a href="#5-6-分组查询" class="headerlink" title="5.6 分组查询"></a>5.6 分组查询</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">3.</span> <span class="string">分组查询:</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">语法：group by 分组字段；</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">分组之后查询的字段：分组字段、聚合函数</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">where 和 having 的区别？</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">where 后不可以跟聚合函数，having可以进行聚合函数的判断。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-7-分页查询"><a href="#5-7-分页查询" class="headerlink" title="5.7 分页查询"></a>5.7 分页查询</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">4.</span> <span class="string">分页查询</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">语法：limit 开始的索引,每页查询的条数;</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</span></span><br><span class="line"><span class="meta">--</span> <span class="string">每页显示3条记录 </span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student LIMIT 0,3; -- 第1页</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student LIMIT 3,3; -- 第2页</span></span><br><span class="line"></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student LIMIT 6,3; -- 第3页</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.</span> <span class="string">limit 是一个 MySQL &quot;方言&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-8-约束"><a href="#5-8-约束" class="headerlink" title="5.8 约束"></a>5.8 约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</span><br><span class="line">* 分类：</span><br><span class="line">1. 主键约束：primary key</span><br><span class="line">2. 非空约束：not null</span><br><span class="line">3. 唯一约束：unique</span><br><span class="line">4. 外键约束：foreign key</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-8-1-primary-key"><a href="#5-8-1-primary-key" class="headerlink" title="5.8.1 primary key"></a>5.8.1 primary key</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">主键约束：primary key。</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">注意：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">含义：非空且唯一</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">一张表只能有一个字段为主键</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">主键就是表中记录的唯一标识</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.</span> <span class="string">在创建表时，添加主键约束</span></span><br><span class="line"><span class="attr">create</span> <span class="string">table stu(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">int primary key,-- 给id添加主键约束</span></span><br><span class="line"><span class="attr">name</span> <span class="string">varchar(20)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.</span> <span class="string">删除主键</span></span><br><span class="line"><span class="meta">--</span> <span class="string">错误 alter table stu modify id int ;</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu DROP PRIMARY KEY;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">4.</span> <span class="string">创建完表后，添加主键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu MODIFY id INT PRIMARY KEY;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-8-2-not-null"><a href="#5-8-2-not-null" class="headerlink" title="5.8.2 not null"></a>5.8.2 not null</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">非空约束：not null，值不能为null</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">创建表时添加约束</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE stu(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT,</span></span><br><span class="line"><span class="attr">NAME</span> <span class="string">VARCHAR(20) NOT NULL -- name为非空</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">创建表完后，添加非空约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.</span> <span class="string">删除 name 的非空约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu MODIFY NAME VARCHAR(20);</span></span><br></pre></td></tr></table></figure><h4 id="5-8-3-unique"><a href="#5-8-3-unique" class="headerlink" title="5.8.3 unique"></a>5.8.3 unique</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">唯一约束：unique，值不能重复</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">创建表时，添加唯一约束</span></span><br><span class="line"><span class="attr">CREATE</span> <span class="string">TABLE stu(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">INT,</span></span><br><span class="line"><span class="attr">phone_number</span> <span class="string">VARCHAR(20) UNIQUE -- 添加了唯一约束</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="meta">*</span> <span class="string">注意mysql中，唯一约束限定的列的值可以有多个 null</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">删除唯一约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu DROP INDEX phone_number;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.</span> <span class="string">在创建表后，添加唯一约束</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</span></span><br></pre></td></tr></table></figure><h4 id="5-8-4-foreign-key"><a href="#5-8-4-foreign-key" class="headerlink" title="5.8.4 foreign key"></a>5.8.4 foreign key</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">在创建表时，可以添加外键</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：</span></span><br><span class="line"><span class="attr">create</span> <span class="string">table 表名(</span></span><br><span class="line"><span class="attr">....</span></span><br><span class="line"><span class="attr">外键列</span></span><br><span class="line"><span class="attr">constraint</span> <span class="string">外键名称 foreign key (外键列名称) references 主表名称(主表列名称)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.</span> <span class="string">删除外键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE 表名 DROP FOREIGN KEY 外键名称;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.</span> <span class="string">创建表之后，添加外键</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</span></span><br></pre></td></tr></table></figure><h4 id="5-8-5-auto-increment"><a href="#5-8-5-auto-increment" class="headerlink" title="5.8.5 auto_increment"></a>5.8.5 auto_increment</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span>  <span class="string">概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">在创建表时，添加主键约束，并且完成主键自增长</span></span><br><span class="line"><span class="attr">create</span> <span class="string">table stu(</span></span><br><span class="line"><span class="attr">id</span> <span class="string">int primary key auto_increment,-- 给id添加主键约束</span></span><br><span class="line"><span class="attr">name</span> <span class="string">varchar(20)</span></span><br><span class="line"><span class="attr">);</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">删除自动增长</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu MODIFY id INT;</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">添加自动增长</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">TABLE stu MODIFY id INT AUTO_INCREMENT;</span></span><br></pre></td></tr></table></figure><h4 id="5-8-6-级联操作"><a href="#5-8-6-级联操作" class="headerlink" title="5.8.6 级联操作"></a>5.8.6 级联操作</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">4.</span> <span class="string">级联操作</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">添加级联操作</span></span><br><span class="line"><span class="meta">语法：ALTER</span> <span class="string">TABLE 表名 ADD CONSTRAINT 外键名称 </span></span><br><span class="line"><span class="attr">FOREIGN</span> <span class="string">KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">分类：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">级联更新：ON UPDATE CASCADE </span></span><br><span class="line"><span class="meta">2.</span> <span class="string">级联删除：ON DELETE CASCADE </span></span><br></pre></td></tr></table></figure><h2 id="6-DCL"><a href="#6-DCL" class="headerlink" title="6. DCL"></a>6. DCL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">* DBA：数据库管理员</span><br><span class="line">* DCL：管理用户，授权</span><br><span class="line">1. 管理用户</span><br><span class="line">1. 添加用户：</span><br><span class="line">* 语法：CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="line">2. 删除用户：</span><br><span class="line">* 语法：DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">3. 修改用户密码：</span><br><span class="line"></span><br><span class="line">UPDATE USER SET PASSWORD = PASSWORD(&#x27;新密码&#x27;) WHERE USER = &#x27;用户名&#x27;;</span><br><span class="line">SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; = PASSWORD(&#x27;新密码&#x27;);</span><br><span class="line"></span><br><span class="line">* mysql中忘记了root用户的密码？</span><br><span class="line">2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables</span><br><span class="line">5. update user set password = password(&#x27;你的新密码&#x27;) where user = &#x27;root&#x27;;</span><br><span class="line">7. 打开任务管理器，手动结束mysqld.exe 的进程</span><br><span class="line">4. 查询用户：</span><br><span class="line">SELECT * FROM USER;</span><br><span class="line">* 通配符： % 表示可以在任意主机使用用户登录数据库</span><br><span class="line"></span><br><span class="line">2. 权限管理：</span><br><span class="line">1. 查询权限：</span><br><span class="line">-- 查询权限</span><br><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line"></span><br><span class="line">2. 授予权限：</span><br><span class="line">-- 授予权限</span><br><span class="line">grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line">3. 撤销权限：</span><br><span class="line">-- 撤销权限：</span><br><span class="line">revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="line">REVOKE UPDATE ON db3.`account` FROM &#x27;lisi&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="7-数据库设计"><a href="#7-数据库设计" class="headerlink" title="7. 数据库设计"></a>7. 数据库设计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 多表之间的关系</span><br><span class="line">1. 分类：</span><br><span class="line">1. 一对一(了解)：</span><br><span class="line">* 如：人和身份证</span><br><span class="line">* 分析：一个人只有一个身份证，一个身份证只能对应一个人</span><br><span class="line">2. 一对多(多对一)：</span><br><span class="line">* 如：部门和员工</span><br><span class="line">* 分析：一个部门有多个员工，一个员工只能对应一个部门</span><br><span class="line">3. 多对多：</span><br><span class="line">* 如：学生和课程</span><br><span class="line">* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</span><br><span class="line">2. 实现关系：</span><br><span class="line">1. 一对多(多对一)：</span><br><span class="line">* 如：部门和员工</span><br><span class="line">* 实现方式：在多的一方建立外键，指向一的一方的主键。</span><br><span class="line">2. 多对多：</span><br><span class="line">* 如：学生和课程</span><br><span class="line">* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</span><br><span class="line">3. 一对一(了解)：</span><br><span class="line">* 如：人和身份证</span><br><span class="line">* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2. 数据库设计的范式</span><br><span class="line">* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</span><br><span class="line">设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</span><br><span class="line">目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</span><br><span class="line"></span><br><span class="line">* 分类：</span><br><span class="line">1. 第一范式（1NF）：每一列都是不可分割的原子数据项</span><br><span class="line">2. 第二范式（2NF）：在 1NF 的基础上，非码属性必须完全依赖于码（在 1NF 基础上消除非主属性对主码的部分函数依赖）</span><br><span class="line">* 几个概念：</span><br><span class="line">1. 函数依赖：A--&gt;B,如果通过 A 属性(属性组)的值，可以确定唯一B属性的值。则称 B 依赖于A</span><br><span class="line">例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数</span><br><span class="line">2. 完全函数依赖：A--&gt;B， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。</span><br><span class="line">例如：（学号，课程名称） --&gt; 分数</span><br><span class="line">3. 部分函数依赖：A--&gt;B， 如果 A 是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。</span><br><span class="line">例如：（学号，课程名称） -- &gt; 姓名</span><br><span class="line">4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A</span><br><span class="line">例如：学号--&gt;系名，系名--&gt;系主任</span><br><span class="line">5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码</span><br><span class="line">例如：该表中码为：（学号，课程名称）</span><br><span class="line">* 主属性：码属性组中的所有属性</span><br><span class="line">* 非主属性：除过码属性组的属性</span><br><span class="line"></span><br><span class="line">3. 第三范式（3NF）：在 2NF 基础上，任何非主属性不依赖于其它非主属性（在 2N F基础上消除传递依赖）</span><br></pre></td></tr></table></figure><h2 id="8-数据库的备份和还原"><a href="#8-数据库的备份和还原" class="headerlink" title="8. 数据库的备份和还原"></a>8. 数据库的备份和还原</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">命令行：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</span></span><br><span class="line"><span class="meta">*</span> <span class="string">还原：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">登录数据库</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">创建数据库</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">使用数据库</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">执行文件。source 文件路径</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">图形化工具：</span></span><br></pre></td></tr></table></figure><h2 id="9-多表查询"><a href="#9-多表查询" class="headerlink" title="9. 多表查询"></a>9. 多表查询</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">*</span> <span class="string">多表查询的分类：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">内连接查询：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">隐式内连接：使用 where 条件消除无用数据</span></span><br><span class="line">        <span class="meta">2.</span> <span class="string">显式内连接：</span></span><br><span class="line">                <span class="meta">*</span> <span class="string">语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件</span></span><br><span class="line">                </span><br><span class="line">    <span class="meta">2.</span> <span class="string">外链接查询：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">左外连接：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；</span></span><br><span class="line"><span class="meta">*</span> <span class="string">查询的是左表所有数据以及其交集部分。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">子查询：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">概念：查询中嵌套查询，称嵌套查询为子查询。</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">子查询的结果是单行单列的：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">子查询的结果是多行单列的：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">子查询可以作为条件，使用运算符in来判断</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">子查询的结果是多行多列的：</span></span><br><span class="line"><span class="meta">*</span> <span class="string">子查询可以作为一张虚拟表参与查询</span></span><br></pre></td></tr></table></figure><h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10. 事务"></a>10. 事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 事务的基本介绍</span><br><span class="line">1. 概念：</span><br><span class="line">*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</span><br><span class="line"></span><br><span class="line">2. 操作：</span><br><span class="line">1. 开启事务： start transaction;</span><br><span class="line">2. 回滚：rollback;</span><br><span class="line">3. 提交：commit;</span><br><span class="line"></span><br><span class="line">3. MySQ L数据库中事务默认自动提交</span><br><span class="line">* 事务提交的两种方式：</span><br><span class="line">* 自动提交：</span><br><span class="line">* mysql 就是自动提交的</span><br><span class="line">* 一条 DML(增删改) 语句会自动提交一次事务。</span><br><span class="line">* 手动提交：</span><br><span class="line">* Oracle 数据库默认是手动提交事务</span><br><span class="line">* 需要先开启事务，再提交</span><br><span class="line">* 修改事务的默认提交方式：</span><br><span class="line">* 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交</span><br><span class="line">* 修改默认提交方式： set @@autocommit = 0;</span><br></pre></td></tr></table></figure><h3 id="10-1-事务的四大特征"><a href="#10-1-事务的四大特征" class="headerlink" title="10.1 事务的四大特征"></a>10.1 事务的四大特征</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">2.</span> <span class="string">事务的四大特征：</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">持久性：当事务提交或回滚后，数据库会持久化的保存数据。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">隔离性：多个事务之间。相互独立。</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">一致性：事务操作前后，数据总量不变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3. 事务的隔离级别（了解）</span><br><span class="line">* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</span><br><span class="line">* 存在问题：</span><br><span class="line">1. 脏读：一个事务，读取到另一个事务中没有提交的数据</span><br><span class="line">2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</span><br><span class="line">* 隔离级别：</span><br><span class="line">1. read uncommitted：读未提交</span><br><span class="line">* 产生的问题：脏读、不可重复读、幻读</span><br><span class="line">2. read committed：读已提交 （Oracle）</span><br><span class="line">* 产生的问题：不可重复读、幻读</span><br><span class="line">3. repeatable read：可重复读 （MySQL默认）</span><br><span class="line">* 产生的问题：幻读</span><br><span class="line">4. serializable：串行化</span><br><span class="line">* 可以解决所有的问题</span><br><span class="line"></span><br><span class="line">* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低</span><br><span class="line">* 数据库查询隔离级别：</span><br><span class="line">* select @@tx_isolation;</span><br><span class="line">* 数据库设置隔离级别：</span><br><span class="line">* set global transaction isolation level  级别字符串;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03_MyBatis</title>
      <link href="2021/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis/"/>
      <url>2021/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mybatis（前身是 iBatis）是一个支持普通 SQL 查询、存储过程及高级映射的持久层框架，几乎消除了 JDBC 代码和参数的手动设置以及对结果集的检索，并使用简单的 XML 或注解进行配置和原始映射，将接口和 Java 的 POJO（Plain Old Java Object，普通 Java 对象）映射成数据库中的记录。</span><br><span class="line">MyBatis 框架也称为 ORM 框架（Object/Relational Mapping，对象关系映射），是一种解决面向对象与关系型数据库中数据类型不匹配的技术，通过描述 Java 对象与数据库表之间的映射关系，自动的将 Java 应用程序中的对象持久化到关系型数据库的表中。、</span><br><span class="line">使用 ORM 框架后，应用程序不在直接访问底层数据库，二是以面向对象的方式来操作持久化对象 （Persisent Object，PO），ORM框架会通过映射将面向对象的操作转换成底层的SQL操作。</span><br></pre></td></tr></table></figure><h2 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h2><h3 id="2-1-图示"><a href="#2-1-图示" class="headerlink" title="2.1 图示"></a>2.1 图示</h3><p><img src="C:\Users\97797\OneDrive\笔记\数据库\assets\image-20210408164339747.png" alt="image-20210408164339747" loading="lazy"></p><h3 id="2-2-文字描述"><a href="#2-2-文字描述" class="headerlink" title="2.2 文字描述"></a>2.2 文字描述</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1.</span> <span class="string">读取 MyBatis 配置文件 mybatis-config.xml。mybaits-config.xml 作为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，主要内容是获取数据库连接。</span></span><br><span class="line"><span class="meta">2.</span> <span class="string">加载映射文件 Mapper.xml。Mapper.xml 文件是 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 mybatis-config.xml 中加载才能运行。mybatis-config.xml 可以加载多个配置，每个配置文件对应数据库中的一张表。</span></span><br><span class="line"><span class="meta">3.</span> <span class="string">构建会话工厂。通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</span></span><br><span class="line"><span class="meta">4.</span> <span class="string">创建 SqlSession 对象。由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 的所有方法。</span></span><br><span class="line"><span class="meta">5.</span> <span class="string">MyBatis 底层定义了一个 Executor 接口来操作数据库，它数根据 SqlSession 传递的参数动态的生成需要执行的 SQL 语句，同时负责查询缓存的维护。</span></span><br><span class="line"><span class="meta">6.</span> <span class="string">在 Executor 接口的执行方法中，包含一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等。Mapper.xml 文件中一个 SQL 对应一个 MappedStatement 对象，SQL 的 id 是 MappedStatement 的 id。</span></span><br><span class="line"><span class="meta">7.</span> <span class="string">输入参数映射。在执行方法是，MappedStatement 对象会对用户执行 SQL 语句的输入参数进行定义（可以定义为 Map、List 类型、基本类型和 POJO 类型），Executor 执行器会通过MappedStatement 对象在执行 SQL 前，将输入的 Java 对象映射到 SQL 语句中。</span></span><br><span class="line"><span class="meta">8.</span> <span class="string">输出结果映射。在数据库中执行完 SQL 语句后，MappedStatement 对象会对 SQL 执行输出的结果进行定义（可以定义为 Map、List 类型、基本类型和 POJO 类型），Executor 执行器会通过 MappedStatement 对象在执行 SQL 语句后，将输出结构映射到 Java 对象中。</span></span><br></pre></td></tr></table></figure><h2 id="3-核心对象"><a href="#3-核心对象" class="headerlink" title="3. 核心对象"></a>3. 核心对象</h2><h3 id="3-1-SqlSessionFactory"><a href="#3-1-SqlSessionFactory" class="headerlink" title="3.1 SqlSessionFactory"></a>3.1 SqlSessionFactory</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是单个数据库映射关系经过编译后的内存镜像，主要是用来创建 SqlSession 。SqlSessionFactory 对象实例可以通过 SqlSessionFactoryBuilder 对象来构建，而 SqlSessionFactoryBuilder可以通过 XML 配置文件或预先定义好的 Configuration 实例构建出 SqlSessionFactory 的实例。</span><br><span class="line">SqlSessionFactory 对象是线程安全的，一旦被创建，在整个应用执行期间都会存在。</span><br></pre></td></tr></table></figure><h3 id="3-2-SqlSession"><a href="#3-2-SqlSession" class="headerlink" title="3.2 SqlSession"></a>3.2 SqlSession</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">是应用程序持久层之间执行交互操作的一个单线程对象，现主要是执行持久化操作。SqlSession 对象包含了数据库中所有执行 SQL 操作的方法，由于底层封装了 JDBC 连接，可以直接使用实例来执行已映射的 SQL 语句。</span><br><span class="line">每一个线程都应该有一个自己的 SqlSession 实例，该实例是不能被共享的。同时，SqlSession 实例也是线程不安全的，最好在一次请求或一个方法中使用。</span><br></pre></td></tr></table></figure><h2 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h2><p><img src="C:\Users\97797\OneDrive\笔记\数据库\assets\image-20210408200050010.png" alt="image-20210408200050010" loading="lazy"></p><h4 id="4-1-properties"><a href="#4-1-properties" class="headerlink" title="4.1 properties"></a>4.1 properties</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;元素是一个配置属性的元素，通常用于将内部的配置外在化，通过外部的配置来动态地替换内部定义的属性。</span><br></pre></td></tr></table></figure><h4 id="4-2-settings"><a href="#4-2-settings" class="headerlink" title="4.2 settings"></a>4.2 settings</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打印 SQL 语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用驼峰命名法转换字段。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;NULL&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-typeAliases"><a href="#4-3-typeAliases" class="headerlink" title="4.3 typeAliases"></a>4.3 typeAliases</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt; 元素用来配置文件中的 Java 型设置一个简短的名字（设置别名），一般默认是类名，不区分大小写</span><br></pre></td></tr></table></figure><h4 id="4-4-environments"><a href="#4-4-environments" class="headerlink" title="4.4 environments"></a>4.4 environments</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span>&gt;</span> 元素是用来对环境进行配置，MyBatis 的环境配置是对数据源的配置，<span class="tag">&lt;<span class="name">environments</span>&gt;</span> 元素可配置多种数据源，也就是多种数据库。</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配合环境,默认的环境id为mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置id为mysql的数据库环境,可配置多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 使用JDBC的事务管理,type属性指定事务管理的方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接池,type属性指定使用哪种数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>/&gt;</span> //事务管理</span><br><span class="line">        type：</span><br><span class="line">            1. JDBC：使用 JDBC 的提交和回滚，它依赖于从数据源得到的连接来管理事务的作用域</span><br><span class="line">            2. MANAGED：从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。</span><br><span class="line">        * 在 spring 中会使用 Spring 自带的管理器来实现事务管理。</span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span> // 是否使用池</span><br><span class="line">      type：</span><br><span class="line">     1. POOLED：据源利用 &quot; 池 &quot; 的概念将 JDBC 连接对象组织起来，避免了在创建新的连接实例时所需要初始化和认证的时间。</span><br><span class="line">     2，UNPOOLED： 不使用池 </span><br><span class="line">      </span><br></pre></td></tr></table></figure><h4 id="4-5-mappers"><a href="#4-5-mappers" class="headerlink" title="4.5 mappers"></a>4.5 mappers</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在配置文件中，&lt;mappers&gt; 元素是指定MyBatis映射文件的位置。支持四种引入方式：</span><br><span class="line">1. &lt;mapper url=&quot;&quot; /&gt;  // 网络地址</span><br><span class="line">2. &lt;mapper class=&quot;&quot; /&gt; // 接口类</span><br><span class="line">3. &lt;mapper resource=&quot;&quot; /&gt; // Mapper 配置文件位置</span><br><span class="line">4. &lt;package name=&quot;r&quot; /&gt; // 包路径</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-映射文件"><a href="#5-映射文件" class="headerlink" title="5. 映射文件"></a>5. 映射文件</h2><p><img src="C:\Users\97797\OneDrive\笔记\数据库\assets\image-20210408201616835.png" alt="image-20210408201616835" loading="lazy"></p><h2 id="6-动态-SQL"><a href="#6-动态-SQL" class="headerlink" title="6. 动态 SQL"></a>6. 动态 SQL</h2><p><img src="C:\Users\97797\OneDrive\笔记\数据库\assets\image-20210512103517605.png" alt="image-20210512103517605" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E5%B7%A5%E5%85%B7/Java%20%E8%AF%8A%E6%96%AD/"/>
      <url>2021/05/26/%E5%B7%A5%E5%85%B7/Java%20%E8%AF%8A%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-诊断工具（Arthas【阿尔萨斯】）"><a href="#Java-诊断工具（Arthas【阿尔萨斯】）" class="headerlink" title="Java 诊断工具（Arthas【阿尔萨斯】）"></a>Java 诊断工具（Arthas【阿尔萨斯】）</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02_JDBC</title>
      <link href="2021/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/JDBC/"/>
      <url>2021/05/26/%E6%95%B0%E6%8D%AE%E5%BA%93/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-JDBC-的本质"><a href="#1-JDBC-的本质" class="headerlink" title="1. JDBC 的本质"></a>1. JDBC 的本质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</span><br><span class="line">* JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</span><br></pre></td></tr></table></figure><h3 id="1-1-快速入门"><a href="#1-1-快速入门" class="headerlink" title="1.1 快速入门"></a>1.1 快速入门</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* 步骤：</span><br><span class="line">1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</span><br><span class="line">1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</span><br><span class="line">2.右键--&gt;Add As Library</span><br><span class="line">2. 注册驱动</span><br><span class="line">3. 获取数据库连接对象 Connection</span><br><span class="line">4. 定义sql</span><br><span class="line">5. 获取执行sql语句的对象 Statement</span><br><span class="line">6. 执行sql，接受返回结果</span><br><span class="line">7. 处理结果</span><br><span class="line">8. 释放资源</span><br><span class="line"></span><br><span class="line">* 代码实现：</span><br><span class="line">        //1.注册驱动</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        //2.获取数据库连接对象</span><br><span class="line">        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">        //3.定义sql语句</span><br><span class="line">        String sql = &quot;update account set balance = 500 where id = 1&quot;;</span><br><span class="line">        //4.获取执行sql的对象 Statement</span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line">        //5.执行sql</span><br><span class="line">        int count = stmt.executeUpdate(sql);</span><br><span class="line">        //6.处理结果</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        //7.释放资源</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br></pre></td></tr></table></figure><h3 id="1-2-详解各对象"><a href="#1-2-详解各对象" class="headerlink" title="1.2 详解各对象"></a>1.2 详解各对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">1. DriverManager：驱动管理对象</span><br><span class="line">* 功能：</span><br><span class="line">1. 注册驱动：告诉程序该使用哪一个数据库驱动jar</span><br><span class="line">static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 </span><br><span class="line">写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</span><br><span class="line"> static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException E) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</span><br><span class="line">2. 获取数据库连接：</span><br><span class="line">* 方法：static Connection getConnection(String url, String user, String password) </span><br><span class="line">* 参数：</span><br><span class="line">* url：指定连接的路径</span><br><span class="line">* 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</span><br><span class="line">* 例子：jdbc:mysql://localhost:3306/db3</span><br><span class="line">* 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</span><br><span class="line">* user：用户名</span><br><span class="line">* password：密码 </span><br><span class="line">2. Connection：数据库连接对象</span><br><span class="line">1. 功能：</span><br><span class="line">1. 获取执行sql 的对象</span><br><span class="line">* Statement createStatement()</span><br><span class="line">* PreparedStatement prepareStatement(String sql)  </span><br><span class="line">2. 管理事务：</span><br><span class="line">* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</span><br><span class="line">* 提交事务：commit() </span><br><span class="line">* 回滚事务：rollback() </span><br><span class="line">3. Statement：执行sql的对象</span><br><span class="line">1. 执行sql</span><br><span class="line">1. boolean execute(String sql) ：可以执行任意的sql 了解 </span><br><span class="line">2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</span><br><span class="line">* 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</span><br><span class="line">3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句</span><br><span class="line"></span><br><span class="line">4. ResultSet：结果集对象,封装查询结果</span><br><span class="line">* boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</span><br><span class="line">* getXxx(参数):获取数据</span><br><span class="line">* Xxx：代表数据类型   如： int getInt() ,String getString()</span><br><span class="line">* 参数：</span><br><span class="line">1. int：代表列的编号,从1开始   如： getString(1)</span><br><span class="line">2. String：代表列名称。 如： getDouble(&quot;balance&quot;)</span><br><span class="line"></span><br><span class="line">* 注意：</span><br><span class="line">* 使用步骤：</span><br><span class="line">1. 游标向下移动一行</span><br><span class="line">2. 判断是否有数据</span><br><span class="line">3. 获取数据</span><br><span class="line"></span><br><span class="line">5. PreparedStatement：执行sql的对象</span><br><span class="line">1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</span><br><span class="line">1. 输入用户随便，输入密码：a&#x27; or &#x27;a&#x27; = &#x27;a</span><br><span class="line">2. sql：select * from user where username = &#x27;fhdsjkf&#x27; and password = &#x27;a&#x27; or &#x27;a&#x27; = &#x27;a&#x27; </span><br><span class="line">2. 解决sql注入问题：使用PreparedStatement对象来解决</span><br><span class="line">3. 预编译的SQL：参数使用?作为占位符</span><br><span class="line">4. 步骤：</span><br><span class="line">4. 定义sql</span><br><span class="line">* 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</span><br><span class="line">5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </span><br><span class="line">6. 给？赋值：</span><br><span class="line">* 方法： setXxx(参数1,参数2)</span><br><span class="line">* 参数1：？的位置编号 从1 开始</span><br><span class="line">* 参数2：？的值</span><br><span class="line">5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作</span><br><span class="line">1. 可以防止SQL注入</span><br><span class="line">2. 效率更高</span><br></pre></td></tr></table></figure><h2 id="2-事务控制"><a href="#2-事务控制" class="headerlink" title="2. 事务控制"></a>2. 事务控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</span><br><span class="line">2. 操作：</span><br><span class="line">1. 开启事务</span><br><span class="line">2. 提交事务</span><br><span class="line">3. 回滚事务</span><br><span class="line">3. 使用Connection对象来管理事务</span><br><span class="line">* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</span><br><span class="line">* 在执行sql之前开启事务</span><br><span class="line">* 提交事务：commit() </span><br><span class="line">* 当所有sql都执行完提交事务</span><br><span class="line">* 回滚事务：rollback() </span><br><span class="line">* 在catch中回滚事务</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3. 数据库连接池"></a>3. 数据库连接池</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。</span><br><span class="line">    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</span><br><span class="line"></span><br><span class="line">2. 好处：</span><br><span class="line">1. 节约资源</span><br><span class="line">2. 用户访问高效</span><br><span class="line"></span><br><span class="line">3. 实现：</span><br><span class="line">1. 标准接口：DataSource   javax.sql 包下的</span><br><span class="line">1. 方法：</span><br><span class="line">* 获取连接：getConnection()</span><br><span class="line">* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</span><br><span class="line"></span><br><span class="line">2. 一般我们不去实现它，有数据库厂商来实现</span><br><span class="line">1. C3P0：数据库连接池技术</span><br><span class="line">2. Druid：数据库连接池实现技术，由阿里巴巴提供的</span><br></pre></td></tr></table></figure><h3 id="3-1-C3P0"><a href="#3-1-C3P0" class="headerlink" title="3.1 C3P0"></a>3.1 C3P0</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C3P0：数据库连接池技术</span><br><span class="line">* 步骤：</span><br><span class="line">1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</span><br><span class="line">* 不要忘记导入数据库驱动jar包</span><br><span class="line">2. 定义配置文件：</span><br><span class="line">* 名称： c3p0.properties 或者 c3p0-config.xml</span><br><span class="line">* 路径：直接将文件放在src目录下即可。</span><br><span class="line"></span><br><span class="line">3. 创建核心对象 数据库连接池对象 ComboPooledDataSource</span><br><span class="line">4. 获取连接： getConnection</span><br><span class="line">* 代码：</span><br><span class="line"> //1.创建数据库连接池对象</span><br><span class="line">        DataSource ds  = new ComboPooledDataSource();</span><br><span class="line">        //2. 获取连接对象</span><br><span class="line">        Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure><h3 id="3-2-Druid"><a href="#3-2-Druid" class="headerlink" title="3.2 Druid"></a>3.2 Druid</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Druid：数据库连接池实现技术，由阿里巴巴提供的</span><br><span class="line">1. 步骤：</span><br><span class="line">1. 导入jar包 druid-1.0.9.jar</span><br><span class="line">2. 定义配置文件：</span><br><span class="line">* 是properties形式的</span><br><span class="line">* 可以叫任意名称，可以放在任意目录下</span><br><span class="line">3. 加载配置文件。Properties</span><br><span class="line">4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</span><br><span class="line">5. 获取连接：getConnection</span><br><span class="line">* 代码：</span><br><span class="line"> //3.加载配置文件</span><br><span class="line">       Properties pro = new Properties();</span><br><span class="line">       InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);</span><br><span class="line">       pro.load(is);</span><br><span class="line">       //4.获取连接池对象</span><br><span class="line">       DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">       //5.获取连接</span><br><span class="line">       Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure><h2 id="4-Spring-JDBC"><a href="#4-Spring-JDBC" class="headerlink" title="4. Spring JDBC"></a>4. Spring JDBC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* Spring 框架对 JDBC 的简单封装。提供了一个 JDBCTemplate 对象简化 JDBC 的开发</span><br><span class="line">* 步骤：</span><br><span class="line">1. 导入 jar 包</span><br><span class="line">2. 创建 JdbcTemplate 对象。依赖于数据源 DataSource</span><br><span class="line">* JdbcTemplate template = new JdbcTemplate(ds);</span><br><span class="line"></span><br><span class="line">3. 调用 JdbcTemplat e的方法来完成 CRUD 的操作</span><br><span class="line">* update():执行 DML 语句。增、删、改语句</span><br><span class="line">* queryForMap():查询结果将结果集封装为 map 集合，将列名作为 key，将值作为 value 将这条记录封装为一个 map 集合</span><br><span class="line">* 注意：这个方法查询的结果集长度只能是1</span><br><span class="line">* queryForList():查询结果将结果集封装为 list 集合</span><br><span class="line">* 注意：将每一条记录封装为一个 Map 集合，再将 Map 集合装载到 List 集合中</span><br><span class="line">* query():查询结果，将结果封装为JavaBean对象</span><br><span class="line">* query 的参数：RowMapper</span><br><span class="line">* 一般我们使用 BeanPropertyRowMapper 实现类。可以完成数据到 JavaBean 的自动封装</span><br><span class="line">* new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</span><br><span class="line">* queryForObject：查询结果，将结果封装为对象</span><br><span class="line">* 一般用于聚合函数的查询</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>2021/05/26/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><hr><ul><li><a href="https://www.jetbrains.com/webstorm/">Webstorm</a></li><li><a href="https://code.visualstudio.com/">VS Code</a></li><li><a href="https://www.dcloud.io/index.html">HBuilder</a></li><li><a href="http://www.sublimetext.com/">sublime text3</a></li><li><a href="https://atom.io/">Atom</a></li><li><a href="https://jsbin.com/?html,output">JSBin</a>: 一种开源的协作式的web 开发调试工具。</li><li><a href="https://jsfiddle.net/">JSFiddle</a>: 编辑 JavaScript、CSS 和 HTML 并获得实时结果。使用外置资源，并和你的团队在线合作</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B1%87%E6%80%BB/"/>
      <url>2021/05/26/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><hr><ul><li><a href="http://nodejs.cn/api/">Node 中文网文档</a></li><li><a href="https://www.expressjs.com.cn/">Express</a>:基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</li><li><a href="https://koa.bootcss.com/">koa</a>: Koa – 基于 Node.js 平台的下一代 web 开发框架。</li><li><a href="https://eggjs.org/zh-cn/">Egg</a>:为企业级框架和应用而生。</li><li><a href="https://www.meteor.com/">Meteor</a>: 一个web APP开发框架。</li><li><a href="http://www.nodaljs.com/">Nodal</a>: Node.js的网络服务器，经过优化可快速高效地构建API服务。</li><li><a href="https://v3.keystonejs.com/zh">Keystone</a>: 以Express和MongoDB为基础搭建的Node.js CMS和web应用程序平台。</li><li><a href="https://imfly.gitbooks.io/sailsjs-docs-gitbook/content/cn/">Sails</a>:一个优秀的web后台开发框架。它基于著名的express，添加了很多功能模块，支持REST、各种流行数据库等。</li><li><a href="https://loopback.io/doc/zh/lb2/">Loopback</a>: LoopBack 框架是由一组Node.js的模块构成的。</li><li><a href="https://tumobi.gitbooks.io/pomelo/content/1.html">Pomelo</a>:一个轻量级的服务器框架，它最适合的应用领域是网页游戏、社交游戏、移动游戏的服务端，开发者会发现pomelo可以用如此少的代码达到强大的扩展性和伸缩性。。</li><li><a href="https://www.totaljs.com/">Totaljs</a>: Node.js 的 MVC 框架。</li><li><a href="https://derbyjs.com/">Derby</a>: DerbyJS 是一个 MVC 框架，帮助编写实时，交互的应用。</li><li><a href="https://socket.gitbook.io/docs/">Socket</a>: Socket.io是一个类库，可以在浏览器与服务器之间实现实时、双向、基于事件的通信。<a href="https://socket.io/docs/v3/server-api/index.html">英文</a></li><li><a href="https://mojito.mx/docs/home">Mojito</a>: 一个模块化的，由源代码控制的拆分测试框架，可让您通过Git / CI构建，启动和分析实验。</li><li><a href="https://docs.nestjs.cn/">Next</a>: 用于构建高效且可伸缩的服务端应用程序的渐进式 Node.js 框架。</li><li><a href="https://thinkjs.org/doc/index.html">ThinkJS</a>: 一款面向未来开发的 Node.js 框架，整合了大量的项目最佳实践，让企业级开发变得更简单、高效。</li><li><a href="http://meanjs.org/">Mean</a></li></ul><hr><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><hr><ul><li><a href="https://cn.vuejs.org/index.html">Vue2.0</a>：Vue2.0 文档</li><li><a href="https://vue3js.cn/docs/zh/guide/installation.html">Vue3.0</a>：Vue3.0 文档</li><li><a href="https://router.vuejs.org/zh/">Vue-Router</a>：Vue.js 官方的路由管理器。</li><li><a href="https://vuex.vuejs.org/zh/">Vuex</a>：Vue.js 应用程序开发的状态管理模式。</li><li><a href="https://element.eleme.io/#/zh-CN/component/installation">Element-UI</a>：饿了么UI组件库</li><li><a href="https://www.iviewui.com/docs/introduce">View UI</a>：一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。</li><li><a href="https://vuetifyjs.com/zh-Hans/getting-started/installation/">Vuetify</a>：用于构建功能丰富、快速的应用程序。</li><li><a href="https://buefy.org/">Buefy-UI</a>： 简单且轻量的UI库。</li><li><a href="http://www.quasarchs.com/">Quasar</a>: 编写代码一次并同时将其部署为网站、移动应用和/或Electron应用。</li><li><a href="http://vuematerial.materializecss.cn/#/">Vue Material</a>: 一个轻量级的框架， 建立在谷歌的 Material Design 基础上。</li><li><a href="https://doc.vux.li/zh-CN/">Vux</a>: 基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面。</li><li><a href="https://vant-contrib.gitee.io/vant/#/zh-CN/">Vant</a>: 有赞前端团队开源的移动端组件库。</li><li><a href="https://nutui.jd.com/#/index">NutUI</a>: 一套京东风格的轻量级移动端Vue组件库。</li><li><a href="http://vue.ydui.org/">YDUI Touch</a>一只基于Vue2.x的移动端&amp;微信UI。</li><li><a href="https://www.antdv.com/docs/vue/introduce-cn/">Ant Design Vue</a>: Vue UI组件库,开箱即用的高质量 Vue 组件。</li><li><a href="https://ftf.jd.com/wot-design/#/components/introduction">Wot Design</a>: 根据京东商家侧的UI设计规范（京麦移动端设计规范）开发，旨在给商家提供统一的UI交互，同时提高研发的开发效率。</li><li><a href="https://www.vuepress.cn/">VuePress</a>： Vue 驱动的静态网站生成器。</li><li><a href="https://www.gridsome.cn/">Gridsome</a>： 基于 Vue.js 构建的 Jamstack 框架。让开发人员可以轻松地构建静态生成的网站和应用程序，这些网站和应用程序 。</li><li><a href="https://better-scroll.github.io/docs/zh-CN/guide/">better-scroll</a>: 解决移动端（已支持PC）各种滚动场景需求的插件。</li><li><a href="https://vue-multiselect.js.org/#sub-getting-started">vue-multiselect</a>: Vue多选。</li><li><a href="https://github.com/ratiw/vue-table">vue-table</a>: vue-table-数据表简化！</li><li><a href="https://github.com/ElemeFE/vue-infinite-scroll">vue-infinite-scroll</a>: vue 的无限滚动插件。</li><li><a href="https://github.com/hilongjw/vue-progressbar">vue-progressbar</a>: Vue 进度条插件。</li><li><a href="https://github.com/zce/vue-devtools">vue-devtools</a>： Vue 游览器调试插件。</li></ul><h2 id="图表库"><a href="#图表库" class="headerlink" title="图表库"></a>图表库</h2><hr><ul><li><a href="https://github.com/c3js/c3">C3.js</a>: C3.js 开源图表库</li><li><a href="https://chartjs.bootcss.com/">Chart.js</a>：为设计和开发人员准备的简单、灵活的 JavaScript 图表工具。</li><li><a href="https://github.com/gionkunz/chartist-js">Chartist.js</a>: 一个简单的 JavaScript 动画库，你能够自制美丽的响应式图表，或者进行其他创作。</li><li><a href="https://d3js.org/">D3.js</a>： 一个非常强大的图形JavaScript库。D3.js可以作为图表库的构建块且免费。</li><li><a href="https://echarts.apache.org/zh/index.html">Echarts</a>： 数据可视化图表库。</li><li><a href="https://github.com/flot/flot">Flot.js</a>： jQuery的Javascript图表库。</li><li><a href="https://www.highcharts.com.cn/">HighCharts.js</a>：兼容 IE6+、完美支持移动端、图表类型丰富、方便快捷的 HTML5 交互性图表库。</li><li><a href="https://www.koolchart.com/">koolchart.js</a>：基于HTML5 Canvas的JavaScript图表库。</li><li><a href="https://github.com/recharts/recharts">Recharts</a>： Recharts是一个用React和D3构建的重新定义的图表库。</li></ul><h2 id="Css-预处理"><a href="#Css-预处理" class="headerlink" title="Css 预处理"></a>Css 预处理</h2><hr><ul><li><a href="https://www.sass.hk/">sass</a>: 世界上最成熟、最稳定、最强大的专业级CSS扩展语言。</li><li><a href="http://lesscss.cn/">less</a>: 一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</li><li><a href="https://stylus.bootcss.com/">stylus</a>： 一个高效、动态以及丰富的 CSS 预处理器。</li></ul><h2 id="动画库"><a href="#动画库" class="headerlink" title="动画库"></a>动画库</h2><hr><ul><li><a href="http://ityped.surge.sh/">iTyped.js</a>: 简单 Javascript 动画输入，没有任何依赖关系。</li><li><a href="http://www.webgl3d.cn/">Three.js</a>: 3D显示动画库。</li><li><a href="https://www.animejs.cn/">Animejs</a>:一个轻量的JavaScript 动画库， 拥有简单而强大的API。可对 CSS 属性、 SVG、 DOM 和JavaScript 对象进行动画。</li><li><a href="https://github.com/mojs/mojs">Mo.js</a>： 一款效果非常炫酷的HTML5 SVG气泡导航和波浪式页面切换特效。</li><li><a href="http://shouce.jb51.net/velocity/">Velocity.js</a>：一个简单易用、高性能、功能丰富的轻量级JS动画库。</li><li><a href="https://scrollrevealjs.org/">ScrollReveal.js</a>： 一个JavaScript库，用于在元素进入/离开视口时轻松对其进行动画处理。</li><li><a href="https://github.com/thednp/kute.js/">Kute.js</a>： 一个完全成熟的原生 JavaScript 动画引擎，具有跨浏览器动画的基本功能。</li><li><a href="http://bouncejs.com/">Bounce.js</a>:快速创建漂亮的 CSS3 动画效果。</li><li><a href="http://dynamicsjs.com/">Dynamicsjs</a>: 一个JavaScript库，用于创建基于物理的动画。</li><li><a href="https://greensock.com/gsap/">GreenSock.js)</a>:适用于现代网络的专业级JavaScript动画。</li><li><a href="https://vincentgarreau.com/particles.js/">Particles.js</a>:用于创建粒子的轻量级JavaScript库。</li><li><a href="https://brm.io/matter-js/">Matter.js</a>:Matter.js是Web的2D物理引擎。</li><li><a href="http://matthew.wagerfield.com/parallax/">Parallax.js</a>:滚动视差效果封装，便于快速调用实现。</li><li><a href="https://github.com/tweenjs/tween.js">Tween.js</a>: 补间动画。</li><li><a href="http://www.rich-harris.co.uk/ramjet/">Ramjet.js</a>： 制作从一个元素变化为另外一个元素的动效，它能作用于DOM元素、SVG、静态和动态的图片。</li><li><a href="https://dixonandmoe.com/rellax/">Rellax.js</a>:让页面滚动更有趣的动画库。</li><li><a href="https://github.com/IanLunn/Hover">Hover.css</a>： 一组CSS3动力悬停效果，可应用于链接，按钮，徽标，SVG，特色图像等。</li><li><a href="https://animista.net/">Animista.css</a>： 一个在线动画生成器，同时也是一个动画库。</li><li><a href="https://animate.style/">Animate.css</a>：一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果。</li><li><a href="http://vivify.mkcreative.cz/">Vivify.css</a>：一个免费的CSS动画库。</li><li><a href="https://www.minimamente.com/project/magic/">Magic Animations CSS3</a>：CSS3 动画库。</li><li><a href="http://cssanimation.io/index.html">cssanimation</a>：一堆不同动画集合，CSS3 动画包。</li><li><a href="https://angrytools.com/css/animation/">Angrytools</a>: 可以做动画生成器，同时也是一个动画库。</li></ul><h2 id="Js插件"><a href="#Js插件" class="headerlink" title="Js插件"></a>Js插件</h2><hr><ul><li><a href="https://www.swiper.com.cn/">Swiper.js</a>：移动端网站的内容触摸滑动插件。</li><li><a href="https://glidejs.com/">Glide.js</a>： 一个无依赖关系的JavaScript ES6滑块和carousel。</li><li><a href="http://code.ciaoca.com/javascript/qrcode/demo/">QRCode.js</a>: 二维码生成插件。</li><li><a href="https://github.com/lipten/slidePage">slidePage.js</a>： slidePage3 特别适合主流前端框架开发，无任何依赖库，一个优化的全屏插件。</li><li><a href="http://fullpage.81hu.com/">fullPage.js</a>： fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站。</li><li><a href="https://validatejs.org/">Validate.js</a>: JavaScript表单验证类库。</li><li><a href="https://www.jq22.com/jquery-info21370">tree-d3.js</a>： tree 树状图 d3.js。</li><li><a href="http://www.treejs.cn/v3/demo.php#_602">zTree.js</a>: 树插件。</li><li><a href="https://www.jstree.com/demo/">jstree</a>: jquery插件，提供交互式树。支持HTML和JSON数据源以及AJAX加载。</li><li><a href="https://datatables.club/">Datatables.js</a>：一个高度灵活的工具，可以将任何HTML表格添加高级的交互功能。</li><li><a href="http://www.eyecon.ro/datepicker/">DatePicker.js</a>: 时间选择插件。</li><li><a href="https://www.layui.com/laydate/">layDate.js</a>: layDate 日期与时间组件。</li><li><a href="https://github.com/datejs/Datejs">Date.js</a>: 一个开放源代码的JavaScript Date库，用于解析，格式化和处理。</li><li><a href="http://www.clipboardjs.cn/">clipboard.js</a>:现代化的拷贝文字插件。</li><li><a href="https://github.com/mozilla/pdf.js/">PDF.js</a>: 一个基于 web 标准的通用 pdf 解析和渲染库。</li><li><a href="https://github.com/jquery-i18n-properties/jquery-i18n-properties">jquery-i18n</a>: 一个轻量级的jQuery插件，用于像Java Resource Bundles中那样从“ .properties”文件为javascript提供国际化。</li><li><a href="https://github.com/i18next/i18next">i18next</a></li><li><a href="https://timeline.knightlab.com/#make">TimelineJS</a>: 时间轴插件。</li><li><a href="https://github.com/amfe/lib-flexible">amfe-flexible</a>： 移动端适配。</li><li><a href="https://www.lazyloadjs.cn/">lazyLoad.js</a>：Lazy Load延迟加载图像插件，直到用户滚动到它们才显示！</li><li><a href="http://spin.js.org/">spin.js</a>: Loading界面插件。</li><li><a href="https://codemirror.net/">CodeMirror.js</a>: 文本编辑器。</li><li><a href="https://www.tiny.cloud/get-tiny/">TinyMCE.js</a> :文本编辑器。</li><li><a href="https://github.com/videojs/video.js">Video.js</a>: 一个通用的在网页上嵌入视频播放器的 JS 库，Video.js 自动检测浏览器对 HTML5 的支持情况,如果不支持 HTML5 则自动使用 Flash 播放器。</li><li><a href="https://sweetalert.bootcss.com/">SweetAlert.js</a>: 一个 JavaScript 插件，能够完美替代 JavaScript 自带的 alert 弹出框，并且功能强大、设计优美。</li><li><a href="http://www.photoswipe.com/">PhotoSwipe.js</a>: 一个 JavaScript 实现的相册组件，没有外部依赖。</li><li><a href="https://github.com/highlightjs/highlight.js">highlight.js</a>: 用JavaScript编写的语法突出显示工具。</li><li><a href="https://github.com/fengyuanchen/photo-editor">Cropper.js</a>: 一款非常强大却又简单的图片裁剪工具,它可以进行非常灵活的配置,支持手机端使用,支持包括 IE9 以上的现代浏览器。</li><li><a href="https://github.com/marcuswestin/store.js/">Store.js</a>: 跨浏览器存储插件。</li><li><a href="https://github.com/js-cookie/js-cookie">Js-cookie</a>: 一个简单，轻巧的JavaScript API，用于处理Cookie.</li><li><a href="https://github.com/ccampbell/mousetrap">Mousetrap.js</a>: 一个用于处理键盘快捷键的简单库。</li><li><a href="https://www.jq22.com/jquery-info14029">FlexSlider.js</a>: 全屏响应式轮播图插件。</li><li><a href="https://leafletjs.com/">Leaflet.js</a>: 一个开放源代码的JavaScript库，用于移动友好的交互式地图。</li></ul><h2 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h2><hr><ul><li><a href="https://www.jquery123.com/">jQuery</a>: 一个高效、精简并且功能丰富的 JavaScript 工具库。</li><li><a href="https://www.runoob.com/manual/zeptojs.html">Zepto.js</a>: 一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。</li><li><a href="http://momentjs.cn/">Moment.js</a>: JavaScript 日期处理类库。</li><li><a href="https://date-fns.org/">date-fns.js</a>: 一个现代的 JavaScript 日期工具类库，提供了最全面、最简单和一致的工具集，用于在浏览器和 Node.js 中操作。</li><li><a href="https://underscorejs.net/">Underscore.js</a>：是一个JavaScript实用库，提供了一整套函数式编程的实用功能。</li><li><a href="https://sugarjs.com/">Sugar.js</a>: 一个可以用来处理原生对象的库。</li><li><a href="https://mathjs.org/">Math.js</a>: Javascript 扩展数学库。</li><li><a href="https://www.lodashjs.com/">Lodash.js</a>:一个一致性、模块化、高性能的 JavaScript 实用工具库。</li><li><a href="https://xinyufeng.net/cnhammerjs/getting-started/">cnhammer.js</a>: 一个可以识别触摸、鼠标和点击事件等手势的开放源码类库。</li><li><a href="https://ramda.cn/">Ramda.js</a>:一款实用的 JavaScript 函数式编程库。</li><li><a href="http://axios-js.com/zh-cn/docs/index.html">Axios.js</a>:一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</li><li><a href="https://github.com/dtao/lazy.js">lazy.js</a>: 功能类似 Underscore 和 Lodash。</li><li><a href="https://vocajs.com/">Voca.js</a>: 一个用于操作字符串的 Javascript 库。</li><li><a href="https://www.babeljs.cn/">Babel.js</a>: 一个 JavaScript 编译器。</li><li><a href="http://101.132.137.99/">RequireJS</a>： 一个JavaScript模块加载器。</li><li><a href="https://cn.rx.js.org/">RxJS</a>: 使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。</li><li><a href="https://www.zhangxinxu.com/sp/seajs/">sea.js</a>： 一个适用于 Web 浏览器端的模块加载器。</li><li><a href="http://caibaojian.com/backbone/">Backbone.js</a>: 为复杂Javascript应用程序提供模型(models)、集合(collections)、视图(views)的结构。<a href="https://backbonejs.org/">英文</a></li><li><a href="https://revealjs.com/#/">reveal.js</a>: 一个能够帮助我们很轻易地使用 HTML 创建一个漂亮的演示文稿的框架。</li><li><a href="http://cyclejs.cn/">Cycle.js</a>: 一个函数式和响应式的 JavaScript 框架，编写可观测代码。</li><li><a href="https://github.com/systemjs/systemjs">system.js</a>:一个通用的模块加载器，它能在浏览器或者 NodeJS 上动态加载模块，并且支持 CommonJS、AMD、全局模块对象和 ES6 模块。</li><li><a href="https://efe.baidu.com/blog/esl-2.0/">ESL.js</a>：一个浏览器端、符合AMD的标准加载器，适合用于现代Web浏览器端应用的入口与模块管理。</li><li><a href="https://github.com/Automattic/expect.js/">expect.js</a>: 简约的、适用于 Node.js 和浏览器端的 BDD 式断言工具。</li><li><a href="https://github.com/canjs/canjs">can.js</a>: 客户端JavaScript架构库的集合。</li><li><a href="https://github.com/cujojs/most">most.js</a>: 用于反应式编程的工具包。</li><li><a href="https://github.com/zurb/foundation-sites.git">foundation.js</a>: 一个支持响应式布局的前端框架。</li><li><a href="https://semantic-ui.com/">Semantic.js</a>: 一款开发框架，帮助开发者使用对人类友好的 HTML 语言构建优雅的响应式布局。</li><li><a href="https://bulma.io/">Bulma</a>: 一个基于 Flexbox 布局技术的免费、开源的现代 CSS 框架。</li><li><a href="https://github.com/photonstorm/phaser">Phaser.js</a>: 一款快速、免费以及开源 HTML5 游戏框架，它支持 WebGL 和 Canvas 两种渲染模式，可以在任何 Web 浏览器环境下运行，游戏可以通过第三方工具转为 iOS、Android 支持的 Native APP，允许使用 JavaScript 和 TypeScript 进行开发。</li><li><a href="https://github.com/octokit/request.js/">Request.js</a>: 针对浏览器和节点的请求库。</li><li><a href="https://github.com/hammerjs/hammer.js">Hammer.js</a>: 一个开源的,轻量级的 JavaScript 库,它可以在不需要依赖其他东西的情况下识别触摸,鼠标事件。</li><li><a href="https://github.com/emberjs/ember.js">Ember.js</a>: 一个开源的 JavaScript 客户端框架，用于开发Web应用程序并使用MVC（模型 - 视图 - 控制器）架构模式。</li><li><a href="https://www.handlebarsjs.cn/">handlebars.js</a>: 一个 JavaScript 语义模板库，通过对视图（view）和数据的分离来快速构建 Web 模板。</li><li><a href="https://github.com/jquery/jquery-ui">jqueryui</a>: jQuery UI 是建立在 jQuery JavaScript 库上的一组用户界面交互、特效、小部件及主题。</li><li><a href="https://github.com/jquery/sizzle">Sizzle.js</a>: 一个纯 JavaScript 实现的 CSS 选择器引擎。</li><li><a href="https://github.com/RubyLouvre/avalon">Avalon.js</a>: 一个迷你、易用、高性能的前端MVVM框架。</li><li><a href="https://github.com/jprichardson/string.js">String.js</a>: JavaScript字符串中没有包含的方法，例如转义html、解码html实体、剥离标记等。</li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><hr><ul><li><a href="https://www.tslang.cn/">typeScript文档</a>： JavaScript 类型超集，可以编译成纯JavaScript 。</li></ul><h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><hr><ul><li><a href="https://www.npmjs.cn/">npm</a>: 包管理工具。</li><li><a href="https://yarn.bootcss.com/">yarn</a>: 快速、可靠、安全的依赖管理工具。</li><li><a href="https://blog.lsqy.space/2016/05/03/160503Bower%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/">bower</a></li></ul><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><hr><ul><li><a href="https://www.gulpjs.com.cn/">gulp</a>: 用自动化构建工具增强你的工作流程。</li><li><a href="https://www.webpackjs.com/">webpack</a>: 一个现代 JavaScript 应用程序的静态模块打包器。</li><li><a href="https://www.gruntjs.net/">grunt</a>: 基于 Node.js 的项目构建工具。</li><li><a href="https://zh.parceljs.org/getting_started.html">Parcel</a>: Web 应用打包工具，适用于经验不同的开发者。</li><li><a href="https://www.rollupjs.com/">rollup</a>: 一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码。</li></ul><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><hr><ul><li><a href="https://cn.eslint.org/">eslint</a>： 可组装的JavaScript和JSX检查工具。</li><li><a href="https://jestjs.io/zh-Hans/">Jest</a>： 一个令人愉快的 JavaScript 测试框架，专注于简洁明快。</li><li><a href="https://mochajs.cn/">mocha</a>： 一个功能丰富的javascript测试框架，运行在node.js和浏览器中，使异步测试变得简单有趣。</li><li><a href="https://jshint.com/docs/">JSHint</a>: 用于标记用JavaScript编写的程序中的可疑用法。</li><li><a href="https://github.com/jscs-dev/node-jscs">JScs.js</a>: 验证JavaScript代码。</li></ul><h2 id="Api-查询"><a href="#Api-查询" class="headerlink" title="Api 查询"></a>Api 查询</h2><ul><li><a href="https://https//overapi.com/.com/">overapi</a></li><li><a href="https://www.javascripting.com/">javascripting</a></li><li><a href="https://tool.oschina.net/apidocs">开源中国在线API文档合集</a></li><li><a href="https://www.runoob.com/">菜鸟教程</a></li><li><a href="http://devdocs.io/">devdocs</a>: 英文文档</li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><hr><ul><li><a href="https://zh-hans.reactjs.org/">React入门文档</a>: 用于构建用户界面的 JavaScript 库。</li><li><a href="https://react-guide.github.io/react-router-cn/">React-router</a>: React路由。</li><li><a href="https://www.redux.org.cn/">React-Redux</a>: React 状态容器。</li><li><a href="https://ant.design/index-cn">Ant Design React</a>: 阿里巴巴团队出品的ReactUI组件库。</li><li><a href="https://material-ui.com/zh/">Material-UI</a>: React 组件用于更快速、更简便的 web 开发。</li><li><a href="http://react.tgwoo.com/">React-Bootstrap</a>: 可重用的前端组件库。</li><li><a href="https://mobile.ant.design/index-cn">Ant Design Mobile</a>: 一个基于 Preact / React / React Native 的 UI 组件库（移动端）。</li><li><a href="http://ui.baifendian.com/">BFD UI</a>: BFD UI —— 企业级 React 组件库。</li><li><a href="https://reactnative.cn/">React Native</a>: 使用JavaScript和React编写原生移动应用。</li><li><a href="http://react-toolbox.io/">React-toolbox</a>： 一组实现Google的Material Design规范的React组件。</li><li><a href="https://bizcharts.net/">BizCharts</a>: 阿里通用图表组件库。</li><li><a href="https://github.com/dvajs/dva/blob/master/README_zh-CN.md">dva</a>: 基于 redux、redux-saga 和 react-router 的轻量级前端框架。</li><li><a href="https://github.com/react-cropper/react-cropper">react-cropper</a>: React图像裁剪器。</li><li><a href="https://github.com/twobin/react-lazyload">react-lazyload</a>： React 懒加载组件（组件、图片等）。</li><li><a href="https://github.com/chenglou/react-treeview">react-treeview</a>： React实现的简单、轻量级、灵活的树视图。</li><li><a href="https://github.com/chenglou/react-motion">react-motion</a>： React 弹性动画库。</li><li><a href="https://github.com/CookPete/react-player">react-player</a>：用于播放各种url，包括文件路径、YouTube、Facebook、Twitch、SoundCloud、Streamable、Vimeo、Wistia、Mixcloud和DailyMotion。</li><li><a href="https://github.com/casesandberg/react-color">react-color</a>： 颜色选择器。</li><li><a href="https://github.com/zenoamaro/react-quill">react-quill</a>： React 富文本编辑器。</li><li><a href="https://github.com/Hacker0x01/react-datepicker">react-datepicker</a>： React 日期选择组件。</li><li><a href="https://github.com/fisshy/react-scroll">react-scroll</a>： React 滚动组件。</li><li><a href="https://github.com/voronianski/react-swipe">react-swipe</a>： React 轮播组件。</li><li><a href="https://github.com/reduxjs/redux-devtools">redux-devtools</a>： react 游览器调试插件。</li><li><a href="http://react-china.org/">React 社区</a></li></ul><h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><hr><ul><li><a href="https://angular.cn/docs">Angular文档</a>： 一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用。</li><li><a href="https://ng.ant.design/docs/introduce/zh">Ant Design Angular</a>: Ant Design 设计规范的 Angular UI 组件库。</li><li><a href="https://devui.design/home">DevUI</a>: 一款开源免费的企业中后台产品前端的通用解决方案。</li><li><a href="https://ngnest.com/index/docs/zh_CN/ng-nest">NG-NEST</a>： 一个开源的 Web 应用程序框架，基于 Angular 和 Nest ，主要用于研发企业级中后台产品。</li><li><a href="https://ng.mobile.ant.design/#/docs/introduce/zh">Ant Design Mobile Angular</a>： Ant Design 设计规范的 Angular UI 组件库(移动端)。</li><li><a href="https://material.angular.cn/">Angular Material</a>: 使用横跨 Web、Mobile 和桌面环境的综合性组件库构建现代应用。</li><li><a href="https://www.bootcdn.cn/angular-animate/">Angular-animate</a>:</li><li><a href="https://www.ituring.com.cn/book/1206">AngularJS入门教程</a></li></ul><h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><hr><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信小程序文档</a></li><li><a href="http://www.wetouch.net/touchwx_doc/">TouchUI WX</a>: 一套完全免费的微信小程序开发框架，扩展了小程序的能力。</li><li><a href="https://wepyjs.github.io/wepy-docs/">WePY</a>:让小程序支持组件化开发的框架,一个最受欢迎的小程序框架.</li><li><a href="https://github.com/Meituan-Dianping/mpvue">mpvue</a>:一个使用 Vue.js 开发小程序的前端框架。</li><li><a href="http://taro-docs.jd.com/taro/docs/README/index.html">taro</a>: 一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ 小程序 / H5 等应用。</li><li><a href="https://uniapp.dcloud.io/">uni-app</a>: 一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。</li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><hr><ul><li><a href="https://flutterchina.club/get-started/install/">Flutter 文档</a>： Google一个新的用于构建跨平台的手机App的SDK。</li><li><a href="https://flutterchina.club/">Flutter中文网﻿</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot CORS</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-30-17_Spring-Boot-CORS/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-30-17_Spring-Boot-CORS/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-CORS"><a href="#Spring-Boot-CORS" class="headerlink" title="Spring Boot CORS"></a>Spring Boot CORS</h2><p>HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130201709189.png" alt="image-20210130201709189" loading="lazy"></p><h3 id="使用-ajax-模拟跨域"><a href="#使用-ajax-模拟跨域" class="headerlink" title="使用 ajax 模拟跨域"></a>使用 ajax 模拟跨域</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">跨域测试</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8080/usr?id=1&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">dataType</span>: <span class="string">&quot;application/json&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(data)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注册实现跨域"><a href="#注册实现跨域" class="headerlink" title="注册实现跨域"></a>注册实现跨域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ORCSConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">//允许所有请求跨域</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>) <span class="comment">//支持GET方法</span></span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>); <span class="comment">//不限定域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130204958443.png" alt="image-20210130204958443" loading="lazy"></p><h3 id="注解实现跨域"><a href="#注解实现跨域" class="headerlink" title="注解实现跨域"></a>注解实现跨域</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130205419510.png" alt="image-20210130205419510" loading="lazy"></p><table><thead><tr><th align="left">属性</th><th>含义</th></tr></thead><tbody><tr><td align="left">value</td><td>指定所支持域的集合，<code>*  </code> 表示所有域都支持，默认值为 <code>*</code>。这些值对应HTTP请求头中的<code>Access-Control-Allow-Origin </code></td></tr><tr><td align="left">origins</td><td>同 value</td></tr><tr><td align="left">allowedHeaders</td><td>允许请求头中的 header，默认都支持</td></tr><tr><td align="left">exposedHeaders</td><td>响应头中允许访问的 header，默认为空</td></tr><tr><td align="left">methods</td><td>支持请求的方法，比如 <code>GET</code>，<code>POST</code>，<code>PUT</code> 等，默认和 Controller 中的方法上标注的一致。</td></tr><tr><td align="left">allowCredentials</td><td>是否允许 cookie 随请求发送，使用时必须指定具体的域</td></tr><tr><td align="left">maxAge</td><td>预请求的结果的有效期，默认 30 分钟</td></tr></tbody></table><h3 id="过滤器实现"><a href="#过滤器实现" class="headerlink" title="过滤器实现"></a>过滤器实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">    bean.setOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot WebSocket</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-31-18_Spring-Boot-WebSocket/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-31-18_Spring-Boot-WebSocket/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-WebSocket"><a href="#Spring-Boot-WebSocket" class="headerlink" title="Spring Boot WebSocket"></a>Spring Boot WebSocket</h2><p>利用 WebSocket，实现简单的客户端与服务端建立长连接并互发送文本消息</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>继承 WebSocketHandler 的实现类，并重写四个其中的方法</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210131015817511.png" alt="image-20210131015817511" loading="lazy"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.CloseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.handler.TextWebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketInterceptor</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//和客户端链接成功的时候触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;建立连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//和客户端连接失败的时候触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.close(CloseStatus.SERVER_ERROR);</span><br><span class="line">        System.out.println(<span class="string">&quot;出现错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//和客户端断开连接的时候触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterConnectionClosed(session, status);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//和客户端建立连接后，处理客户端发送的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到客户端发送过来的消息</span></span><br><span class="line">        String messagePayload = message.getPayload();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户：&quot;</span>+session.getId()+<span class="string">&quot;  &quot;</span>+messagePayload);</span><br><span class="line">        String getMessages = getMessage();</span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> TextMessage(getMessages));</span><br><span class="line">        System.out.println(<span class="string">&quot;已发送给客户端&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String messages = scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span>(messages==<span class="keyword">null</span> || messages==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请重新输入：&quot;</span>);</span><br><span class="line">            getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//开启WebSocket</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebSocketInterceptor webSocketInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端通过路径 /websocket 和服务端连接通信时，会使用 webSocketInterceptor 来处理会话</span></span><br><span class="line">        <span class="comment">//通信的客户端是通过 SockJS 实现的</span></span><br><span class="line">        registry.addHandler(webSocketInterceptor,<span class="string">&quot;/websocket&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>有关 SockJs 详情，请点击 <a href="https://github.com/sockjs/sockjs-client">这里 </a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebSocket客户端<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/sockjs-client/0.3.4/sockjs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/4.4.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.jumbotron</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#text</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">3rem</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">line-height</span>: <span class="number">3rem</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#connect</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-left</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#log</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;jumbotron&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入你想传输的内容&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-12&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;连接&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-info&quot;</span> <span class="attr">id</span>=<span class="string">&quot;connect&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;connect()&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发送&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sent&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;sent()&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;断开&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span> <span class="attr">id</span>=<span class="string">&quot;disconnect&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">onclick</span>=<span class="string">&quot;disconnect()&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>聊天记录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> text = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#text&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> connectBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#connect&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> sentBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#sent&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> disconnectBtn = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#disconnect&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> logDiv = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#log&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ws = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> targetUri = <span class="string">&quot;/websocket&quot;</span>;</span></span><br><span class="line"><span class="javascript">        ws = <span class="keyword">new</span> SockJS(targetUri);</span></span><br><span class="line"><span class="javascript">        ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            setConnected(<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            log(<span class="string">&#x27;和服务端连接成功！&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            log(<span class="string">&#x27;服务端说：&#x27;</span> + event.data);</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            setConnected(<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">            log(<span class="string">&#x27;和服务端断开连接！&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">sent</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (ws != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">            ws.send(text.value);</span></span><br><span class="line"><span class="javascript">            log(<span class="string">&#x27;客户端说：&#x27;</span> + text.value);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            log(<span class="string">&#x27;请先建立连接！&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">disconnect</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (ws != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">            ws.close();</span></span><br><span class="line"><span class="javascript">            ws = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        setConnected(<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> content = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        content.innerHTML = value;</span></span><br><span class="line"><span class="javascript">        logDiv.appendChild(content);</span></span><br><span class="line"><span class="javascript">        text.value = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">setConnected</span>(<span class="params">connected</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        connectBtn.disabled = connected;</span></span><br><span class="line"><span class="javascript">        disconnectBtn.disabled = !connected;</span></span><br><span class="line"><span class="javascript">        sentBtn.disabled = !connected;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210131015259618.png" alt="image-20210131015259618" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210131015317161.png" alt="image-20210131015317161" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/XML%20%E7%BA%A6%E6%9D%9F/Mybatis/"/>
      <url>2021/05/26/XML%20%E7%BA%A6%E6%9D%9F/Mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="Configuraion"><a href="#Configuraion" class="headerlink" title="Configuraion"></a>Configuraion</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打印 SQL 语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用驼峰命名法转换字段。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;NULL&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/XML%20%E7%BA%A6%E6%9D%9F/spring/"/>
      <url>2021/05/26/XML%20%E7%BA%A6%E6%9D%9F/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Async</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-30-16_Spring-Boot-Async/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-30-16_Spring-Boot-Async/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-Async"><a href="#Spring-Boot-Async" class="headerlink" title="Spring Boot Async"></a>Spring Boot Async</h2><p>通常我们的程序都是同步的，但有时候也会使用异步的方式，来提高程序的效率。</p><h3 id="开启异步"><a href="#开启异步" class="headerlink" title="开启异步"></a>开启异步</h3><p>在启动类上添加 <code>@EnableAsync</code> 注解来开启异步</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130183820379.png" alt="image-20210130183820379" loading="lazy"></p><h3 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h3><p>使用 <code>@Async</code> 注解来标明此方法是异步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;异步线程：开始&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;异步线程：&quot;</span> + <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;异步线程：结束&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;异步线程耗时：&quot;</span>+(end-start)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130184050140.png" alt="image-20210130184050140" loading="lazy"></p><p>从结果上可以看到，它和平时的执行顺序不一样，异步方法是另起一个线程来执行的</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130184234595.png" alt="image-20210130184234595" loading="lazy"></p><h3 id="接受异步的返回结果"><a href="#接受异步的返回结果" class="headerlink" title="接受异步的返回结果"></a>接受异步的返回结果</h3><h5 id="修改异步方法"><a href="#修改异步方法" class="headerlink" title="修改异步方法"></a>修改异步方法</h5><p>给异步方法添加返回值，用 AsyncResult&lt;&gt; 来返回我们的结果，用 Future<String> 来接受结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程：开始&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程：&quot;</span> + <span class="keyword">this</span>.getClass().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程：结束&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;异步线程耗时：&quot;</span>+(end-start)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">&quot;异步方法执行完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130185952801.png" alt="image-20210130185952801" loading="lazy"></p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p><img src="G:\images\image-20210130190254776.png" alt="image-20210130190254776" loading="lazy"></p><p>同步方法并没有一次性执行完，而是在 <code>future.get()</code> 这里处于阻塞状态，等待异步执行完毕后返回的结果</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130190420374.png" alt="image-20210130190420374" loading="lazy"></p><h3 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">asyncThreadPoolTaskExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//线程池核心线程的数量，默认值为1（这就是默认情况下的异步线程池配置使得线程不能被重用的原因）</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//线程池维护的线程的最大数量，只有当核心线程都被用完并且缓冲队列满后，才会开始申超过请核心线程数的线程，默认值为Integer.MAX_VALUE。</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//缓冲队列。</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        <span class="comment">//超出核心线程数外的线程在空闲时候的最大存活时间，默认为60秒。</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">//线程名前缀。</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;asyncThread&quot;</span>);</span><br><span class="line">        <span class="comment">//是否等待所有线程执行完毕才关闭线程池，默认值为false。</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//waitForTasksToCompleteOnShutdown的等待的时长，默认值为0，即不等待</span></span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当没有线程可以被使用时的处理策略（拒绝任务），默认策略为abortPolicy</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130193657121.png" alt="image-20210130193657121" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">discardOldestPolicy：当线程池中的数量等于最大线程数时、抛弃线程池中最后一个要执行的任务，并执行新传入的任务。</span><br><span class="line">abortPolicy：直接抛出java.util.concurrent.RejectedExecutionException异常。</span><br><span class="line">callerRunsPolicy：用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</span><br><span class="line">discardPolicy：当线程池中的数量等于最大线程数时，不做任何动作。</span><br></pre></td></tr></table></figure><p>使用自定义线程池时，只需在注解 <code>@Async</code> 的 Value 属性中添加线程池的 Bean name</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130194544356.png" alt="image-20210130194544356" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210130194523295.png" alt="image-20210130194523295" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 监控 Actuator</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-28-11_Spring-Boot-%E7%9B%91%E6%8E%A7-Actuator/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-28-11_Spring-Boot-%E7%9B%91%E6%8E%A7-Actuator/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-监控-Actuator"><a href="#Spring-Boot-监控-Actuator" class="headerlink" title="Spring Boot 监控 Actuator"></a>Spring Boot 监控 Actuator</h2><p>Spring Boot 遵循着“约定大于配置”的原则，许多功能不用配置即可使用，这是因为 Spring Boot 把约定的配置已经配置好了。好处在于我们不需要像使用 Spring 那样编写一大堆的配置文件，但过于简单的配置过程会让我们在了解各种依赖，配置之间的关系过程上带来一些困难。在 Spring Boot中，提供了 Actuator 监控，Actuator 提供了 RESTful API 让我们可以更为方便的了解配置信息。</p><p> Spring Boot 2.0.1.RELEASE Actuator  <a href="https://www.cnblogs.com/powerwu/articles/9553333.html">中文文档</a></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Applicaiton-yml-配置-Actuator"><a href="#Applicaiton-yml-配置-Actuator" class="headerlink" title="Applicaiton.yml 配置 Actuator"></a>Applicaiton.yml 配置 Actuator</h3><p>web 请求默认只暴露两个端点，查看全部端点可访问 <a href="https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/html/production-ready-endpoints.html">官网</a></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128004346954.png" loading="lazy"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span>  <span class="comment">#端口</span></span><br><span class="line">    <span class="attr">base-path:</span> <span class="string">/manager</span>  <span class="comment">#请求路径</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">          <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>  <span class="comment">#暴露全部端点,也可以有选择性的暴露端点  </span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>访问 <a href="http://localhost/manager/actuator">http://localhost/manager/actuator</a> 查看暴露的端点，截取一部分</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128004542614.png" alt="image-20210128004542614" loading="lazy"></p><p>访问 <a href="http://localhost/manager/actuator/mappings">http://localhost/manager/actuator/mappings</a> 查看 Mapping，截取一部分</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128004734994.png" alt="image-20210128004734994" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Devtools 热部署</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-28-12_Spring%20Boot%20Devtools%20%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-28-12_Spring%20Boot%20Devtools%20%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-Devtool-热部署"><a href="#Spring-Boot-Devtool-热部署" class="headerlink" title="Spring Boot Devtool 热部署"></a>Spring Boot Devtool 热部署</h2><p>热部署就是在修改了代码后不需要手动重启，工具会帮你快速的自动重启是修改生效。深层原理是使用了两个 <code>ClassLoader</code>，一个 <code>Classloader</code> 加载那些不会改变的类（第三方Jar包），另一个 <code>ClassLoader</code> 加载会更改的类，称为 <code>restart ClassLoader</code>，这样在有代码更改的时候，原来的 <code>restart ClassLoader</code> 被丢弃，重新创建一个 <code>restart ClassLoader</code>，由于需要加载的类相比较少，从而实现了较快的重启。<a href="!%5B%5D(https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128021026864.png)">官网</a></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span>            </span><br></pre></td></tr></table></figure><h3 id="修改-IDEA-设置"><a href="#修改-IDEA-设置" class="headerlink" title="修改 IDEA 设置"></a>修改 IDEA 设置</h3><p>切换 IDEA 界面到其他应用（浏览器）之后自动部署</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128020146593.png" alt="image-20210128020146593" loading="lazy"></p><p>快捷键 <code>CTRL + SHFT + ALT + / </code>  选择 <code>Registry</code>。可以按你自己按的字母搜索</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128020525075.png" alt="image-20210128020525075" loading="lazy"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动应用——修改代码——切换到其他应用——查看结果</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128021026864.png" alt="image-20210128021026864" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 发送邮件</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-28-13_Spring%20Boot%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-28-13_Spring%20Boot%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-发送邮件"><a href="#Spring-Boot-发送邮件" class="headerlink" title="Spring Boot 发送邮件"></a>Spring Boot 发送邮件</h2><p>在 Spring Boot 中发送邮件使用的是 Spring 提供的 <code>org.springframework.mail.javamail.JavaMailSender</code>，其提供了许多简单易用的方法，可发送简单的邮件、HTML 格式的邮件、带附件的邮件，并且可以创建邮件模板。<a href="https://docs.spring.io/spring-framework/docs/4.3.18.RELEASE/spring-framework-reference/htmlsingle/#mail">官方说明</a></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>l</span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml-中邮件的配置"><a href="#application-yml-中邮件的配置" class="headerlink" title="application.yml 中邮件的配置"></a>application.yml 中邮件的配置</h3><p>以网易的 163 邮箱为例</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line">    <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">邮箱</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">校验码</span>  <span class="comment">#在邮箱的设置中开启 POP3/SMTP 服务时，会有一个检验码，只显示一次</span></span><br><span class="line">        <span class="attr">default-encoding:</span> <span class="string">utf-8</span></span><br><span class="line">        <span class="attr">properties:</span></span><br><span class="line">          <span class="attr">mail:</span></span><br><span class="line">            <span class="attr">smtp:</span></span><br><span class="line">              <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">              <span class="attr">starttls:</span></span><br><span class="line">                <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">                <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128033917747.png" alt="image-20210128033917747" loading="lazy"></p><h3 id="创建服务请求"><a href="#创建服务请求" class="headerlink" title="创建服务请求"></a>创建服务请求</h3><h4 id="发送简单的邮件"><a href="#发送简单的邮件" class="headerlink" title="发送简单的邮件"></a>发送简单的邮件</h4><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128202755585.png" alt="image-20210128202755585" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128033800389.png" alt="image-20210128033800389" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128033834976.png" alt="image-20210128033834976" loading="lazy"></p><h4 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h4><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128203350615.png" alt="image-20210128203350615" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128040413240.png" alt="image-20210128040413240" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128040449253.png" alt="image-20210128040449253" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128041032075.png" alt="image-20210128041032075" loading="lazy"></p><h3 id="发送带验证码的邮件"><a href="#发送带验证码的邮件" class="headerlink" title="发送带验证码的邮件"></a>发送带验证码的邮件</h3><p>在发送验证码等情况下可以创建一个邮件的模板，唯一的变量为验证码。使用的模板解析引擎为 Thymeleaf。</p><h5 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">您好，您的验证码为<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;code&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>，请在两分钟内使用完成操作。</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128205310045.png" alt="image-20210128205310045" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128042245633.png" alt="image-20210128042245633" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210128194246726.png" alt="image-20210128194246726" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 异常处理</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-29-14_Spring-Boot-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-29-14_Spring-Boot-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-异常处理"><a href="#Spring-Boot-异常处理" class="headerlink" title="Spring Boot 异常处理"></a>Spring Boot 异常处理</h2><p>Spring Boot 有一套默认的异常处理机制。Spring Boot 根据请求头中的 <code>accept</code> 是否包含 <code>text/html</code> 来返回不同的响应信息。当从浏览器中访问应用接口时，请求头中的 <code>accept</code> 包含 <code>text/html</code> 信息，产生异常时，Spring Boot 通过<code>org.springframework.web.servlet.ModelAndView</code> 对象来装载异常信息，并以HTML的格式返回。当从客户端访问应用接口产生异常时，Spring Boot 以 JSON 的格式返回异常信息。  <a href="https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-error-handling">官方文档</a></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129004056223.png" alt="image-20210129004056223" loading="lazy"></p><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomError</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7032572272727239L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomError</span><span class="params">(String message, Integer status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.status = String.valueOf(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义异常处理类"><a href="#定义异常处理类" class="headerlink" title="定义异常处理类"></a>定义异常处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorController</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(CustomError.class)</span></span><br><span class="line">    ResponseEntity&lt;?&gt; handleControllerException(CustomError e) &#123;</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>,e.getStatus());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(map,HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="模拟出错"><a href="#模拟出错" class="headerlink" title="模拟出错"></a>模拟出错</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129004857518.png" alt="image-20210129004857518" loading="lazy"></p><p>我使用了 JSON 插件</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129005106513.png" alt="image-20210129005106513" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Filter and Interceptor</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-29-15_Spring-Boot-Filter-and-Interceptor/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-29-15_Spring-Boot-Filter-and-Interceptor/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-Filter-and-Interceptor"><a href="#Spring-Boot-Filter-and-Interceptor" class="headerlink" title="Spring Boot Filter and Interceptor"></a>Spring Boot Filter and Interceptor</h2><p>在 Spring Boot 中使用过滤器和拦截器来计算 Controller 中方法的执行时长。 <a href="https://docs.spring.io/spring-boot/docs/1.5.14.RELEASE/reference/html/howto-embedded-servlet-containers.html#howto-add-a-servlet-filter-or-listener">Filter 文档</a></p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>实现 <code>javax.servlet.Filter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/usr/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器： 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：开始过滤&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> startime = System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：结束过滤, 中间耗时：&quot;</span>+(endTime-startime)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Filter-配置"><a href="#Filter-配置" class="headerlink" title="Filter 配置"></a>Filter 配置</h4><p><strong>注册</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;MyFilter&gt; <span class="title">registrationBean</span><span class="params">(MyFilter myFilter)</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter&gt; registrationBean=<span class="keyword">new</span> FilterRegistrationBean&lt;&gt;(myFilter);</span><br><span class="line">        Collection&lt;String&gt; collection=<span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        collection.add(<span class="string">&quot;/usr/&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;/login/&quot;</span>);</span><br><span class="line">        registrationBean.setUrlPatterns(collection);</span><br><span class="line">        <span class="keyword">return</span>  registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注解</strong></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129222153375.png" alt="image-20210129222153375" loading="lazy"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129222858671.png" alt="image-20210129222858671" loading="lazy"></p><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先执行</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;拦截器： 开始&quot;</span>);</span><br><span class="line">       <span class="keyword">long</span> startime = System.currentTimeMillis();</span><br><span class="line">       request.setAttribute(<span class="string">&quot;startTime&quot;</span>,startime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 preHandle 执行后执行，有异常不执行，跳到 afterCompletion</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器：处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后执行，不管有没有异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long startTime = (Long) request.getAttribute(<span class="string">&quot;startTime&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器：关闭,  中间耗时：&quot;</span>+(endTime-startTime)+<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Interceptor-配置"><a href="#Interceptor-配置" class="headerlink" title="Interceptor 配置"></a>Interceptor 配置</h4><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129223301053.png" alt="image-20210129223301053" loading="lazy"></p><p>现在不需要继承 WebMvcConfigurerAdapter，可以直接实现 WebMvcConfigurer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demo.filter.MyHandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanderInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyHandlerInterceptor myHandlerInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myHandlerInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><strong>有异常</strong></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129224013699.png" alt="image-20210129224013699" loading="lazy"></p><p><strong>无异常</strong></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210129224112432.png" alt="image-20210129224112432" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 使用 Thymeleaf</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-27-09_Spring%20Boot%20%E4%BD%BF%E7%94%A8%20Thymeleaf/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-27-09_Spring%20Boot%20%E4%BD%BF%E7%94%A8%20Thymeleaf/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-使用-Thymeleaf"><a href="#Spring-Boot-使用-Thymeleaf" class="headerlink" title="Spring Boot 使用 Thymeleaf"></a>Spring Boot 使用 Thymeleaf</h2><p>Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎，能够处理 HTML，XML，JavaScript，CSS<br>甚至纯文本。详情见 <a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#introducing-thymeleaf">官方文档</a> 。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Thymeleaf-配置"><a href="#Thymeleaf-配置" class="headerlink" title="Thymeleaf 配置"></a>Thymeleaf 配置</h3><p>可以在 application.properties 中配置 Thymeleaf 的属性</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）</span></span><br><span class="line"><span class="meta">spring.thymeleaf.prefix</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#在构建URL时添加到视图名称后的后缀（默认值：.html）</span></span><br><span class="line"><span class="meta">spring.thymeleaf.suffix</span>=<span class="string">.html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启模板缓存（默认值：true）</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">true </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Check that the template exists before rendering it.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.check-template</span>=<span class="string">true </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#检查模板位置是否正确（默认值:true）</span></span><br><span class="line"><span class="meta">spring.thymeleaf.check-template-location</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Content-Type的值（默认值：text/html）</span></span><br><span class="line"><span class="meta">spring.thymeleaf.content-type</span>=<span class="string">text/html</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开启MVC Thymeleaf视图解析（默认值：true）</span></span><br><span class="line"><span class="meta">spring.thymeleaf.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#模板编码</span></span><br><span class="line"><span class="meta">spring.thymeleaf.encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#要被排除在解析之外的视图名称列表，用逗号分隔</span></span><br><span class="line"><span class="meta">spring.thymeleaf.excluded-view-names</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)</span></span><br><span class="line"><span class="meta">spring.thymeleaf.mode</span>=<span class="string">HTML5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。</span></span><br><span class="line"><span class="meta">spring.thymeleaf.template-resolver-order</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#可解析的视图名称列表，用逗号分隔</span></span><br><span class="line"><span class="meta">spring.thymeleaf.view-names</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="创建-index-html"><a href="#创建-index-html" class="headerlink" title="创建 index.html"></a>创建 index.html</h3><p>在 src/main/resource/templates 下创建 index.html 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello Spring Boot</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建控制层-IndexController"><a href="#创建控制层-IndexController" class="headerlink" title="创建控制层 IndexController"></a>创建控制层 IndexController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127010918209.png" alt="image-20210127010918209" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合 Swagger2</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-27-10_Spring-Boot-%E6%95%B4%E5%90%88-Swagger2/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-27-10_Spring-Boot-%E6%95%B4%E5%90%88-Swagger2/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-整合-Swagger2"><a href="#Spring-Boot-整合-Swagger2" class="headerlink" title="Spring Boot 整合 Swagger2"></a>Spring Boot 整合 Swagger2</h2><p>Swagger是一款可以快速生成符合RESTful风格API并进行在线调试的插件。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Swagger2-注解"><a href="#Swagger2-注解" class="headerlink" title="Swagger2 注解"></a>Swagger2 注解</h3><ul><li><code>@Api</code>：修饰整个类，描述Controller的作用；</li><li><code>@ApiOperation</code>：描述一个方法，或者说一个接口；</li><li><code>@ApiParam</code>：单个参数描述；</li><li><code>@ApiModel</code>：用对象来接收参数；</li><li><code>@ApiProperty</code>：用对象接收参数时，描述对象的一个字段；</li><li><code>@ApiResponse</code>：HTTP响应其中1个描述；</li><li><code>@ApiResponses</code>：HTTP响应整体描述；</li><li><code>@ApiIgnore</code>：使用该注解忽略这个API；</li><li><code>@ApiError</code> ：发生错误返回的信息；</li><li><code>@ApiImplicitParam</code>：一个请求参数；</li><li><code>@ApiImplicitParams</code>：多个请求参数。</li></ul><h3 id="Swagger2-配置"><a href="#Swagger2-配置" class="headerlink" title="Swagger2 配置"></a>Swagger2 配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">buildDocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(buildApiInf())</span><br><span class="line">                .select()</span><br><span class="line">            <span class="comment">//扫描路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.example.demo.controller&quot;</span>))</span><br><span class="line">               <span class="comment">//根据注解定制</span></span><br><span class="line">            <span class="comment">//.apis(RequestHandlerSelectors.withMethodAnnotation(ApiImplicitParams.class))</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">buildApiInf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;网址&quot;</span>,<span class="string">&quot;邮箱&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">            <span class="comment">//文档首页标题</span></span><br><span class="line">                .title(<span class="string">&quot;系统RESTful API文档&quot;</span>) </span><br><span class="line">            <span class="comment">//文档描述信息</span></span><br><span class="line">            .description(<span class="string">&quot;swagger2-文档构建利器&quot;</span>)</span><br><span class="line">            <span class="comment">//创建者信息</span></span><br><span class="line">            .contact(contact) </span><br><span class="line">            <span class="comment">//文档版本</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改-Controller"><a href="#修改-Controller" class="headerlink" title="修改 Controller"></a>修改 Controller</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127221530198.png" alt="image-20210127221530198" loading="lazy"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127221725794.png" alt="image-20210127221725794" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127221816613.png" alt="image-20210127221816613" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127222550393.png" alt="image-20210127222550393" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Aop 记录用户操作</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-27-08_Spring%20Boot%20Aop%20%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-27-08_Spring%20Boot%20Aop%20%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-Aop-记录用户操作"><a href="#Spring-Boot-Aop-记录用户操作" class="headerlink" title="Spring Boot Aop 记录用户操作"></a>Spring Boot Aop 记录用户操作</h2><p>在 Spring 框架中，使用 AOP 配合自定义注解可以方便的实现记录用户操作。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>用于标记用户操作的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建实体类来存储用户的操作"><a href="#创建实体类来存储用户的操作" class="headerlink" title="创建实体类来存储用户的操作"></a>创建实体类来存储用户的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myLog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Method;</span><br><span class="line">    <span class="keyword">private</span> String description ;</span><br><span class="line">    <span class="keyword">private</span> String parame;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        Method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParame</span><span class="params">(String parame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parame = parame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;myLog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Method=&#x27;&quot;</span> + Method + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, description=&#x27;&quot;</span> + description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, parame=&#x27;&quot;</span> + parame + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, date=&quot;</span> + date +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.LocalVariableTableParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.demo.contrller.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">myAround</span><span class="params">(ProceedingJoinPoint point)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行方法</span></span><br><span class="line">            result = point.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存日志</span></span><br><span class="line">        saveLog(point);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        myLog myLog = <span class="keyword">new</span> myLog();</span><br><span class="line">        Log logAnnotation = method.getAnnotation(Log.class);</span><br><span class="line">        <span class="keyword">if</span> (logAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注解上的描述</span></span><br><span class="line">            myLog.setDescription(logAnnotation.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 请求的方法名</span></span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        String methodName = signature.getName();</span><br><span class="line">        myLog.setMethod(className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;()&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求的方法参数值</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="comment">// 请求的方法参数名称</span></span><br><span class="line">        LocalVariableTableParameterNameDiscoverer u = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">        String[] paramNames = u.getParameterNames(method);</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; paramNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String params = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                params += <span class="string">&quot;  &quot;</span> + paramNames[i] + <span class="string">&quot;: &quot;</span> + args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            myLog.setParame(params);</span><br><span class="line">        &#125;</span><br><span class="line">        myLog.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(myLog);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>修改 IndexController</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126232932606.png" alt="image-20210126232932606" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126232901547.png" alt="image-20210126232901547" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126233002574.png" alt="image-20210126233002574" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 缓存 Redis</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-27-07_Spring-Boot-%E7%BC%93%E5%AD%98-Redis/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-27-07_Spring-Boot-%E7%BC%93%E5%AD%98-Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-缓存-Redis"><a href="#Spring-Boot-缓存-Redis" class="headerlink" title="Spring Boot 缓存 Redis"></a>Spring Boot 缓存 Redis</h2><p><a href="https://spvian.lanzous.com/ieFf7kxop5c">下载 Redis x64</a> </p><p>以下部分是把 <a href="https://spviancc.github.io/_posts/2021-01-27-06_Spring-Boot-%E7%BC%93%E5%AD%98-EhCache/">Spring Boot 缓存 EhCahe</a> 中的 EhCahe 替换为 Redis</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-boot redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启-Redis-服务"><a href="#开启-Redis-服务" class="headerlink" title="开启 Redis 服务"></a>开启 Redis 服务</h3><p>开启服务时，会有一个黑窗口一闪而过。默认端口是 6379</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127203158530.png" alt="image-20210127203158530" loading="lazy"></p><p>你也可以在服务管理那里开启</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127203521187.png" alt="image-20210127203521187" loading="lazy"></p><h3 id="application-yml-中配置-Redis"><a href="#application-yml-中配置-Redis" class="headerlink" title="application.yml 中配置 Redis"></a>application.yml 中配置 Redis</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//这是默认配置，可以不配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment"># Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">      <span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">      <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">      <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">      <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>有关更多 Redis 的配置可以去 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties-cache">官网</a> 查看</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127203949562.png" alt="image-20210127203949562" loading="lazy"></p><h3 id="实体类序列化"><a href="#实体类序列化" class="headerlink" title="实体类序列化"></a>实体类序列化</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127204200123.png" alt="image-20210127204200123" loading="lazy"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我之前已经测试过一次，可以看到没有去数据库中查询</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127204753616.png" alt="image-20210127204753616" loading="lazy"></p><p>我们来看 Redis 中有没有缓存，Redis 中有一个 Key ，我们获取这个 Key 可以得到我们缓存的数据</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127205037738.png" alt="image-20210127205037738" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 缓存 EhCache</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-27-06_Spring%20Boot%20%E7%BC%93%E5%AD%98%20EhCache/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-27-06_Spring%20Boot%20%E7%BC%93%E5%AD%98%20EhCache/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-缓存-EhCache"><a href="#Spring-Boot-缓存-EhCache" class="headerlink" title="Spring Boot 缓存 EhCache"></a>Spring Boot 缓存 EhCache</h2><p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是一种广泛使用的开源 Java 分布式缓存。</p><p>Spring 本身不直接提供缓存功能的实现。它支持注解方式使用缓存。注解的使用可以查看 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache">官方文档</a></p><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p><code>@CacheConfig</code>：主要用于配置该类中会用到的一些共用的缓存配置。在这里 <code>@CacheConfig(cacheNames = &quot;stu&quot;)</code>，配置了该数据访问对象中返回的内容将存储于名为 stu 的缓存对象中。我们也可以不使用该注解，直接通过<code>@Cacheable</code>自己配置缓存集的名字来定义。</p><p><code>@Cacheable</code>：将方法的返回值加入缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数：</p><ul><li><p><code>value、cacheNames</code>：两个等同的参数，非必需，用于指定缓存存储的集合名。</p></li><li><p><code>key</code>：缓存对象存储在Map集合中的 key。默认为 “ ”，意味着所有方法参数都被视为一个 key，除非已经配置了自定义的keyGenerator。</p></li><li><p><code>condition</code>：缓存对象的条件，非必需，也需使用 SpEL 表达式，只有满足表达式条件的内容才会被缓存。<code>@Cacheable(key = &quot;#p0&quot;, condition = &quot;#p0.length() &lt; 3&quot;)</code>，表示只有当第一个参数的长度小于3的时候才会被缓存。</p></li><li><p><code>unless</code>：另外一个缓存条件参数，非必需，需使用SpEL表达式。它不同于 <code>condition</code> 参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对result进行判断。</p></li><li><p><code>keyGenerator</code>：用于指定 key 生成器，非必需。若需要指定一个自定义的 key，我们需要去实现org.springframework.cache.interceptor.KeyGenerator 接口，并使用该参数来指定。</p></li><li><p><code>cacheManager</code>：用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用。</p></li><li><p><code>cacheResolver</code>：用于指定使用那个缓存解析器，非必需。需通过 org.springframework.cache.interceptor.CacheResolver 接口来实现自己的缓存解析器，并用该参数指定。</p></li></ul><p><code>@CachePut</code>：配置方法上，能够根据参数定义条件来进行缓存，其缓存的是方法的返回值，它与 <code>@Cacheable</code> 不同的是，它每次都会真实调用函数，所以主要用于数据新增和修改操作上，它的参数与 <code>@Cacheable</code> 类似。</p><p><code>@CacheEvict</code>：配置于方法上，通常用在删除方法上，用来从缓存中移除相应数据。除了同 <code>@Cacheable</code> 一样的参数之外，它还有两个参数：</p><ul><li><code>allEntries</code>：非必需，默认为 false。当为 true 时，会移除所有数据；</li><li><code>beforeInvocation</code>：非必需，默认为 false，会在调用方法之后移除数据。当为 true 时，会在调用方法之前移除数据。</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127040748227.png" alt="image-20210127040748227" loading="lazy"></p><h3 id="ehcache配置"><a href="#ehcache配置" class="headerlink" title="ehcache配置"></a>ehcache配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;3600&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 自定义配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;stu&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxEntriesLocalHeap</span>=<span class="string">&quot;2000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;3600&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">statistics</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">cache ：自定的缓存，当自定的配置不满足实际情况时可以通过自定义（可以包含多个cache节点）</span></span><br><span class="line"><span class="comment">name : 缓存的名称，可以通过指定名称获取指定的某个Cache对象</span></span><br><span class="line"><span class="comment">maxElementsInMemory ：内存中允许存储的最大的元素个数，0代表无限个</span></span><br><span class="line"><span class="comment">clearOnFlush：内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">eternal ：设置缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。根据存储数据的不同，例如一些静态不变的数据如省市区等可以设置为永不过时</span></span><br><span class="line"><span class="comment">timeToIdleSeconds ： 设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">timeToLiveSeconds ：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。</span></span><br><span class="line"><span class="comment">overflowToDisk ：内存不足时，是否启用磁盘缓存。</span></span><br><span class="line"><span class="comment">maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。</span></span><br><span class="line"><span class="comment">maxElementsOnDisk：硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。</span></span><br><span class="line"><span class="comment">diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span></span><br><span class="line"><span class="comment">--&gt;</span>    </span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开启配置"><a href="#开启配置" class="headerlink" title="开启配置"></a>开启配置</h3><p>在 application.properties 中指明 EhCache 的配置文件位置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.ehcache.config</span>=<span class="string">classpath:ehcache.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#在配置中开启 debug 可以在测试执行过程中看到 sql 语句</span></span><br><span class="line"><span class="comment">#com.example.demo.mapper 是我数据访问层所在的包</span></span><br><span class="line"><span class="meta">logging.level.com.example.demo.mapper</span>=<span class="string">debug  </span></span><br></pre></td></tr></table></figure><p>在启动类上使用注解 <code>@EnableCaching</code> 来开启缓存</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127041502955.png" alt="image-20210127041502955" loading="lazy"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用缓存前，去数据库中查询了两次。</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127041226732.png" alt="image-20210127041226732" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127041115052.png" alt="image-20210127041115052" loading="lazy"></p><p>使用缓存后，只查了一次数据</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210127041427402.png" alt="image-20210127041427402" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合 Mybatis PageHelper</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-26-05_Spring%20Boot%20%E6%95%B4%E5%90%88%20Mybatis%20PageHelper/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-26-05_Spring%20Boot%20%E6%95%B4%E5%90%88%20Mybatis%20PageHelper/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-整合-PageHelper"><a href="#Spring-Boot-整合-PageHelper" class="headerlink" title="Spring Boot 整合 PageHelper"></a>Spring Boot 整合 PageHelper</h2><p>PageHelper 是 Mybatis 的分页插件，支持多数据库、多数据源。可以简化数据库的分页查询操作。</p><p>使用时，只需引入依赖即可。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>修改 IndexController</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126043834668.png" alt="image-20210126043834668" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126043912132.png" alt="image-20210126043912132" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合 MyBatis 通用 Mapper</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-26-04_Spring%20Boot%20%E6%95%B4%E5%90%88%20MyBatis%20%E9%80%9A%E7%94%A8%20Mapper/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-26-04_Spring%20Boot%20%E6%95%B4%E5%90%88%20MyBatis%20%E9%80%9A%E7%94%A8%20Mapper/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-整合-MyBatis-通用-Mapper"><a href="#Spring-Boot-整合-MyBatis-通用-Mapper" class="headerlink" title="Spring Boot 整合 MyBatis 通用 Mapper"></a>Spring Boot 整合 MyBatis 通用 Mapper</h2><p>tk.mybatis 是在 MyBatis 框架的基础上提供了很多工具，让开发更加高效。</p><p>更多使用可以查看 <a href="https://github.com/abel533/Mapper/wiki">官网</a></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-pom-中配置-MyBatis-Geneator"><a href="#在-pom-中配置-MyBatis-Geneator" class="headerlink" title="在 pom 中配置 MyBatis Geneator"></a>在 pom 中配置 MyBatis Geneator</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 自动生成的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>$&#123;basedir&#125;/src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 是否覆盖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--允许移动生成的文件 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span> </span><br></pre></td></tr></table></figure><h3 id="application-yml-配置"><a href="#application-yml-配置" class="headerlink" title="application.yml 配置"></a>application.yml 配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//后面做测试，提前把数据库配置配好</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.demo.domain</span>  <span class="comment">#实体类的存放路径</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><h3 id="配置-Geneator"><a href="#配置-Geneator" class="headerlink" title="配置 Geneator"></a>配置 Geneator</h3><p>在 src/main/resource 目录下创建 generatorConfig.xml 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入数据库连接配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;properties resource=&quot;jdbc.properties&quot;/&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;Mysql&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span> <span class="attr">defaultModelType</span>=<span class="string">&quot;flat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置 tk.mybatis 插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappers&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.example.demo.utils.MyMapper&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/db2?serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置实体类存放路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.example.demo.domain&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置 XML 存放路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置 DAO 存放路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span></span></span><br><span class="line"><span class="tag">                <span class="attr">targetPackage</span>=<span class="string">&quot;com.example.demo.dao&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">catalog</span>=<span class="string">&quot;db2&quot;</span> <span class="attr">tableName</span>=<span class="string">&quot;stu&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mysql 配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;Mysql&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建一个通用的父级接口"><a href="#创建一个通用的父级接口" class="headerlink" title="创建一个通用的父级接口"></a>创建一个通用的父级接口</h3><p>主要作用是让 DAO 层的接口继承该接口，以达到使用 tk.mybatis 的目的。值得注意的是，该接口不能被扫描到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tk.mybatis.mapper.common.Mapper;</span><br><span class="line"><span class="keyword">import</span> tk.mybatis.mapper.common.MySqlMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">MySqlMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn mybatis-generator:generate</span><br></pre></td></tr></table></figure><p>使用 maven 的插件管理</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126040936011.png" alt="image-20210126040936011" loading="lazy"></p><h4 id="生成的实体类"><a href="#生成的实体类" class="headerlink" title="生成的实体类"></a>生成的实体类</h4><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126041244314.png" alt="image-20210126041244314" loading="lazy"></p><h4 id="数据访问层"><a href="#数据访问层" class="headerlink" title="数据访问层"></a>数据访问层</h4><p>这里继承了通用的父级接口 MyMapper</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126041333702.png" alt="image-20210126041333702" loading="lazy"></p><h4 id="生成的Mapper"><a href="#生成的Mapper" class="headerlink" title="生成的Mapper"></a>生成的Mapper</h4><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126041529678.png" alt="image-20210126041529678" loading="lazy"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>修改 IndexController</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126041642863.png" alt="image-20210126041642863" loading="lazy"></p><p>在启动类上配置数据访问层的扫描 （指定 Mapper 接口的路径）</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126042641572.png" alt="image-20210126042641572" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126041710831.png" alt="image-20210126041710831" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 整合 Mybatis</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-26-03_Spring%20Boot%20%E6%95%B4%E5%90%88%20Mybatis/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-26-03_Spring%20Boot%20%E6%95%B4%E5%90%88%20Mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Boot-整合-Mybatis"><a href="#Spring-Boot-整合-Mybatis" class="headerlink" title="Spring Boot 整合 Mybatis"></a>Spring Boot 整合 Mybatis</h2><p>继初试 Spring Boot 的基础上来继续开发。</p><p>我用的试 MySql 数据库，如有不同，请导入相应的驱动包，不清楚可以百度。</p><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>不同版本的 Spring Boot 和 MyBatis版本对应不一样，具体可查看 <a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">官方文档</a></p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126005935711.png" alt="image-20210126005935711" loading="lazy"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="MySql-数据源配置"><a href="#MySql-数据源配置" class="headerlink" title="MySql 数据源配置"></a>MySql 数据源配置</h3><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `stu` (</span><br><span class="line">`id` <span class="type">int</span> (<span class="number">11</span>),</span><br><span class="line">`name` <span class="type">varchar</span> (<span class="number">60</span>),</span><br><span class="line">`age` <span class="type">int</span> (<span class="number">11</span>),</span><br><span class="line">`sex` <span class="type">varchar</span> (<span class="number">30</span>),</span><br><span class="line">`add_time` <span class="type">timestamp</span> ,</span><br><span class="line">`update_time` <span class="type">timestamp</span> </span><br><span class="line">); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `stu` (`id`, `name`, `age`, `sex`, `add_time`, `update_time`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;ss1&#x27;</span>,<span class="string">&#x27;20&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `stu` (`id`, `name`, `age`, `sex`, `add_time`, `update_time`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;sss&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `stu` (`id`, `name`, `age`, `sex`, `add_time`, `update_time`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;ssss&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="keyword">NULL</span>,<span class="keyword">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.yml 的配置</p><blockquote><p>我这里把 application.properties 改为 application.yml ，</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db2?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Date add_time;</span><br><span class="line">    <span class="keyword">private</span> Date update_time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getAdd_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> add_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdd_time</span><span class="params">(Date add_time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.add_time = add_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getUpdate_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> update_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpdate_time</span><span class="params">(Date update_time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.update_time = update_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编写数据访问层"><a href="#编写数据访问层" class="headerlink" title="编写数据访问层"></a>编写数据访问层</h3><p>我这里使用 myabit 的注解来实现，也可以使用 xml 的方式来配置。更多注解的使用看以去 <a href="https://mybatis.org/mybatis-3/zh/java-api.html">官网</a> 查看</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126015708402.png" alt="image-20210126015708402" loading="lazy"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StuDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from stu where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">Stu <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>xml 的配置需要在 application.yml 中添加以下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># type-aliases扫描路径</span></span><br><span class="line">  <span class="comment"># type-aliases-package:</span></span><br><span class="line">  <span class="comment"># mapper xml实现扫描路径</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">property:</span></span><br><span class="line">    <span class="attr">order:</span> <span class="string">BEFORE</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在 indexController 中修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StuDao stuDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stu <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuDao.findById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210126020140674.png" alt="image-20210126020140674" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 基础配置</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-25-02_Spring%20Boot%20%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-25-02_Spring%20Boot%20%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="定制Banner"><a href="#定制Banner" class="headerlink" title="定制Banner"></a>定制Banner</h2><p>Spring Boot 在启动时会有一个默认的启动图案，我们可以更改这个图案。图案可以在 <a href="http://www.network-science.de/ascii/">ASCII Generator</a>  生成，不支持中文。</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210125015123462.png" alt="image-20210125015123462" loading="lazy"></p><p>生成自己的Banner后，在 <code>src/main/resource</code> 下新建 banner.txt 文件，文件中放入我们生成的图案，启动项目就可以看到了我们自己的图案了。</p><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210125015832395.png" alt="image-20210125015832395" loading="lazy"></p><p>如果不需要图案也是可以关闭的，只不过我们需要去修改启动程序的代码，重新启动就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//SpringApplication.run(DemoApplication.class, args);</span></span><br><span class="line">        SpringApplication app=<span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">        app.setBannerMode(Banner.Mode.OFF);  <span class="comment">//这里可以设置banner的开启可关闭</span></span><br><span class="line">        app.run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>在 <code>src/main/resources</code> 目录下，Spring Boot 提供了一个名为 application.properties<br>的全局配置文件，可对一些默认配置的配置值进行修改，英语好的可以点击 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html">这里</a><br>去官网查看相关的配置。</p><p>除了默认配置，我们还可以定义自己的配置值。</p><h3 id="自定义属性值"><a href="#自定义属性值" class="headerlink" title="自定义属性值"></a>自定义属性值</h3><p>在 <code>application.properties</code> 下自定义一些属性值，如</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">you.name</span>=<span class="string">spvian</span></span><br><span class="line"><span class="meta">you.tages</span>=<span class="string">Spring Boot</span></span><br></pre></td></tr></table></figure><p>创建 user 类，并用注解 @Component 来把它加入到容器。属性的值用注解 @Value 来获取配置中设置好的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;you.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;you.tages&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTages</span><span class="params">(String tages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tages = tages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改IndexController，注入Bean，完成后启动项目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getName()+<span class="string">&quot;--&quot;</span>+user.getTages();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spviancc/spviancc.github.io/master/assets/image-20210125024956146.png" alt="image-20210125024956146" loading="lazy"></p><h3 id="属性间的引用"><a href="#属性间的引用" class="headerlink" title="属性间的引用"></a>属性间的引用</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">you.name</span>=<span class="string">spvian</span></span><br><span class="line"><span class="meta">you.tages</span>=<span class="string">Spring Boot</span></span><br><span class="line"><span class="meta">you.title</span>=<span class="string">$&#123;you.name&#125;--$&#123;you.tages&#125;</span></span><br></pre></td></tr></table></figure><h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>除了可以在 <code>application.properties</code> 里配置属性，我们还可以自定义配置文件。在 <code>src/main/resources</code> 目录下新建一个 <code>test.properties</code>。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">test.name</span>=<span class="string">spvian</span></span><br><span class="line"><span class="meta">test.tages</span>=<span class="string">Spring Boot</span></span><br></pre></td></tr></table></figure><p>创建对应的类，并修改 IndexController，除此之外还需要在启动类上加上 @EnableConfigurationProperties(TestConfig.class) 来启用该配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:test.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String tages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTages</span><span class="params">(String tages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tages = tages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>@Configuration</code> 把它标识为配置类</p><p>注解 <code>@PropertySource(&quot;classpath:test.properties&quot;)</code> 指明使用哪个配置文件</p><p>注解 <code>@ConfigurationProperties(prefix = &quot;test&quot;)</code> 可有效绑定到此对象的属性的前缀</p><p>prefix属性的英文解释</p><blockquote><p>The prefix of the properties that are valid to bind to this object. Synonym for value(). A valid prefix is defined by one or more words separated with dots (e.g. “acme.system.feature”).<br>Returns:  the prefix of the properties to bind</p></blockquote><h2 id="通过命令行设置属性值"><a href="#通过命令行设置属性值" class="headerlink" title="通过命令行设置属性值"></a>通过命令行设置属性值</h2><p>在运行 Spring Boot 的 jar 文件时，可以使用命令 <code>java -jar xxx.jar --server.port=8081</code> 来改变端口的值。这条命令等价于我们手动到 application.properties<br>中修改（如果没有这条属性的话就添加）server.port 属性的值为8081。</p><p>如果不想项目的配置被命令行修改，可以在启动类中的main方法中进行如下设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">    app.setAddCommandLineProperties(<span class="keyword">false</span>);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用xml配置"><a href="#使用xml配置" class="headerlink" title="使用xml配置"></a>使用xml配置</h2><p>Spring Boot 并不推荐我们使用 xml 配置，但如果出现不得不使用 xml 配置的情况，Spring Boot 允许我们在启动类里通过注解<code>@ImportResource(&#123;&quot;classpath:xxxx.xml&quot;&#125;)</code>来引入<br>xml 配置文件。</p><h2 id="Profile配置"><a href="#Profile配置" class="headerlink" title="Profile配置"></a>Profile配置</h2><p>Profile 用来针对不同的环境下使用不同的配置文件，多环境配置文件必须以 <code>application-&#123;profile&#125;.properties</code> 的格式命，其中<code>&#123;profile&#125;</code>为环境标识。</p><ul><li><p>application-dev.properties ：开发环境</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure></li><li><p>application-prod.properties ：生产环境</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br></pre></td></tr></table></figure></li></ul><p>至于哪个配置文件会被加载，需要在 application.properties 文件中通过 <code>spring.profiles.active</code> 属性来设置，其值对应<code>&#123;profile&#125;</code> 的值。</p><p>如：<code>spring.profiles.active=dev</code> 就会加载 application-dev.properties 配置文件内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初试 Spring Boot</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-25-01_%E5%88%9D%E8%AF%95%20Spring%20Boot/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-25-01_%E5%88%9D%E8%AF%95%20Spring%20Boot/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>这里使用idea编辑器为例</p><p><img src="https://i.loli.net/2021/01/25/uxKiHNJlTVfAdmF.png" alt="image-20210125011630642" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/25/cloNqAFRng425Uv.png" alt="image-20210125011838333" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/25/1AdVZcXEsoKG74Q.png" alt="image-20210125012049064" loading="lazy"></p><p>建好后需要等它加载依赖包，可能会有点慢</p><h2 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h2><p>初始化完成后的目录结构</p><p><img src="https://i.loli.net/2021/01/25/sBqA4IwHjfLgzce.png" alt="image-20210125012446449" loading="lazy"></p><h3 id="创建控制层"><a href="#创建控制层" class="headerlink" title="创建控制层"></a>创建控制层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动 DemoApplication</p><p>启动成功后，会告诉我们<strong>端口号</strong>和<strong>路径</strong></p><p>在浏览器中输入<code>http://localhost:8080/</code></p><p><img src="https://i.loli.net/2021/01/25/iM26jsgrlqFIOmK.png" alt="image-20210125012916249" loading="lazy"></p><p>如果没有出错的话，我们可以看到它展示了我们书写在控制层内容</p><p><img src="https://i.loli.net/2021/01/25/wN9ils1fz8GHgoJ.png" alt="image-20210125013112848" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ToroiseGit 的安装</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-23-05_TortoiseGit%20%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-23-05_TortoiseGit%20%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="TortoiseGit"><a href="#TortoiseGit" class="headerlink" title="TortoiseGit"></a>TortoiseGit</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>git 图形化软件，与 TortiseSVN 是同门。TortoiseGit 是一个Git 版本控制客户端，作为 Microsoft Windows<br>的外壳扩展实现。一个新的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=54528924&ss_c=ssc.citiao.link">版本管理</a>工具 Git，它本来是<br>Linux 下的基于Linux 内核的版本控制工具。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>这里提供了压缩包，压缩包中有 TortoiseGit 安装包和它的中文语言安装包 TortoiseGit-LanguagePack</p><p>点击<a href="https://spvian.lanzous.com/iucnnkphloh">下载</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>因为 TortoiseGit 只是一个程序壳,必须依赖一个 Git Core,所以安装前请确定已完成 git 安装和配置</p><h4 id="先安装-TortoiseGit"><a href="#先安装-TortoiseGit" class="headerlink" title="先安装 TortoiseGit"></a>先安装 TortoiseGit</h4><p>双击运行，然后一直 next 直到出现下面那张图，说明安装成功了</p><p><img src="https://i.loli.net/2021/01/22/SQFdqbo6957RDmN.png" alt="image-20210122222542523" loading="lazy"></p><h4 id="再安装语言包"><a href="#再安装语言包" class="headerlink" title="再安装语言包"></a>再安装语言包</h4><p>双击运行，然后一直 next 直到出现，记得勾选下面的选项，就不用再去设置里更改了</p><p><img src="https://i.loli.net/2021/01/22/CMA1nlQwOgtszj5.png" alt="image-20210122222738966" loading="lazy"></p><p>如果忘记勾选可以去Settings中修改</p><p><img src="https://i.loli.net/2021/01/22/DiLSZBC67pIMw9G.png" alt="image-20210122223349598" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/22/TkWj4ozHp8Jm5I6.png" alt="image-20210122223547883" loading="lazy"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>我是因为之前有用密钥使用过 git， 所以这里没有配置密码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">　　name =   <span class="comment">//注册用的账号</span></span><br><span class="line">　　email = <span class="comment">//注册用的联系邮箱</span></span><br><span class="line">　　signingkey = <span class="comment">//注册用的密码</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/22/iznrST4JqPCwmav.png" alt="image-20210122224117641" loading="lazy"></p><h4 id="密钥配置"><a href="#密钥配置" class="headerlink" title="密钥配置"></a>密钥配置</h4><p>在 TortoiseGit 中选择 PuTTYgen 后，点击 Generate 来生成密钥</p><ul><li>注意：生成时鼠标要不停划过进度条，不然进度条会一直不动</li></ul><p><img src="https://i.loli.net/2021/01/22/DiLSZBC67pIMw9G.png" alt="image-20210122223349598" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/22/8jliwRK7hxsQDUE.png" alt="image-20210122225031485" loading="lazy"></p><p>记住保存私钥的位置，很重要</p><p>这里以 GitHub 为例，复制公钥到 GitHub 上配置 SSH Keys</p><p><img src="https://i.loli.net/2021/01/22/kivU65bVpnDBAft.png" alt="image-20210122230143452" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/22/lacwxyChzvX6nro.png" alt="image-20210122230031855" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/22/Gs2DqgjYHpFZv7R.png" alt="image-20210122230416788" loading="lazy"></p><p>在 TortoiseGit 中选择 Pageant ，添加保存的私钥。默认不显示画面，会有个小图标在右下角。</p><p><img src="https://i.loli.net/2021/01/22/zH5Rx1jtge3odm7.png" alt="image-20210122230900273" loading="lazy"></p><p>到此为止算是配置完成了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 配置 JDK</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-22-03_Linux%20%E9%85%8D%E7%BD%AE%20JDK/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-22-03_Linux%20%E9%85%8D%E7%BD%AE%20JDK/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-JDk"><a href="#安装-JDk" class="headerlink" title="安装 JDk"></a>安装 JDk</h2><p><a href="https://pan.baidu.com/s/1iDH4ahRh2DozUy375Rl3hQ">提取码：0000 </a></p><h3 id="解压-JDK"><a href="#解压-JDK" class="headerlink" title="解压 JDK"></a>解压 JDK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf  压缩包的名   //表示在当前目录</span><br><span class="line">tar -zxvf  压缩包的名 -C 目标路径</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>使用 vim /etc/profile 命令，在文件末添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8   //jdk所在的文件目录</span><br><span class="line">CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib/</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH JAVA_HOME CLASSPATH</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile  //让配置生效</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/01/22/WpEIByUmqVGHzDf.png" alt="image-20210122204302713" style="zoom: 80%;" / loading="lazy"><h3 id="检验配置"><a href="#检验配置" class="headerlink" title="检验配置"></a>检验配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/22/breOi4fCdG9Z1po.png" alt="image-20210122204458775" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 子系统安装开发软件</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-23-04_Windows%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-23-04_Windows%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="windows子系统安装开发软件"><a href="#windows子系统安装开发软件" class="headerlink" title="windows子系统安装开发软件"></a>windows子系统安装开发软件</h2><h3 id="配置工作环境"><a href="#配置工作环境" class="headerlink" title="配置工作环境"></a>配置工作环境</h3><p>这里以安装、配置 idea 为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make //在按入Center后会有些停顿</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ubuntu-make</span><br></pre></td></tr></table></figure><h3 id="安装-idea"><a href="#安装-idea" class="headerlink" title="安装 idea"></a>安装 idea</h3><p><img src="https://i.loli.net/2021/01/23/VjgMYKW1qtd7Xz4.png" alt="image-20210123162114478" loading="lazy"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umake ide -h //来查看可以安装的开发软件</span><br><span class="line">sudo umake ide idea-ultimate</span><br></pre></td></tr></table></figure><p>执行后分别会让你选择安装地址，默认就好。稍等片刻就安装好啦。在应用程序查找那里修改命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/spvian/.<span class="built_in">local</span>/share/umake/ide/idea-ultimate/bin/idea.sh  </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/23/yNCu7h2cgpoMvSe.png" alt="image-20210123171607677" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 下创建子系统</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-21-01_Windows%20%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-21-01_Windows%20%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是WSL"><a href="#什么是WSL" class="headerlink" title="什么是WSL"></a>什么是WSL</h2><p>来自<a href="https://baike.baidu.com/item/wsl/20359185">百度百科</a>的回答</p><blockquote><p>Windows Subsystem for Linux（简称 WSL）是一个为在 Windows 10 上能够原生运行 Linux 二进制可执行文件（ELF 格式）的兼容层。它是由微软与 Canonical 公司合作开发，目标是使纯正的 Ubuntu 14.04 “Trusty Tahr”映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</p></blockquote><h3 id="相对于虚拟机的优势"><a href="#相对于虚拟机的优势" class="headerlink" title="相对于虚拟机的优势"></a>相对于虚拟机的优势</h3><p>相比于 VMware 等虚拟机，WSL 占用内存和 CPU 资源更少，在 WSL 上运行软件的消耗和直接在 Windows 上差不多。而且，Windows 下可以直接访问 WSL 的环境。</p><h3 id="相对于多系统的优势"><a href="#相对于多系统的优势" class="headerlink" title="相对于多系统的优势"></a>相对于多系统的优势</h3><p>假如需要重启 Linux 系统，WSL 只需要把软件关掉重开即可。同时，相较于多系统，文件交互也更为简单。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="手动安装步骤"><a href="#手动安装步骤" class="headerlink" title="手动安装步骤"></a>手动安装步骤</h3><h4 id="启用适用于-Linux-的-Windows-子系统"><a href="#启用适用于-Linux-的-Windows-子系统" class="headerlink" title="启用适用于 Linux 的 Windows 子系统"></a>启用适用于 Linux 的 Windows 子系统</h4><p>在控制面板中选择程序，在程序和功能中可以看到[启动或关闭 Windows 功能」中勾选「适用于 Linux 的 Windows 子系统] 。或者可以使用命令的方式打开。</p><p><strong>以管理员身份打开 PowerShell 并运行：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows</span><span class="literal">-Subsystem</span><span class="literal">-Linux</span> /all /norestart</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/01/21/IeRxVoPWAH2cZ1k.png" alt="image-20210121151303582" style="zoom:80%;" / loading="lazy"><h4 id="检查运行-WSL-2-的要求"><a href="#检查运行-WSL-2-的要求" class="headerlink" title="检查运行 WSL 2 的要求"></a>检查运行 WSL 2 的要求</h4><p>若要更新到 WSL 2，需要运行 Windows 10。</p><ul><li>对于 x64 系统：<strong>版本 1903</strong> 或更高版本，采用 <strong>内部版本 18362</strong> 或更高版本。</li><li>对于 ARM64 系统：<strong>版本 2004</strong> 或更高版本，采用 <strong>内部版本 19041</strong> 或更高版本。</li><li>低于 18362 的版本不支持 WSL 2。 使用 <a href="https://www.microsoft.com/software-download/windows10">Windows Update 助手</a>更新 Windows 版本。</li></ul><p>若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。</p><p>如果运行的是 Windows 10 版本1903 或 1909， 内部版本号必须是 18362.1049+ 或 18363.1049+，次要内部版本号需要高于 .1049。</p><p><img src="https://i.loli.net/2021/01/21/iScRJ6HPZX4gTnr.png" alt="image-20210121152015640" loading="lazy"></p><h4 id="启用虚拟机功能"><a href="#启用虚拟机功能" class="headerlink" title="启用虚拟机功能"></a>启用虚拟机功能</h4><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。</p><p>以管理员身份打开 PowerShell 并运行：</p><p><strong>重新启动</strong> 计算机，以完成 WSL 安装并更新到 WSL 2。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><h4 id="下载-Linux-内核更新包"><a href="#下载-Linux-内核更新包" class="headerlink" title="下载 Linux 内核更新包"></a>下载 Linux 内核更新包</h4><ol><li>下载最新包：</li></ol><ul><li><p><a href="https://spvian.lanzous.com/i4bhHknavpe">wsl_update_x64</a></p></li><li><p><a href="https://spvian.lanzous.com/i5FZJknb3xa">wsl_update_arm64</a></p></li></ul><p>如果不确定自己计算机的类型，可以打开控制面板查看</p><p><img src="https://i.loli.net/2021/01/21/eoDMLh4iWAU9Rlw.png" alt="image-20210121153713299" loading="lazy"></p><ol start="2"><li><p>运行上一步中下载的更新包</p><p>双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。</p></li></ol><h4 id="将-WSL-2-设置为默认版本"><a href="#将-WSL-2-设置为默认版本" class="headerlink" title="将 WSL 2 设置为默认版本"></a>将 WSL 2 设置为默认版本</h4><p>打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -<span class="literal">-set</span><span class="literal">-default</span><span class="literal">-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="安装所选的-Linux-分发"><a href="#安装所选的-Linux-分发" class="headerlink" title="安装所选的 Linux 分发"></a>安装所选的 Linux 分发</h4><p>单击以下链接会打开每个分发版的 Microsoft Store 页面：</p><ul><li><a href="https://www.microsoft.com/store/apps/9pjn388hp8c9">Ubuntu 16.04 LTS</a></li><li><a href="https://www.microsoft.com/store/apps/9N9TNGVNDL3Q">Ubuntu 18.04 LTS</a></li><li><a href="https://www.microsoft.com/store/apps/9n6svws3rx71">Ubuntu 20.04 LTS</a></li><li><a href="https://www.microsoft.com/store/apps/9NJFZK00FGKV">openSUSE Leap 15.1</a></li><li><a href="https://www.microsoft.com/store/apps/9MZ3D1TRP8T1">SUSE Linux Enterprise Server 12 SP5</a></li><li><a href="https://www.microsoft.com/store/apps/9PN498VPMF3Z">SUSE Linux Enterprise Server 15 SP1</a></li><li><a href="https://www.microsoft.com/store/apps/9PKR34TNCV07">Kali Linux</a></li><li><a href="https://www.microsoft.com/store/apps/9MSVKQC78PK6">Debian GNU/Linux</a></li><li><a href="https://www.microsoft.com/store/apps/9n6gdm4k2hnc">Fedora Remix for WSL</a></li><li><a href="https://www.microsoft.com/store/apps/9NV1GV1PXZ6P">Pengwin</a></li><li><a href="https://www.microsoft.com/store/apps/9N8LP0X93VCP">Pengwin Enterprise</a></li><li><a href="https://www.microsoft.com/store/apps/9p804crf0395">Alpine WSL</a></li></ul><p>在分发版的页面中，选择“获取”。</p><p><img src="https://i.loli.net/2021/01/21/Cgl6T4feQJWhoOm.png" alt="image-20210121154239160" loading="lazy"></p><p>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。 未来的所有启动时间应不到一秒。</p><p><img src="https://i.loli.net/2021/01/21/s9xi3MRGWvODUgo.png" alt="image-20210121154608425" loading="lazy"></p><p>输入用户名和密码后，会提示安装成功。此帐户将被视为 Linux 管理员，能够运行 <code>sudo</code> (Super User Do) 管理命令。</p><p><img src="https://i.loli.net/2021/01/21/Svu2eaj8VYBzQL1.png" alt="image-20210121154735485" loading="lazy"></p><p>如果出现Enter new UNIX username: user 参考的对象类型不支持尝试的操作。运行 NoLsp.exe。</p><p>使用管理员身份启动PowerShell</p><ul><li><p><a href="https://spvian.lanzous.com/iMvqNknciud">NoLsp.exe</a></p></li><li><p>输入D:\NoLsp.exe C:\windows\system32\wsl.exe（这里注意你自己下载的NoLsp.exe位置）</p></li></ul><h5 id="重置-Linux-密码"><a href="#重置-Linux-密码" class="headerlink" title="重置 Linux 密码"></a>重置 Linux 密码</h5><p>若要更改密码，请打开 Linux 分发版（例如 Ubuntu）并输入以下命令：<code>passwd</code></p><p>系统会要求你输入当前密码，然后要求输入新密码，之后再确认新密码。</p><h5 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h5><p>如果忘记了 Linux 分发版的密码：</p><ol><li><p>请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：<code>wsl -u root</code></p><blockquote><p>如果需要在非默认分发版中更新忘记的密码，请使用命令：<code>wsl -d Debian -u root</code>，并将 <code>Debian</code> 替换为目标分发版的名称。</p></blockquote></li><li><p>在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：<code>passwd &lt;WSLUsername&gt;</code>，其中 <code>&lt;WSLUsername&gt;</code> 是 DISTRO 中帐户的用户名，而你忘记了它的密码。</p></li><li><p>系统将提示你输入新的 UNIX 密码，然后确认该密码。 在被告知密码已成功更新后，请使用以下命令在 PowerShell 内关闭 WSL：<code>exit</code></p></li></ol><h2 id="切换源并更新"><a href="#切换源并更新" class="headerlink" title="切换源并更新"></a>切换源并更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line">sudo apt update -y</span><br><span class="line">sudo apt upgrade -y</span><br></pre></td></tr></table></figure><h2 id="配置图形界面"><a href="#配置图形界面" class="headerlink" title="配置图形界面"></a>配置图形界面</h2><p>如果要运行一些带图形界面的程序，WSL 原生是没有支持 GUI 的。这里通过 XServer 实现可视化操作，用到的软件是<code>VcXsrv</code>。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li>VcXsrv 启动 Xserver 服务用于监听；</li><li>WSL 启动程序后把界面数据发送给 Xserver；</li><li>Xserver 接收到数据进行绘制，于是在 Win 下看到图形界面。</li></ol><h3 id="下载并安装-VcXsrv"><a href="#下载并安装-VcXsrv" class="headerlink" title="下载并安装 VcXsrv"></a>下载并安装 VcXsrv</h3><p><a href="https://spvian.lanzous.com/i5hSjkndp6h">vcxsrv-64.1.20.8.1.installer</a></p><p>一路 next 即可。第一步是选择组件，默认是全部安装；第二步是安装路径。</p><h3 id="启动-VcXsrv"><a href="#启动-VcXsrv" class="headerlink" title="启动 VcXsrv"></a>启动 VcXsrv</h3><p>开始菜单里现在出现了一个XLaunch，运行它</p><p>下面是我的配置</p><p><img src="https://i.loli.net/2021/01/21/hSHLq2QZtXegEVa.png" alt="image-20210121161144647" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/21/Pm2j3JTdWs6oIOY.png" alt="image-20210121161303808" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/21/4iFhnHsqWKS1ulG.png" alt="image-20210121161316674" loading="lazy"></p><p><img src="https://i.loli.net/2021/01/21/5XxowyRqZBtTfhQ.png" alt="image-20210121161540108" loading="lazy"></p><h4 id="配置-DISPLAY"><a href="#配置-DISPLAY" class="headerlink" title="配置 DISPLAY"></a>配置 DISPLAY</h4><p>运行如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export DISPLAY=ip:0.0&quot;</span> &gt;&gt; ~/.bashrc  //ip是指window下的ip，可以使用ipconfig查看</span><br><span class="line"></span><br><span class="line">//更新配置</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p>运行下述代码，安装 firefox 检验效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install firefox</span><br></pre></td></tr></table></figure><p>随后直接运行下述代码即可查看效果。<strong>前提使在root账户下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firefox</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/21/miFpMrqsYDH18tz.png" alt="image-20210121162343948" loading="lazy"></p><h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h3><p>运行下述代码，成功解决。现在可以正常显示中文了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fonts-noto-cjk</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/21/9wJvZN81pSxVEKG.png" alt="image-20210121162628693" loading="lazy"></p><h3 id="修改默认语言环境为中文（可选）"><a href="#修改默认语言环境为中文（可选）" class="headerlink" title="修改默认语言环境为中文（可选）"></a>修改默认语言环境为中文（可选）</h3><p>安装中文语言包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install language-pack-zh-hans language-pack-zh-hans-base</span><br></pre></td></tr></table></figure><p>设置本地化环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;LANG=zh_CN.UTF-8&quot;</span> &gt;&gt; ~/.profile</span><br><span class="line"><span class="built_in">source</span> ~/.profile</span><br></pre></td></tr></table></figure><h3 id="安装桌面"><a href="#安装桌面" class="headerlink" title="安装桌面"></a>安装桌面</h3><p>这里选择<code>xfce4</code>桌面，它的优点是轻量、美观、占用系统资源少。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xfce4 dbus-x11</span><br></pre></td></tr></table></figure><p>完成后，执行下面这段代码就可以看到桌面的图形界面了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfce4-session  </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/21/vLZKFINrtMPJASu.png" alt="image-20210121163949840" loading="lazy"></p><h3 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fcitx fcitx-pinyin</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;export XMODIFIERS=@im=fcitx\nexport GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\n&quot;</span> &gt;&gt; .profile</span><br></pre></td></tr></table></figure><p>软件包已装，在应用程序 - 设置 - 会话与启动 - 应用程序自启动，添加 /usr/bin/fcitx。</p><p>到此，windows安装子系统已基本完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 与子系统文件互传</title>
      <link href="2021/05/26/Spring%20Boot/2021-01-22-02_%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8E%20Windows%20%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/"/>
      <url>2021/05/26/Spring%20Boot/2021-01-22-02_%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8E%20Windows%20%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="查看挂载盘"><a href="#查看挂载盘" class="headerlink" title="查看挂载盘"></a>查看挂载盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h  </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/22/NhnDwIZyPS1Wvs6.png" alt="image-20210122192731323" loading="lazy"></p><h2 id="进入文件所在目录"><a href="#进入文件所在目录" class="headerlink" title="进入文件所在目录"></a>进入文件所在目录</h2><p><img src="https://i.loli.net/2021/01/22/FDzVb8rg73uPmMA.png" alt="image-20210122193331970" loading="lazy"></p><h2 id="使用-copy-或-mv-命令"><a href="#使用-copy-或-mv-命令" class="headerlink" title="使用 copy 或 mv 命令"></a>使用 copy 或 mv 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv maven.tar.gz /usr/<span class="built_in">local</span>  //需要root权限</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/22/FzJkZCv1mIdShtX.png" alt="image-20210122195225616" loading="lazy"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/spring/spring-transaction/"/>
      <url>2021/05/26/spring/spring-transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-transaction"><a href="#spring-transaction" class="headerlink" title="spring-transaction"></a>spring-transaction</h1><h2 id="1-spring-tx"><a href="#1-spring-tx" class="headerlink" title="1. spring-tx"></a>1. spring-tx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring-tx-5.2.7RELEASE JAR 包是 Spring 提供的事务管理依赖包。PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 是 Spring 事务管理所涉及的 3 个核心接口。</span><br></pre></td></tr></table></figure><h3 id="1-2-PlatformTransactionManager"><a href="#1-2-PlatformTransactionManager" class="headerlink" title="1.2 PlatformTransactionManager"></a>1.2 PlatformTransactionManager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PlatformTransactionManager是 Spring 提供的平台事务管理器，只是代表事务管理的接口，并不知道底层如何管理事务，只提供事务管理的 3 个方法，具体管理事务则由它的实现类完成。</span><br><span class="line">实现类：</span><br><span class="line">DataSourceTransactionManager：用于配置 JDBC 数据源的事务管理器</span><br><span class="line">HibernateTransactionManager：用于配置 Hibernate 的事务管理器</span><br><span class="line">JtaTransactionManager：用于配置全局事务管理器</span><br></pre></td></tr></table></figure><h3 id="1-3-TransactionDefinition"><a href="#1-3-TransactionDefinition" class="headerlink" title="1.3 TransactionDefinition"></a>1.3 TransactionDefinition</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">是事务定义的对象，对象中定义了事务的规则，并提供获取事务相关信息的方法。</span><br><span class="line">String getName（）：获取事务对象名称</span><br><span class="line">int getIsolationLevel（）：获取事务的隔离级别</span><br><span class="line">       int getTimeout（）：获取事务的超时时间</span><br><span class="line">       boolean isReadOnly（）：获取事务是否只读</span><br><span class="line">       int getPropagationBehavior（）：获取事务的传播行为</span><br></pre></td></tr></table></figure><h3 id="1-4-TransactionStatus"><a href="#1-4-TransactionStatus" class="headerlink" title="1.4 TransactionStatus"></a>1.4 TransactionStatus</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">描述某个时间点上事务的状态信息。该接口有 6 个方法：</span><br><span class="line">- void flush（）：刷新事务</span><br><span class="line">    - boolean hasSavepoint（）：获取是否存在保存点</span><br><span class="line">    - boolean isCompleted（）：获取事务是否完成</span><br><span class="line">    - boolean isNewTransaction（）：获取是否是新事务</span><br><span class="line">    - boolean isRollbackOnly（）：获取是否回滚</span><br><span class="line">    - void setRollbackOnly（）：设置事务回滚</span><br></pre></td></tr></table></figure><h2 id="2-基于-XML-的配置"><a href="#2-基于-XML-的配置" class="headerlink" title="2. 基于 XML 的配置"></a>2. 基于 XML 的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Spring 2.0 后提供了 tx 命名空间来配置事务，tx 命名空间下提供了 <span class="tag">&lt;<span class="name">tx:adivce</span>&gt;</span> 元素来配置事务的通知(增强处理)。</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务管理器,依赖于数据源--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">&lt;!-- 编写通知,对事务进行增强,需要编写对切入点和具体执行的事务细节--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- name 为方法名 ,* 表示任意方法 </span></span><br><span class="line"><span class="comment">指定方法名称：是业务核心方法</span></span><br><span class="line"><span class="comment">           read-only：是否是只读事务。默认 false，不只读。</span></span><br><span class="line"><span class="comment">           isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。</span></span><br><span class="line"><span class="comment">           propagation：指定事务的传播行为。</span></span><br><span class="line"><span class="comment">           timeout：指定超时时间。默认值为：-1。永不超时。</span></span><br><span class="line"><span class="comment">           rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。</span></span><br><span class="line"><span class="comment">           没有默认值，任何异常都回滚。</span></span><br><span class="line"><span class="comment">           no-rollback-for：用于指</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">rollback-for</span>=<span class="string">&quot;&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">  <span class="comment">&lt;!-- 编写 aop,让 spring 自动对目标生成代理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.spvain.dao.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-基于注解的配置"><a href="#3-基于注解的配置" class="headerlink" title="3. 基于注解的配置"></a>3. 基于注解的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring</title>
      <link href="2021/05/26/spring/spring/"/>
      <url>2021/05/26/spring/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 SpringMVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</span><br></pre></td></tr></table></figure><h3 id="1-1-优势"><a href="#1-1-优势" class="headerlink" title="1.1 优势"></a>1.1 优势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 方便解耦，简化开发</span><br><span class="line">通过 Spring 提供的 IoC 容器，可以将对象间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</span><br><span class="line">2. AOP 编程的支持</span><br><span class="line">通过 Spring 的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现的功能可以通过 AOP 轻松应付</span><br><span class="line">3. 声明式事务的支持</span><br><span class="line">可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。</span><br><span class="line">4. 方便程序的测试</span><br><span class="line">可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。</span><br><span class="line">5. 方便集成各种优秀框架</span><br><span class="line">Spring 可以降低各种框架的使用难度，提供了对各种优秀框架（Struts、Hibernate、Hessian、Quartz等）的直接支持</span><br><span class="line">6. 降低 JavaEE API 的使用难度</span><br><span class="line">Spring 对 JavaEE API（如 JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些 API 的使用难度大为降低。</span><br><span class="line">7. Java 源码是经典学习范例</span><br><span class="line">Spring 的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对 Java 设计模式灵活运用以及对 Java 技术的高深造诣。它的源代码无意是 Java 技术的最佳实践的范例。</span><br></pre></td></tr></table></figure><h3 id="1-2-体系结构"><a href="#1-2-体系结构" class="headerlink" title="1.2 体系结构"></a>1.2 体系结构</h3><p><img src="assets%5Cimage-20210512225118073.png" alt="image-20210512225118073" loading="lazy"></p><h2 id="2-Inversion-Of-Control"><a href="#2-Inversion-Of-Control" class="headerlink" title="2. Inversion Of Control"></a>2. Inversion Of Control</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制反转-Inversion Of Control</span><br><span class="line">是把创建的对象的主动权交给容器，由容器创建、管理对象</span><br><span class="line">ioc 的作用：</span><br><span class="line">削减计算机程序的耦合(解除我们代码中的依赖关系)。</span><br></pre></td></tr></table></figure><h3 id="2-1-耦合"><a href="#2-1-耦合" class="headerlink" title="2.1 耦合"></a>2.1 耦合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。耦合性存于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。</span><br><span class="line">在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是高内聚低耦合。</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">       （1） 内容耦合：当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。</span><br><span class="line">       （2） 公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</span><br><span class="line">       （3） 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</span><br><span class="line">       （4） 控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。</span><br><span class="line">       （5） 标记耦合：若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间存在一个标记耦合。</span><br><span class="line">       （6） 数据耦合：模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。</span><br><span class="line">       （7） 非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</span><br><span class="line">       </span><br><span class="line">    内聚与耦合</span><br><span class="line">内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</span><br></pre></td></tr></table></figure><h3 id="2-2-IOC-解决程序耦合"><a href="#2-2-IOC-解决程序耦合" class="headerlink" title="2.2 IOC 解决程序耦合"></a>2.2 IOC 解决程序耦合</h3><p>​    </p><h4 id="2-2-1-BeanFactory-和-ApplicationContext"><a href="#2-2-1-BeanFactory-和-ApplicationContext" class="headerlink" title="2.2.1 BeanFactory 和 ApplicationContext"></a>2.2.1 BeanFactory 和 ApplicationContext</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。</span><br><span class="line">BeanFactory 和 ApplicationContext 的区别：</span><br><span class="line">创建对象的时间点不一样。</span><br><span class="line">               ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。</span><br><span class="line">               BeanFactory：什么时候使用什么时候创建对象。</span><br></pre></td></tr></table></figure><h4 id="2-2-2-ApplicationContext-接口的实现类"><a href="#2-2-2-ApplicationContext-接口的实现类" class="headerlink" title="2.2.2 ApplicationContext 接口的实现类"></a>2.2.2 ApplicationContext 接口的实现类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件推荐使用这种</span><br><span class="line">FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</span><br><span class="line">AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</span><br></pre></td></tr></table></figure><h4 id="2-2-3-bean-标签"><a href="#2-2-3-bean-标签" class="headerlink" title="2.2.3 bean 标签"></a>2.2.3 bean 标签</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   作用：用于配置对象让 spring 来创建的。默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</span><br><span class="line">       属性：</span><br><span class="line">           id：给对象在容器中提供一个唯一标识。用于获取对象。</span><br><span class="line">           class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</span><br><span class="line">           scope：指定对象的作用范围。</span><br><span class="line">               * singleton :默认值，单例的.一个应用只有一个对象的实例。它的作用范围就是整个引用。</span><br><span class="line">                       生命周期：</span><br><span class="line">                           对象出生：当应用加载，创建容器时，对象就被创建了。</span><br><span class="line">                           对象活着：只要容器在，对象一直活着。</span><br><span class="line">                           对象死亡：当应用卸载，销毁容器时，对象就被销毁了</span><br><span class="line">               * prototype :多例的.每次访问对象时，都会重新创建对象实例。</span><br><span class="line">                       生命周期：</span><br><span class="line">                           对象出生：当使用对象时，创建新的对象实例。</span><br><span class="line">                           对象活着：只要对象在使用中，就一直活着。</span><br><span class="line">                           对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</span><br><span class="line">               * request</span><br><span class="line">               :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</span><br><span class="line">               * session</span><br><span class="line">               :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</span><br><span class="line">               * global session</span><br><span class="line">               :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.</span><br><span class="line">           init-method：指定类中的初始化方法名称。</span><br><span class="line">           destroy-method：指定类中销毁方法名称。</span><br><span class="line">        </span><br><span class="line">Bean 实例化的三种方式</span><br><span class="line">第一种方式：使用默认无参构造函数  </span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; /&gt;</span><br><span class="line">第二种方式：spring 管理静态工厂-使用静态工厂的方法创建对象</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; factory-method=&quot;&quot; /&gt;</span><br><span class="line">第三种方式：spring 管理实例工厂-使用实例工厂的方法创建对象</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot; /&gt;</span><br><span class="line">&lt;bead id=&quot;&quot; factory-bean=&quot;&quot; factory-method=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="3-Dependency-Injection"><a href="#3-Dependency-Injection" class="headerlink" title="3. Dependency Injection"></a>3. Dependency Injection</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">依赖注入：Dependency Injection。它是 spring 框架核心 ioc 的具体实现。ioc 解耦只是降低他们的依赖关系，但不会消除.</span><br><span class="line">方式：</span><br><span class="line">构造函数注入：</span><br><span class="line">                &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span><br><span class="line">                    &lt;constructor-arg name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                    &lt;constructor-arg index=&quot;&quot; value=&quot;&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                    &lt;constructor-arg type=&quot;&quot; ref=&quot;&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">         set 方法注入:</span><br><span class="line">         &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">                    &lt;property name=&quot;&quot; value=&quot;&quot;&gt;&lt;/property&gt;</span><br><span class="line">                     &lt;property name=&quot;&quot; ref=&quot;&quot;&gt;&lt;/property&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">          注入集合数据</span><br><span class="line">                List 结构的：</span><br><span class="line">                array,list,set</span><br><span class="line">                Map 结构的</span><br><span class="line">                map,entry,props,prop</span><br><span class="line">         </span><br></pre></td></tr></table></figure><h2 id="4-Annotation"><a href="#4-Annotation" class="headerlink" title="4. Annotation"></a>4. Annotation</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    @Component 此注解用于描述 Spring 中的 Bean，但它是一个泛化的概念，仅表示一个组件（bean），可用于任何层次。</span><br><span class="line">    作用：</span><br><span class="line">        把资源让 spring 来管理。相当于在 xml 中配置一个 bean。</span><br><span class="line">        属性：</span><br><span class="line">        value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。</span><br><span class="line">    @Repository 将数据访问层（DAO层）的类标识为 Spring 中的 Bean。功能与 @Component 相同。</span><br><span class="line">    @Service 将业务层（Service层）的类标识为 Spring 中的 Bean，功能与 @Component 相同。</span><br><span class="line">    @Controller 将控制层 （如 Spring MVC 的 Controller）的类标识为 Spring 中的 Bean。功能与 @Component 相同。@Autowired 对 Bean 的属性变量、属性的 setter 方法及构造方法进行标注，配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型进行装配。</span><br><span class="line">    @Resource 作用与 @Autowired 一样。@Resource 默认按照 Bean 实例名称进行装配。其有两个重要的属性：name 和 type。Spring 将 name 属性解析为 Bena实例名称，type 属性解析为 Bean 的实例类型。</span><br><span class="line">    @Qualifier 与 @Autowired 注解配合使用，将默认的按 Bean 类型装配修改为按 Bean 的实例名装配，Bean 的实例名由@Qualifier 注解的参数指定。</span><br><span class="line">    @Value </span><br><span class="line">    作用：</span><br><span class="line">        注入基本数据类型和 String 类型数据的</span><br><span class="line">        属性：</span><br><span class="line">              value：用于指定值</span><br><span class="line">    @Scope</span><br><span class="line">    作用：</span><br><span class="line">        指定 bean 的作用范围。</span><br><span class="line">        属性：</span><br><span class="line">        value：指定范围的值。取值：singleton prototype request session globalsession</span><br><span class="line">    @PostConstruct</span><br><span class="line">    作用：</span><br><span class="line">用于指定初始化方法</span><br><span class="line">@PreDestro</span><br><span class="line">作用：</span><br><span class="line">用于指定销毁方法。</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置扫描使用了注解的包--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="4-1-新增注解"><a href="#4-1-新增注解" class="headerlink" title="4.1 新增注解"></a>4.1 新增注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration </span><br><span class="line">作用：</span><br><span class="line">       用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用 AnnotationApplicationContext(有@Configuration 注解的类.class)。</span><br><span class="line">       属性：</span><br><span class="line">       value:用于指定配置类的字节码</span><br><span class="line">   @ComponentSca</span><br><span class="line">   作用：</span><br><span class="line">           用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：&lt;context:component-scan base-package=&quot;&quot;/&gt;是一样的。</span><br><span class="line">       属性：</span><br><span class="line">           basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。</span><br><span class="line">   @Bean</span><br><span class="line">  作用：</span><br><span class="line">       该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。</span><br><span class="line">       属性：</span><br><span class="line">       name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。</span><br><span class="line">   @PropertySource</span><br><span class="line">   作用：</span><br><span class="line">            用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到 properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。</span><br><span class="line">       属性：</span><br><span class="line">       value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath:</span><br><span class="line">   @Import</span><br><span class="line">   作用：</span><br><span class="line">        于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。</span><br><span class="line">       属性 </span><br><span class="line">        value[]：用于指定其他配置类的字节码。</span><br></pre></td></tr></table></figure><h2 id="5-Junit"><a href="#5-Junit" class="headerlink" title="5. Junit"></a>5. Junit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RunWith </span><br><span class="line">换原有运行器</span><br><span class="line">@ContextConfiguration</span><br><span class="line">指定 spring 的配置文件</span><br><span class="line">locations 属性：用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明</span><br><span class="line">classes 属性：用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。</span><br></pre></td></tr></table></figure><h2 id="6-Aspent-Oriented-Programming"><a href="#6-Aspent-Oriented-Programming" class="headerlink" title="6. Aspent-Oriented Programming"></a>6. Aspent-Oriented Programming</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">面向切面编程（面向方面编程）。是面向对象编程（OOP）的一种补充</span><br><span class="line">       作用：</span><br><span class="line">            在程序运行期间，不修改源码对已有方法进行增强。</span><br><span class="line">       优势：</span><br><span class="line">            减少重复代码</span><br><span class="line">            提高开发效率</span><br><span class="line">            维护方便</span><br><span class="line">  实现方式：动态代理</span><br><span class="line">  基于 JDK 的代理</span><br><span class="line">  基于 CGLIB 的代理</span><br></pre></td></tr></table></figure><h3 id="6-1-JDK-代理"><a href="#6-1-JDK-代理" class="headerlink" title="6.1 JDK 代理"></a>6.1 JDK 代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JDK 动态代理是通过 java.lang.reflect.Proxy 类实现的，可以通过调用 Proxy 类中的 newProxyInstance（）方法来创建代理对象。它的局限性在于动态代理的对象必须实现一个或多个接口。</span><br><span class="line">//1. 类加载器</span><br><span class="line">   ClassLoader classLoader=getClass().getClassLoader();</span><br><span class="line"></span><br><span class="line">   //2, 被代理对象实现的所有接口</span><br><span class="line">   Class[] targetInterfaces=xxxx.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">   Proxy.newProxyInstance(classLoader,targetInterfaces,InvocationHandler 接口的实现类);</span><br></pre></td></tr></table></figure><h3 id="6-2-CGLIB-代理"><a href="#6-2-CGLIB-代理" class="headerlink" title="6.2 CGLIB 代理"></a>6.2 CGLIB 代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CGLIB（Code Generation Library）一个高性能开源的代理生成包，是对没有实现接口的的类进行代理的。</span><br><span class="line"></span><br><span class="line">   Enhancer enhancer=new Enhancer();</span><br><span class="line">   //设置代理类</span><br><span class="line">   enhancer.setSuperclass(xxx.class);</span><br><span class="line">   // 设置回调方法 ：intercept（）</span><br><span class="line">   enhancer.setCallback(new MethodInterceptor()&#123;&#125;);</span><br><span class="line">   return (xxxx) enhancer.create();</span><br></pre></td></tr></table></figure><h3 id="6-3-AOP-术语"><a href="#6-3-AOP-术语" class="headerlink" title="6.3 AOP 术语"></a>6.3 AOP 术语</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Aspect（切面）切面通常指封装插入系统功能（如事务、日志等）的类</span><br><span class="line">Joninpoint（连接点）实际上是对象的一个操作，如方法的调用或异常的抛出。在 Spring AOP 指方法的调用Pointcut（切入点）指切面与程序流程的交叉点。通常指的是类或者方法名。</span><br><span class="line">Advice（通知/增强处理）在定义好的切入点处所需要执行的代码。可理解为切面类中的方法。</span><br><span class="line">Target Object（目标对象）指所有被通知的对象，也称为被增强对象。</span><br><span class="line">Proxy（代理）将通知应用到目标对象之后，被动态创建的对象。</span><br><span class="line">Weaving（织入）将你的代码出入到目标对象上，生成代理对象的过程。</span><br></pre></td></tr></table></figure><h3 id="6-4-PorxyFactoryBean"><a href="#6-4-PorxyFactoryBean" class="headerlink" title="6.4 PorxyFactoryBean"></a>6.4 PorxyFactoryBean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactoryBean 是 FactoryBean 接口的实现类，FactoryBean 负责实例化一个 Bean，ProxyFactoryBean 负责为其它 Bean 创建代理实例。在 Spring 中，使用ProxyFactoryBean 是创建 AOP 代理的基本方式。</span><br><span class="line">常用属性：</span><br><span class="line">arget 代理的目标对象</span><br><span class="line">proxyInterfaces 代理要实现的接口，如果是多个接口，按以下格式赋值：                                                              &lt;list&gt;                                                                                                                 &lt;value&gt;&lt;/value&gt;                                                                                               &lt;/list&gt;</span><br><span class="line">proxyTargetClass 是否对代理而不是接口，设置为 true 时，使用 CGLIB 代理</span><br><span class="line">interceptorNames 需要织入目标的 Advicesingleton 返回的代理是否时单实例，默认为 true</span><br><span class="line">optimize 当设置为 true 时，强制使用 CGLIB</span><br><span class="line"></span><br><span class="line"> &lt;bean id=&quot;&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; &gt;</span><br><span class="line">       &lt;!-- 指定目标对象--&gt;</span><br><span class="line">       &lt;property name=&quot;target&quot; ref=&quot;&quot; /&gt;</span><br><span class="line">       &lt;!-- 指定切面类--&gt;</span><br><span class="line">       &lt;property name=&quot;interceptorNames&quot; value=&quot;&quot;/&gt;</span><br><span class="line">       &lt;!-- 指定代理方式, true 为 CGLIB,false 为 JDK 动态代理--&gt;</span><br><span class="line">       &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="7-AspectJ"><a href="#7-AspectJ" class="headerlink" title="7. AspectJ"></a>7. AspectJ</h2><h3 id="7-1-XML"><a href="#7-1-XML" class="headerlink" title="7.1 XML"></a>7.1 XML</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">AspectJ 是一个基于 Java 语言的 AOP 框架，提供了强大的 AOP 功能。使用AspectJ 实现 AOP 有基于 XML 的声明式和基于注解的声明式。</span><br><span class="line">XML 配置</span><br><span class="line">aop:pointcut：</span><br><span class="line">           作用：</span><br><span class="line">           用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。</span><br><span class="line">           属性：</span><br><span class="line">               expression：用于定义切入点表达式。</span><br><span class="line">               表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br><span class="line">               id：用于给切入点表达式提供一个唯一标识</span><br><span class="line">               </span><br><span class="line">       aop:aspect:</span><br><span class="line">           作用：</span><br><span class="line">          用于配置切面。</span><br><span class="line">           属性：</span><br><span class="line">               id：给切面提供一个唯一标识。</span><br><span class="line">               ref：引用配置好的通知类 bean 的 id。</span><br><span class="line">               </span><br><span class="line">       aop:before</span><br><span class="line">           作用：</span><br><span class="line">           用于配置前置通知。指定增强的方法在切入点方法之前执行</span><br><span class="line">           属性：</span><br><span class="line">               method:用于指定通知类中的增强方法名称</span><br><span class="line">               ponitcut-ref：用于指定切入点的表达式的引用</span><br><span class="line">               poinitcut：用于指定切入点表达式</span><br><span class="line">               </span><br><span class="line">       aop:after-returning</span><br><span class="line">       作用：</span><br><span class="line">               用于配置后置通知</span><br><span class="line">           属性：</span><br><span class="line">               method：指定通知中方法的名称。</span><br><span class="line">               pointct：定义切入点表达式</span><br><span class="line">               pointcut-ref：指定切入点表达式的引用</span><br><span class="line">        aop:after-throwing</span><br><span class="line">           作用：</span><br><span class="line">               用于配置异常通知</span><br><span class="line">           属性：</span><br><span class="line">               method：指定通知中方法的名称。</span><br><span class="line">               pointct：定义切入点表达式</span><br><span class="line">               pointcut-ref：指定切入点表达式的引用</span><br><span class="line">        aop:after</span><br><span class="line">           作用：</span><br><span class="line">           用于配置最终通知</span><br><span class="line">           属性：</span><br><span class="line">               method：指定通知中方法的名称。</span><br><span class="line">               pointct：定义切入点表达式</span><br><span class="line">               pointcut-ref：指定切入点表达式的引用</span><br><span class="line">         aop:around：</span><br><span class="line">           作用：</span><br><span class="line">               用于配置环绕通知</span><br><span class="line">           属性：</span><br><span class="line">               method：指定通知中方法的名称。</span><br><span class="line">               pointct：定义切入点表达式</span><br><span class="line">               pointcut-ref：指定切入点表达式的引用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-2-注解"><a href="#7-2-注解" class="headerlink" title="7.2 注解"></a>7.2 注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut</span><br><span class="line">      作用：</span><br><span class="line">       指定切入点表达式</span><br><span class="line">      属性：</span><br><span class="line">        value：指定表达式的内容</span><br><span class="line">@Aspect </span><br><span class="line">作用：</span><br><span class="line">把当前类声明为切面类。</span><br><span class="line">@Before</span><br><span class="line">       作用：</span><br><span class="line">       把当前方法看成是前置通知。</span><br><span class="line">       属性：</span><br><span class="line">       value：用于指定切入点表达式，还可以指定切入点表达式的引用。</span><br><span class="line">    @AfterReturning</span><br><span class="line">       作用：</span><br><span class="line">        把当前方法看成是后置通知。</span><br><span class="line">       属性：</span><br><span class="line">       value：用于指定切入点表达式，还可以指定切入点表达式的引用</span><br><span class="line">    @AfterThrowing</span><br><span class="line">       作用：</span><br><span class="line">     把当前方法看成是异常通知。</span><br><span class="line">       属性：</span><br><span class="line">       value：用于指定切入点表达式，还可以指定切入点表达式的引用</span><br><span class="line">     @After</span><br><span class="line">       作用：</span><br><span class="line">       把当前方法看成是最终通知。</span><br><span class="line">       属性：</span><br><span class="line">       value：用于指定切入点表达式，还可以指定切入点表达式的引用</span><br><span class="line">     @Around</span><br><span class="line">       作用：</span><br><span class="line">       把当前方法看成是环绕通知。</span><br><span class="line">       属性：</span><br><span class="line">       value：用于指定切入点表达式，还可以指定切入点表达式的引用</span><br><span class="line">       </span><br><span class="line">     &lt;!--  启动基于注解声明式AspectJ支持--&gt;</span><br><span class="line">     &lt;aop:aspectj-autoproxy /&gt; </span><br><span class="line">     在 XML 中开启注解</span><br><span class="line">     @EnableAspectJAutoProxy  </span><br><span class="line">    在配置类开启注解支持</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/spring/spring-mybatis/"/>
      <url>2021/05/26/spring/spring-mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-mybatis"><a href="#spring-mybatis" class="headerlink" title="spring-mybatis"></a>spring-mybatis</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring 整合 mybatis 是需要导入 mybatis-spring 依赖包</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyBatis-Spring 提供了自动扫描的形式来配置 MyBatis 中的映射器，采用 MapperScannerConfigurer 类，它在 Spring 配置文件中可以配置的属性：</span><br><span class="line">basePackage：指定映射接口文件所在的包路径，当需扫描多个包路径时，可以用分号或逗号分隔。</span><br><span class="line">sqlSessionFactoryBeanName：指定在 Spring 中定义的 SqlSessionFactory 的 Bean 名称</span><br><span class="line">sqlSessionTemplateBeanName：指定在 Spring 定义的 SqlSessionTemplate 的 Bean 名称</span><br><span class="line">markerInterface：指定创建映射器的接口</span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring-mvc</title>
      <link href="2021/05/26/spring/spring-mvc/"/>
      <url>2021/05/26/spring/spring-mvc/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-mvc"><a href="#spring-mvc" class="headerlink" title="spring-mvc"></a>spring-mvc</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Spring MVC 是 Spring 提供的一个实现 Web MVC 设计模式的轻量级 Web 框架，它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful 编程风格的请求。</span><br><span class="line">特点：</span><br><span class="line">         1、清晰的角色划分：</span><br><span class="line">             前端控制器（DispatcherServlet）</span><br><span class="line">             请求到处理器映射（HandlerMapping）</span><br><span class="line">             处理器适配器（HandlerAdapter）</span><br><span class="line">             视图解析器（ViewResolver）</span><br><span class="line">             处理器或页面控制器（Controller）</span><br><span class="line">             验证器（ Validator）</span><br><span class="line">             命令对象（Command 请求参数绑定到的对象就叫命令对象）</span><br><span class="line">             表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。</span><br><span class="line">         2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。</span><br><span class="line">         3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</span><br><span class="line">         4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</span><br><span class="line">         5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。</span><br><span class="line">         6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。</span><br><span class="line">         7、功能强大的数据验证、格式化、绑定机制。</span><br><span class="line">         8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</span><br><span class="line">         9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</span><br><span class="line">         10、强大的 JSP 标签库，使 JSP 编写更容易。</span><br><span class="line">         ………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配</span><br><span class="line">         置支持等等。</span><br></pre></td></tr></table></figure><h3 id="1-1-三层模型"><a href="#1-1-三层模型" class="headerlink" title="1.1 三层模型"></a>1.1 三层模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表现层：</span><br><span class="line">它负责接收客户端请求，向客户端响应结果，通常客户端使用 http 协议请求 web 层，web 需要接收 http 请求，完成 http 响应。表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）</span><br><span class="line">业务层：</span><br><span class="line">    它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制）</span><br><span class="line">持久层：</span><br><span class="line">负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。</span><br></pre></td></tr></table></figure><h3 id="1-2-MVC-模型"><a href="#1-2-MVC-模型" class="headerlink" title="1.2 MVC 模型"></a>1.2 MVC 模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：</span><br><span class="line">Model（模型）：</span><br><span class="line">通常指的就是我们的数据模型。作用一般情况下用于封装数据。</span><br><span class="line">View（视图）：</span><br><span class="line">通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。通常视图是依据模型数据创建的。</span><br><span class="line">Controller（控制器）：</span><br><span class="line">是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。</span><br></pre></td></tr></table></figure><h2 id="2-工作流程"><a href="#2-工作流程" class="headerlink" title="2. 工作流程"></a>2. 工作流程</h2><img src="spring-mvc.assets/image-20210410155114998.png" alt="image-20210410155114998" style="zoom: 67%;" / loading="lazy"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 用户通过浏览器向服务器发送请求，请求会被 Spring MVC 的前端控制器 DispatcherServlet 拦截。</span><br><span class="line">2. DispatcherServlet 拦截请求后，会调用 HandlerMapping 处理器映射器</span><br><span class="line">3. HandlerMapping：处理映射器根据 URL 找到具体的处理器，生成处理器对象及处理器拦截器一并返回给 DispatcherServlet</span><br><span class="line">4. DispatcherServlet 会通过返回信息选择合适的 HandlerAdapter。</span><br><span class="line">5. HandlerAdapter 调用并执行 Handler（程序中编写的 Controller 类，也称为后端控制器）</span><br><span class="line">6. Controller 执行完成后，返回一个 ModelAndView 对象，该对象包含视图名或包含模型和视图名</span><br><span class="line">7. HandlerAdapte r将 ModelAndView 对象返回给 DispatcherServlet</span><br><span class="line">8. DispatcherServlet 根据 ModelAndView 对象选择一个合适的 ViewReslover</span><br><span class="line">9. ViewReslover 解析后，向 DispatcherServlet 中返回具体的 View</span><br><span class="line">10. DispatcherServlet 对 View 进行渲染（将模型数据填充至视图中）</span><br><span class="line">11. 视图渲染结果返回给客户端浏览器显示</span><br></pre></td></tr></table></figure><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><h3 id="3-1-spring-mvc-xml"><a href="#3-1-spring-mvc-xml" class="headerlink" title="3.1 spring-mvc.xml"></a>3.1 spring-mvc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 配置处理器Handle,映射&quot;/hello&quot;请求 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 处理映射器,将处理器Handle的name作为url进行查找--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 处理适配器,配置处理器中handleRequest()方法的调用--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 视图解析器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 默认的注解映射的支持 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">ViewResolver(视图解析器)</span><br><span class="line">负责解析视图</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">org.springframework.stereotype.Controller 注解类型用来指示 Spring 类的实例是一个控制器，形式为@Controller </span><br><span class="line">@RequestMapping</span><br><span class="line">RequestMapping 注解用来映射一个请求或一个方法，注解形式为 @RequestMapping，可在一个类或方法上使用。</span><br><span class="line">@RequestParam</span><br><span class="line">作用：</span><br><span class="line">      把请求中指定名称的参数给控制器中的形参赋值。</span><br><span class="line">       属性：</span><br><span class="line">               value：请求参数中的名称。</span><br><span class="line">               required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</span><br><span class="line">@RequestHeader</span><br><span class="line">作用：</span><br><span class="line">       用于获取请求消息头。</span><br><span class="line">       属性：</span><br><span class="line">            value：提供消息头名称，required：是否必须有此消息头</span><br><span class="line">@CookieValue</span><br><span class="line">作用：</span><br><span class="line">       用于把指定 cookie 名称的值传入控制器方法参数。</span><br><span class="line">       属性：</span><br><span class="line">           value：指定 cookie 的名称。required：是否必须有此 cookie</span><br><span class="line">@ModelAttribute</span><br><span class="line">作用：</span><br><span class="line">           该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。出现在参数上，获取指定的数据给参数赋值。</span><br><span class="line">       属性：</span><br><span class="line">      value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key</span><br><span class="line">@RequestBody</span><br><span class="line">作用：</span><br><span class="line">用于获取请求体内容。直接使用得到是 key=value&amp;key=value...结构的数据</span><br><span class="line">       属性：</span><br><span class="line">           required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</span><br><span class="line">@SessionAttribute</span><br><span class="line">作用：</span><br><span class="line">     用于多次执行控制器方法间的参数共享。</span><br><span class="line">       属性：</span><br><span class="line">           value：用于指定存入的属性名称，type：用于指定存入的数据类型。</span><br><span class="line">@PathVaribale</span><br><span class="line">作用：</span><br><span class="line">           用于绑定 url 中的占位符。例如：请求 url 中 /delete/&#123;id&#125;，这个&#123;id&#125;就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</span><br><span class="line">       属性：</span><br><span class="line">           value：用于指定 url 中占位符名称。required：是否必须提供占位符。</span><br><span class="line">组合注释</span><br><span class="line">       在 Spring 框架 4.3 版本后,引入了组合注解，简化了常用的 HTTP 方法的映射，并且更好地表达了被注解方法地语义。</span><br><span class="line">       - @GetMapping：匹配 GET 方式地请</span><br><span class="line">       - @PostMapping：匹配 POST 方式的请求</span><br><span class="line">       - @PutMapping：匹配 PUT 方式的请求</span><br><span class="line">       - @DeleteMapping：匹配 DELETE 方式的请求</span><br><span class="line">       - @PatchMapping：匹配 PATCH 方式的请求。</span><br></pre></td></tr></table></figure><h3 id="3-2-web-xml"><a href="#3-2-web-xml" class="headerlink" title="3.2 web.xml"></a>3.2 web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置前端过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 初始化时加载配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-confiig.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标识容器在启动时立即加载Servlet--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 拦截所有URL,并交给DispatcherServlet处理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    基本类型参数：</span><br><span class="line">    包括基本类型和 String 类型，要求我们的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)</span><br><span class="line">    POJO 类型参数：</span><br><span class="line">    包括实体类，以及关联的实体类，要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</span><br><span class="line">    数组和集合类型参数：</span><br><span class="line">        包括 List 结构和 Map 结构的集合（包括数组）</span><br><span class="line">SpringMVC 绑定请求参数是自动实现的，但是要想使用，必须遵循使用要求。</span><br></pre></td></tr></table></figure><h3 id="4-1-自定义类型转换"><a href="#4-1-自定义类型转换" class="headerlink" title="4.1 自定义类型转换"></a>4.1 自定义类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">实现 Converter 接口</span><br><span class="line">在 spring 配置文件中配置类型转换器。</span><br><span class="line"> &lt;!-- 配置类型转换器工厂 --&gt;</span><br><span class="line">    &lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span><br><span class="line">        &lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;!-- 配置自定义类型转换器 --&gt;</span><br><span class="line">                &lt;bean class=&quot;&quot;&gt;&lt;/bean&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;!-- 引用自定义类型转换器 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven conversion-service=&quot;converterService&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-参数乱码"><a href="#5-参数乱码" class="headerlink" title="5. 参数乱码"></a>5. 参数乱码</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">在 web.xml 中配置一个过滤器</span><br><span class="line"><span class="comment">&lt;!-- 配置 springMVC 编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span> org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 启动过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 过滤所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-过滤静态资源"><a href="#6-过滤静态资源" class="headerlink" title="6. 过滤静态资源"></a>6. 过滤静态资源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 springmvc 的配置文件中可以配置，静态资源不过滤：</span><br><span class="line">&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;</span><br><span class="line">&lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;</span><br><span class="line">&lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;</span><br><span class="line">&lt;mvc:resources location=&quot;/scripts/&quot; mapping=&quot;/javascript/**&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="7-REST-风格-URL"><a href="#7-REST-风格-URL" class="headerlink" title="7. REST 风格 URL"></a>7. REST 风格 URL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。</span><br><span class="line">restful 的优点</span><br><span class="line">它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</span><br><span class="line">restful 的特性：</span><br><span class="line">       资源（Resources）：网络上的一个实体，或者说是网络上的一个具体信息。</span><br><span class="line">       表现层（Representation）：把资源具体呈现出来的形式，叫做它的表现层 （Representation）。</span><br><span class="line">       状态转化（State Transfer）：每 发出一个请求，就代表了客户端和服务器的一次交互过程。</span><br></pre></td></tr></table></figure><h2 id="8-数据响应"><a href="#8-数据响应" class="headerlink" title="8. 数据响应"></a>8. 数据响应</h2><h3 id="8-1-forward"><a href="#8-1-forward" class="headerlink" title="8.1 forward"></a>8.1 forward</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forward:url：路径必须写成实际视图 url，</span><br><span class="line">相当于 request.getRequestDispatcher(&quot;url&quot;).forward(request,response)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-Redirect"><a href="#8-2-Redirect" class="headerlink" title="8.2 Redirect"></a>8.2 Redirect</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redirect:url ：路径为是相对路径</span><br><span class="line">相当于 response.sendRedirect(url)</span><br></pre></td></tr></table></figure><h3 id="8-3-ResponseBody"><a href="#8-3-ResponseBody" class="headerlink" title="8.3 @ResponseBody"></a>8.3 @ResponseBody</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    作用：</span><br><span class="line">        该注解用于将 Controller 的方法返回的对象，通过 HttpMessageConverter 接口转换为指定格式的数据如：json,xml 等，通过 Response 响应给客户端。Springmvc 默认用 MappingJacksonHttpMessageConverter 对 json 数据进行转换，需要加入</span><br><span class="line">jackson 的包。</span><br></pre></td></tr></table></figure><h2 id="9-文件上传与下载"><a href="#9-文件上传与下载" class="headerlink" title="9. 文件上传与下载"></a>9. 文件上传与下载</h2><h3 id="9-1-上传"><a href="#9-1-上传" class="headerlink" title="9.1 上传"></a>9.1 上传</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form 表单的 enctype 取值必须是：multipart/form-data</span><br><span class="line">method 属性取值必须是 Post，</span><br><span class="line">提供一个文件选择域&lt;input type=”file” /&gt;</span><br></pre></td></tr></table></figure><h4 id="9-1-1-传统方式"><a href="#9-1-1-传统方式" class="headerlink" title="9.1.1 传统方式"></a>9.1.1 传统方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">上传的文件和访问的应用存在于同一台服务器上。并且上传完成之后，浏览器可能跳转。</span><br><span class="line">使用 Commons-fileupload 组件实现文件上传，需要导入该组件相应的支撑 jar 包：Commons-fileupload 和</span><br><span class="line">commons-io。</span><br><span class="line">MultipartResolver 是一个接口对象，需要通过它的实现类 CommonsMultipartResolver 来完成文件的上传。</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置文件上传解析器 --&gt;</span><br><span class="line">&lt;!-- id 的值是固定的--&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot;  class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">    &lt;!-- 设置上传文件的最大尺寸为 5MB --&gt;</span><br><span class="line">    &lt;property name=&quot;maxUploadSize&quot;&gt;</span><br><span class="line">    &lt;value&gt;5242880&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean</span><br><span class="line"></span><br><span class="line">//获取原始文件名</span><br><span class="line">String uploadFileName = uploadFile.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">//使用 MulitpartFile 接口中方法，把上传的文件写到指定位置</span><br><span class="line">uploadFile.transferTo(new File(file,name));</span><br></pre></td></tr></table></figure><h3 id="9-2-下载"><a href="#9-2-下载" class="headerlink" title="9.2 下载"></a>9.2 下载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//设置响应头</span><br><span class="line">HttpHeaders httpHeaders=new HttpHeaders();</span><br><span class="line">//通知浏览器以下载的方式打开文件</span><br><span class="line">httpHeaders.setContentDispositionFormData(&quot;attachment&quot;,filename);</span><br><span class="line">//定义以流的形式返回文件数据</span><br><span class="line">httpHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line">//使用Spring MVC框架的 ResponseEntity 对象封转返回下载数据</span><br><span class="line">return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(filePath),httpHeaders, HttpStatus.OK);</span><br></pre></td></tr></table></figure><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</span><br><span class="line">    自定义异常处理：需实现 HandlerExceptionResolver 接口</span><br><span class="line">    </span><br><span class="line">   &lt;!-- 配置自定义异常处理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="11-拦截器"><a href="#11-拦截器" class="headerlink" title="11. 拦截器"></a>11. 拦截器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理</span><br><span class="line">过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用，过滤器在 url-pattern 中配置了/* 之后，可以对所有要访问的资源拦截。</span><br><span class="line">   拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用，拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的。</span><br><span class="line">   自定义拦截器， 要求必须实现：HandlerInterceptor 接口。</span><br><span class="line">   </span><br><span class="line">    &lt;!-- 配置拦截器--&gt;</span><br><span class="line">   &lt;mvc:interceptors&gt;</span><br><span class="line">       &lt;!-- 拦截器1--&gt;</span><br><span class="line">       &lt;mvc:interceptor&gt;</span><br><span class="line">           &lt;!-- 配置拦截的路径--&gt;</span><br><span class="line">           &lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">           &lt;!-- 配置不需要拦截的路径--&gt;</span><br><span class="line">           &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt;</span><br><span class="line">           &lt;bean class=&quot;&quot;/&gt;</span><br><span class="line">       &lt;/mvc:interceptor&gt;</span><br><span class="line">   &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/LeetCode/%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97/"/>
      <url>2021/05/26/LeetCode/%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; inQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; outQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> inOut=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inOut)&#123;</span><br><span class="line">        inQueue.add(x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        outQueue.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inOut)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (inQueue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                outQueue.add(inQueue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            inOut=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> inQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!outQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (outQueue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                inQueue.add(outQueue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            inOut=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> outQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the top element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inOut)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (inQueue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                outQueue.add(inQueue.poll());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> inQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!outQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (outQueue.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                inQueue.add(outQueue.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> outQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether the stack is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inQueue.isEmpty() &amp;&amp; outQueue.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\队列\队列.assets\image-20210508080228894.png" alt="image-20210508080228894" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/LeetCode/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/"/>
      <url>2021/05/26/LeetCode/%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode curr = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode root = curr;</span><br><span class="line">    <span class="keyword">int</span> secondNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode();</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        total = (l1.val + l2.val) + secondNum;</span><br><span class="line">        secondNum = total / <span class="number">10</span>;</span><br><span class="line">        curr.val = total % <span class="number">10</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode();</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            total = (l1.val) + secondNum;</span><br><span class="line">            secondNum = total / <span class="number">10</span>;</span><br><span class="line">            curr.val = total % <span class="number">10</span>;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> ListNode();</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            total = (l2.val) + secondNum;</span><br><span class="line">            secondNum = total / <span class="number">10</span>;</span><br><span class="line">            curr.val = total % <span class="number">10</span>;</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(secondNum != <span class="number">0</span>)&#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode();</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        curr.val=secondNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="%E9%93%BE%E8%A1%A8.assets/image-20210516231148518.png" alt="image-20210516231148518" loading="lazy"></p><h4 id="083-删除排序链表中的重复元素"><a href="#083-删除排序链表中的重复元素" class="headerlink" title="083. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">083. 删除排序链表中的重复元素</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    ListNode newHead = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.val == head.val) &#123;</span><br><span class="line">            prev.next = head.next;</span><br><span class="line">            head = prev.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\链表.assets\image-20210507073313793.png" alt="image-20210507073313793" loading="lazy"></p><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    ListNode quick=head.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (quick!=<span class="keyword">null</span> &amp;&amp; quick.next !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(quick == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        quick=quick.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\链表.assets\image-20210507070450372.png" alt="image-20210507070450372" loading="lazy"></p><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode newHead = head;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            prev.next = head.next;</span><br><span class="line">            head = prev.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(newHead.val == val)&#123;</span><br><span class="line">        newHead=newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\链表.assets\image-20210507072748277.png" alt="image-20210507072748277" loading="lazy"></p><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head ==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode newHead=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp=head.next;</span><br><span class="line">        head.next=newHead;</span><br><span class="line">        newHead=head;</span><br><span class="line">        head=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next=newHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\链表.assets\image-20210507070530958.png" alt="image-20210507070530958" loading="lazy"></p><h4 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = node;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\链表.assets\image-20210507070601296.png" alt="image-20210507070601296" loading="lazy"></p><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还可以使用快慢指针 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; half; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\链表.assets\image-20210507074400474.png" alt="image-20210507074400474" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/LeetCode/%E6%A0%88/%E6%A0%88/"/>
      <url>2021/05/26/LeetCode/%E6%A0%88/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h4 id="020-有效的括号"><a href="#020-有效的括号" class="headerlink" title="020. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">020. 有效的括号</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(chars[i]))&#123;</span><br><span class="line">            stack.push(chars[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Character character = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(chars[i] != map.get(character))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%A0%88.assets/image-20210507080411720.png" alt="image-20210507080411720" loading="lazy"></p><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (tokens[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                stack.push(b + a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                stack.push(b - a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                stack.push(b / a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                a = stack.pop();</span><br><span class="line">                b = stack.pop();</span><br><span class="line">                stack.push(b * a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                stack.push(Integer.valueOf(tokens[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%A0%88.assets/image-20210507104757417.png" alt="image-20210507104757417" loading="lazy"></p><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> outStack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> outStack.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="%E6%A0%88.assets/image-20210507232347901.png" alt="image-20210507232347901" loading="lazy"></p><h4 id="224-基本计算器-未完成"><a href="#224-基本计算器-未完成" class="headerlink" title="224. 基本计算器 未完成"></a><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a> 未完成</h4><h4 id="856-括号的分数-未完成"><a href="#856-括号的分数-未完成" class="headerlink" title="856. 括号的分数 未完成"></a><a href="https://leetcode-cn.com/problems/score-of-parentheses/">856. 括号的分数</a> 未完成</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/LeetCode/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/"/>
      <url>2021/05/26/LeetCode/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        num = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(num),i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%95%B0%E7%BB%84.assets/image-20210507070632077.png" alt="image-20210507070632077" loading="lazy"></p><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] indexs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    Arrays.fill(indexs, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> li = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pi = indexs[chars[i]];</span><br><span class="line">        <span class="keyword">if</span> (pi &gt;= li) &#123;</span><br><span class="line">            li = pi + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexs[chars[i]] = i;</span><br><span class="line">        max = Math.max(max, (i - li + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%95%B0%E7%BB%84.assets/image-20210507070659085.png" alt="image-20210507070659085" loading="lazy"></p><h4 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> second=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;n ; i++) &#123;</span><br><span class="line">        second+=first;</span><br><span class="line">        first=second-first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E6%95%B0%E7%BB%84.assets/image-20210507070726735.png" alt="image-20210507070726735" loading="lazy"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/26/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/05/26/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h4 id="094-二叉树的中序遍历"><a href="#094-二叉树的中序遍历" class="headerlink" title="094. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">094. 二叉树的中序遍历</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Set&lt;TreeNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode treeNode = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(treeNode.left) &amp;&amp; treeNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(treeNode);</span><br><span class="line">                stack.push(treeNode.left);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(treeNode);</span><br><span class="line">                list.add(treeNode.val);</span><br><span class="line">                <span class="keyword">if</span>(treeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getTreeNodeVal(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getTreeNodeVal</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    getTreeNodeVal(node.left, list);</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    getTreeNodeVal(node.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\97797\OneDrive\笔记\LeetCode\二叉树\二叉树.assets\image-20210509073229590-1620600470040.png" alt="image-20210509073229590" loading="lazy"></p><h4 id="101-对称二叉树-未完成"><a href="#101-对称二叉树-未完成" class="headerlink" title="101. 对称二叉树 未完成"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a> 未完成</h4><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levelCount=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> levelCount;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> count=queue.size();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode treeNode = queue.poll();</span><br><span class="line">        System.out.println(treeNode);</span><br><span class="line">        list.add(treeNode.val);</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(treeNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(treeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            count=queue.size();</span><br><span class="line">            levelCount.add(list);</span><br><span class="line">            list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> levelCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets%5Cimage-20210509091800226.png" alt="image-20210509091800226" loading="lazy"></p><h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getMaxDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left += getMaxDepth(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right += getMaxDepth(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210509092657328.png" alt="image-20210509092657328" loading="lazy"></p><h4 id="106-从中序与后序遍历序列构造二叉树-未完成"><a href="#106-从中序与后序遍历序列构造二叉树-未完成" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树  未完成"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>  未完成</h4><h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levelCount=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> levelCount;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> count=queue.size();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode treeNode = queue.poll();</span><br><span class="line">        System.out.println(treeNode);</span><br><span class="line">        list.add(treeNode.val);</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(treeNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(treeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">            count=queue.size();</span><br><span class="line">            levelCount.add(<span class="number">0</span>,list);</span><br><span class="line">            list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> levelCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210510065702707.png" alt="image-20210510065702707" loading="lazy"></p><h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    treeNodeToLink(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">treeNodeToLink</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode right = node.right;</span><br><span class="line">        TreeNode left = node.left;</span><br><span class="line">        node.right = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (left.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left = left.right;</span><br><span class="line">        &#125;</span><br><span class="line">        left.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    treeNodeToLink(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210511074810742.png" alt="image-20210511074810742" loading="lazy"></p><h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Set&lt;TreeNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode treeNode = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(treeNode)) &#123;</span><br><span class="line">            set.add(treeNode);</span><br><span class="line">            list.add(treeNode.val);</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!set.contains(treeNode.left) &amp;&amp; treeNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            stack.push(treeNode.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(treeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getTreeNodeVal(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getTreeNodeVal</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    getTreeNodeVal(node.left, list);</span><br><span class="line">    getTreeNodeVal(node.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210511064730421.png" alt="image-20210511064730421" loading="lazy"></p><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Set&lt;TreeNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode treeNode = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (treeNode.left != <span class="keyword">null</span> &amp;&amp; !set.contains(treeNode.left)) &#123;</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            stack.push(treeNode.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (treeNode.right != <span class="keyword">null</span> &amp;&amp; !set.contains(treeNode.right)) &#123;</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            stack.push(treeNode.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(treeNode.val);</span><br><span class="line">            set.add(treeNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    getTreeNodeVal(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getTreeNodeVal</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    getTreeNodeVal(node.left, list);</span><br><span class="line">    getTreeNodeVal(node.right, list);</span><br><span class="line">    list.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210509074558190-1620600664531.png" alt="image-20210509074558190" loading="lazy"></p><h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode newRoot = root;</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode treeNode = queue.poll();</span><br><span class="line"></span><br><span class="line">        TreeNode temp=treeNode.right;</span><br><span class="line">        treeNode.right=treeNode.left;</span><br><span class="line">        treeNode.left=temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(treeNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(treeNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210508081144715.png" alt="image-20210508081144715" loading="lazy"></p><h4 id="589-N-叉树的前序遍历"><a href="#589-N-叉树的前序遍历" class="headerlink" title="589. N 叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; nodeVals = getNodeVal(root, list);</span><br><span class="line">    <span class="keyword">return</span> nodeVals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getNodeVal</span><span class="params">(Node node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    List&lt;Node&gt; children = node.children;</span><br><span class="line">    <span class="keyword">for</span> (Node child : children) &#123;</span><br><span class="line">        getNodeVal(child,list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210511064730421-1620690699962.png" alt="image-20210511064730421" loading="lazy"></p><h4 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getDepth(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">1</span>;</span><br><span class="line">    List&lt;Node&gt; childrens= node.children;</span><br><span class="line">    <span class="keyword">for</span> (Node children : childrens) &#123;</span><br><span class="line">        <span class="keyword">int</span> length = getDepth(children);</span><br><span class="line">        depth=Math.max(length +<span class="number">1</span> ,depth);            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210511070231219.png" alt="image-20210511070231219" loading="lazy"></p><h4 id="590-N-叉树的后序遍历"><a href="#590-N-叉树的后序遍历" class="headerlink" title="590. N 叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; nodeVals = getNodeVal(root, list);</span><br><span class="line">    <span class="keyword">return</span> nodeVals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getNodeVal</span><span class="params">(Node node, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    List&lt;Node&gt; children = node.children;</span><br><span class="line">    <span class="keyword">for</span> (Node child : children) &#123;</span><br><span class="line">        getNodeVal(child,list);</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(node.val);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/image-20210511065006071.png" alt="image-20210511065006071" loading="lazy"></p><h4 id="662-二叉树最大宽度-未完成"><a href="#662-二叉树最大宽度-未完成" class="headerlink" title="662. 二叉树最大宽度 未完成"></a><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a> 未完成</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发</title>
      <link href="2021/05/26/Java/Java-03_%E5%B9%B6%E5%8F%91/"/>
      <url>2021/05/26/Java/Java-03_%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h1><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    并发：指两个或多个事件在同一个时间段内发</span><br><span class="line">    进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</span><br><span class="line">    线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</span><br><span class="line">    线程调度：</span><br><span class="line">    分时调度</span><br><span class="line">        所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</span><br><span class="line">        抢占式调度</span><br><span class="line">        优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。可以设置线程的优先级，提高抢占几率</span><br><span class="line">    三种使用线程的方法：</span><br><span class="line">        实现 Runnable 接口；</span><br><span class="line">        实现 Callable 接口；</span><br><span class="line">        继承 Thread 类。</span><br><span class="line">Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，最终还是要通过 Thread 来调用</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="1-1-Runable"><a href="#1-1-Runable" class="headerlink" title="1.1 Runable"></a>1.1 Runable</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现 Runable 接口并重写 run（）方法，通过 Thread 实例运行 </span><br></pre></td></tr></table></figure><h3 id="1-2-Callable"><a href="#1-2-Callable" class="headerlink" title="1.2 Callable"></a>1.2 Callable</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现 Callable 接口并重写 call（）方法，该方法可以有返回值，返回值通过 FutureTask 封装</span><br></pre></td></tr></table></figure><h3 id="1-3-Thread"><a href="#1-3-Thread" class="headerlink" title="1.3 Thread"></a>1.3 Thread</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">继承并重写 run（）方法，该实例调用 start（）方法启动一个新线程，虚拟机会把该线程放入就绪队列中，当线程被调度时，执行 run（）方法</span><br></pre></td></tr></table></figure><h3 id="1-4-接口与继承"><a href="#1-4-接口与继承" class="headerlink" title="1.4 接口与继承"></a>1.4 接口与继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接口比继承所具有的优势：</span><br><span class="line">    1. 适合多个相同的程序代码的线程去共享同一个资源。</span><br><span class="line">    2. 可以避免java中的单继承的局限性。</span><br><span class="line">    3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</span><br><span class="line">    4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</span><br></pre></td></tr></table></figure><h2 id="2-线程机制"><a href="#2-线程机制" class="headerlink" title="2. 线程机制"></a>2. 线程机制</h2><h3 id="2-1-Executor"><a href="#2-1-Executor" class="headerlink" title="2.1 Executor"></a>2.1 Executor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。</span><br><span class="line">Executor 的三个类别：</span><br><span class="line">CachedThreadPool：一个任务创建一个线程</span><br><span class="line">FixedThreadPool：所有任务只使用固定大小的线程</span><br><span class="line">SigleThreadExecutor：单个</span><br></pre></td></tr></table></figure><h3 id="2-2-Daemon"><a href="#2-2-Daemon" class="headerlink" title="2.2 Daemon"></a>2.2 Daemon</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</span><br><span class="line">当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main（）就是一个非守护线程。</span><br><span class="line">在线程启动之前可以使用 setDaemon（）方法把当前线程设置为守护线程</span><br></pre></td></tr></table></figure><h3 id="2-3-sleep"><a href="#2-3-sleep" class="headerlink" title="2.3 sleep"></a>2.3 sleep</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(millisex) 方法把当前正在执行的线程让其休眠，但该方法可能会抛出 InterruptedException，又因异常不能跨线程传播，只能在本地处理</span><br></pre></td></tr></table></figure><h3 id="2-4-yield"><a href="#2-4-yield" class="headerlink" title="2.4 yield"></a>2.4 yield</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 Thread。yield（）方法标识当前线程已完成生命周期中最重要的部分，建议可以切换其它线程来执行</span><br></pre></td></tr></table></figure><h2 id="3-中断"><a href="#3-中断" class="headerlink" title="3. 中断"></a>3. 中断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</span><br></pre></td></tr></table></figure><h3 id="3-1-InterruptedException"><a href="#3-1-InterruptedException" class="headerlink" title="3.1 InterruptedException"></a>3.1 InterruptedException</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用的线程的 interrupt（）方法中断线程，如果该线程处于阻塞、期限等待、无限等待状态，并会抛出 InterruptedException，才会提前结束线程。但不能中断 I/O 阻塞和 synchronized 锁阻塞</span><br></pre></td></tr></table></figure><h3 id="3-2-interrupted"><a href="#3-2-interrupted" class="headerlink" title="3.2 interrupted"></a>3.2 interrupted</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果线程的 run（）方法执行的是一个无限循环，并且没有能够抛出 InterruptedException 的操作，调用 interrupted（）方法无法让线程提前结束</span><br></pre></td></tr></table></figure><h3 id="3-3-Executor-的中断"><a href="#3-3-Executor-的中断" class="headerlink" title="3.3 Executor 的中断"></a>3.3 Executor 的中断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 Executor 的 shutdown（）方法会等待线程全部执行完毕再关闭</span><br><span class="line">调用 shutdownNow（）方法，相当于调用每个线程的 interrupted（）方法</span><br><span class="line">若想中断 Executor 中的某个线程，可以调用 submit（）方法来提价一个线程。该方法返回 Future&lt;?&gt; 对象，调用该对象的 cancel（）方法来中断线程</span><br></pre></td></tr></table></figure><h2 id="4-互斥同步"><a href="#4-互斥同步" class="headerlink" title="4. 互斥同步"></a>4. 互斥同步</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，</span><br><span class="line">synchronized：由 JVM 实现的 </span><br><span class="line">ReentrantLock：由 JDK 实现的 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-1-synchronized"><a href="#4-1-synchronized" class="headerlink" title="4.1 synchronized"></a>4.1 synchronized</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同步代码块：只作用于同一个对象，如果调用的时不同的对象，则并不会同步</span><br><span class="line">同步方法：和同步代码块相同</span><br><span class="line">同步类：作用域整个类，即使不同对象也会进行同步</span><br><span class="line">同步静态方法：同同步类</span><br></pre></td></tr></table></figure><h3 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2  ReentrantLock"></a>4.2  ReentrantLock</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</span><br></pre></td></tr></table></figure><h3 id="4-3-两者的比较"><a href="#4-3-两者的比较" class="headerlink" title="4.3 两者的比较"></a>4.3 两者的比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</span><br><span class="line">性能：synchronized 与 ReentrantLock 大致相同。</span><br><span class="line">等待可中断：ReentrantLock 可中断，而 synchronized 不行。</span><br><span class="line">当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</span><br><span class="line">公平锁：synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。的，但是也可以是公平的。</span><br><span class="line">公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</span><br><span class="line">锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。</span><br><span class="line">使用选择：优先使用 synchronized 锁，再不是 ReentracntLock 的高级功能时</span><br></pre></td></tr></table></figure><h2 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5. 线程通信"></a>5. 线程通信</h2><h3 id="5-1-等待唤醒"><a href="#5-1-等待唤醒" class="headerlink" title="5.1 等待唤醒"></a>5.1 等待唤醒</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个线程完成每个任务或者操作后主动进入等待状态，等待其它线程执行与它相关联的任务或操作后，通知该线程不再等待</span><br><span class="line">使用 wait（）方法进入等待状态，使用 notify（）方法唤醒等待线程，两者使用同一锁对象</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="2021/05/26/Java/Java-02_%E5%AE%B9%E5%99%A8-%E6%9C%AA%E5%AE%8C/"/>
      <url>2021/05/26/Java/Java-02_%E5%AE%B9%E5%99%A8-%E6%9C%AA%E5%AE%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</span><br></pre></td></tr></table></figure><h2 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2. Collection"></a>2. Collection</h2><h3 id="2-1-Set"><a href="#2-1-Set" class="headerlink" title="2.1 Set"></a>2.1 Set</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeSet：基于红黑树的实现，支持有序操作</span><br><span class="line">HashSet：基于哈希表的实现，支持快速查找，不支持有序性操作</span><br><span class="line">LinkedHashSet：具有 HashSet 的查找效率，内部使用双向链表维护元素的插入顺序</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-List"><a href="#2-2-List" class="headerlink" title="2.2 List"></a>2.2 List</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayLsit：基于动态数据的实现，支持随机访问</span><br><span class="line">Vector：和 ArrayList 相似，但它是线程安全的</span><br><span class="line">LinkedLsit：基于双向链表的实现，只能顺序访问，但可以快速的在链表中添加、删除元素，由于使用双向链表，可作为栈、队列、双向队列</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-Queue"><a href="#2-3-Queue" class="headerlink" title="2.3 Queue"></a>2.3 Queue</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList：基于双向链表的队列</span><br><span class="line">PriorityQueue：基于堆结构实现的队列，可用做优先队列</span><br></pre></td></tr></table></figure><h3 id="2-5-Map"><a href="#2-5-Map" class="headerlink" title="2.5 Map"></a>2.5 Map</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap：基于红黑树的实现</span><br><span class="line">HashMap：基于哈希表的实现</span><br><span class="line">HashTable：和 HashMap 相似，它是线程安全的，但被遗弃了，使用 ConcurrentHashMap 来代替，使用了分段锁，因此效率更高</span><br><span class="line">LinkHashMap：使用双向链表维护元素的顺序，为插入顺序、最少使用顺序</span><br></pre></td></tr></table></figure><h2 id="3-使用的设计模式"><a href="#3-使用的设计模式" class="headerlink" title="3. 使用的设计模式"></a>3. 使用的设计模式</h2><h3 id="3-1-迭代器模式"><a href="#3-1-迭代器模式" class="headerlink" title="3.1 迭代器模式"></a>3.1 迭代器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection 接口继承 Iterable 接口，Iterable 中的 iterator（）方法返回一个 iterator 对象，该对象能够遍历 Collection 中的元素，在 JDK1.5 之口，使用 foreach（）方法遍历 iterable 接口的聚合对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-适配器模式"><a href="#3-2-适配器模式" class="headerlink" title="3.2 适配器模式"></a>3.2 适配器模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在 java.util.Arrays 类中的 asList（）方法能够把数组转为 List，参数为泛型的可变长参数 </span><br><span class="line">@SafeVarargs</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</span><br></pre></td></tr></table></figure><h2 id="4-查看源码"><a href="#4-查看源码" class="headerlink" title="4. 查看源码"></a>4. 查看源码</h2><h3 id="4-1-ArrayList"><a href="#4-1-ArrayList" class="headerlink" title="4.1 ArrayList"></a>4.1 ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList 是基于动态数组实现的，RandomAccess 接口标识着该类支持快速随机访问。默认初始容量为 <span class="number">10</span> ，每次扩容为 原来的 <span class="number">1.5</span> 倍</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">序列化：<span class="keyword">transient</span> 修饰的属性，并不会被序列化，并且实现了 writeObject（）和 readObject（）来控制只读序列化数组中有元素的部分</span><br><span class="line">       <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">Fail-Fast：modCount 用来记录 ArrayList 结构发生变化的次数，在进行序列化或者迭代操作时，比较 modCount 是否改变，若发生改变则抛出异常 ConcurrentModificationException</span><br></pre></td></tr></table></figure><h3 id="4-2-Vector"><a href="#4-2-Vector" class="headerlink" title="4.2 Vector"></a>4.2 Vector</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vector 与 ArrayList 相似，但它使用了 synchronized 进行同步，</span><br><span class="line">Vector 在扩容时，根据构造函数传入的参数 capacityIncrement 是由大于等于 0，若不等于，在原来的容量基础上增加 capacityIncrement 的容量，若没有或调用默认的则扩容为原来的两倍</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="2021/05/26/Java/Java-01_%E5%9F%BA%E7%A1%80/"/>
      <url>2021/05/26/Java/Java-01_%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><h3 id="1-1-基本数据类型"><a href="#1-1-基本数据类型" class="headerlink" title="1.1 基本数据类型"></a>1.1 基本数据类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> / <span class="number">8</span> bit</span><br><span class="line"><span class="keyword">char</span> / <span class="number">16</span> / <span class="number">2</span> 字节</span><br><span class="line"><span class="keyword">short</span> / <span class="number">16</span> / <span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> / <span class="number">32</span> / <span class="number">4</span></span><br><span class="line">Long / <span class="number">32</span> ~ <span class="number">64</span> / <span class="number">4</span> ~ <span class="number">8</span></span><br><span class="line"><span class="keyword">float</span> / <span class="number">32</span> / <span class="number">4</span></span><br><span class="line">Double / <span class="number">32</span> ~ <span class="number">64</span> / <span class="number">4</span> ~ <span class="number">8</span></span><br><span class="line"><span class="keyword">boolean</span> / ~ </span><br><span class="line">       <span class="keyword">boolean</span> 没有明确的大小规定，JVM 在编译器会将 <span class="keyword">boolean</span> 类型的数据转换为 <span class="keyword">int</span> ，<span class="number">1</span> 表示 <span class="keyword">true</span> ，<span class="number">0</span> 表示 <span class="keyword">false</span>。JVM 支持 <span class="keyword">boolean</span> 数组，通过读写 <span class="keyword">byte</span> 数组实现</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-包装类型"><a href="#1-2-包装类型" class="headerlink" title="1.2 包装类型"></a>1.2 包装类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型都有对应的包装类型</span><br><span class="line">在基本数据类型与对应包装类型之间赋值时，是自动装箱和拆箱的</span><br><span class="line">显示拆箱、隐式拆箱</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-1-缓存池"><a href="#1-2-1-缓存池" class="headerlink" title="1.2.1 缓存池"></a>1.2.1 缓存池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">每个包装类型都含有相应的缓存池</span><br><span class="line">以 Integer 为例：</span><br><span class="line"><span class="keyword">new</span> Integer(<span class="number">20</span>) 与 Integer.valueOf(<span class="number">20</span>) 的区别</span><br><span class="line"><span class="keyword">new</span> Integer(<span class="number">20</span>)：是创建一个新的对象</span><br><span class="line">Integer.valueOf(<span class="number">20</span>)：会先查找缓存池，若没有则创建新的对象</span><br><span class="line">每个包装类对应的缓存池大小：JDK 为 <span class="number">1.8</span> </span><br><span class="line">Integer：-<span class="number">128</span> ~ <span class="number">127</span> <span class="comment">// 在启动 jvm 是可以指定上界 -XX:AutoBoxCacheMax=&lt;size&gt;</span></span><br><span class="line">Byte: All</span><br><span class="line">Short: -<span class="number">128</span> ~ <span class="number">127</span></span><br><span class="line">Char: \u0000 ~ \u007F</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String 被声明为 <span class="keyword">final</span>，它不可被继承(Integer 等包装类也不能被继承）</span><br><span class="line">   内部使用 <span class="keyword">char</span>[] 数组存储数据且被 <span class="keyword">final</span> 修饰，说明该数组引用是不可变的，也就是 string 不可变。在 JDK1<span class="number">.9</span> 之后，添加 <span class="keyword">byte</span> coder 来标识编码</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h3 id="2-1-StringPool"><a href="#2-1-StringPool" class="headerlink" title="2.1 StringPool"></a>2.1 StringPool</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。除此之外，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。在 JDK 1.7 之前，StringPool 被放在永久代， 在 1.7 之后被放到堆中。</span><br></pre></td></tr></table></figure><h3 id="2-2-String-不可变"><a href="#2-2-String-不可变" class="headerlink" title="2.2 String   不可变"></a>2.2 String   不可变</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. String 的 hash 经常被使用，不可变的特性，使它 hash 值也不可变，不必多次计算。</span><br><span class="line">2，使用使用常量池，当遇到多个相同的字符串，不必多次创建</span><br><span class="line">3. String 经常作为参数，不可变性保证参数不可变</span><br><span class="line">4. String 的不可变保证了线程安全</span><br></pre></td></tr></table></figure><h3 id="2-3-StringBuffer、StringBuilder"><a href="#2-3-StringBuffer、StringBuilder" class="headerlink" title="2.3 StringBuffer、StringBuilder"></a>2.3 StringBuffer、StringBuilder</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">都是可变的，StringBuffer 是线程安全的，内部使用 synchronized 同步，StringBuilder 是不安全的</span><br></pre></td></tr></table></figure><h2 id="3-运算"><a href="#3-运算" class="headerlink" title="3. 运算"></a>3. 运算</h2><h3 id="3-1-参数传递"><a href="#3-1-参数传递" class="headerlink" title="3.1 参数传递"></a>3.1 参数传递</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 的参数是以值传递的形式传入方法中，而不是引用传递。</span><br></pre></td></tr></table></figure><h3 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2 类型转换"></a>3.2 类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">隐式类型转换</span><br><span class="line">java 不能隐式指向向下转型，会降低精确度，在使用 +=、++ 时，会进行隐式转换</span><br><span class="line">显示转换</span><br><span class="line">强转，会损失精确度</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-switch"><a href="#3-3-switch" class="headerlink" title="3.3 switch"></a>3.3 switch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 java1.7 后，switch 的判断语句可以是 String 类型，但还是不支持 long、float、double 类型的判断</span><br></pre></td></tr></table></figure><h2 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4. 关键字"></a>4. 关键字</h2><h3 id="4-1-final"><a href="#4-1-final" class="headerlink" title="4.1 final"></a>4.1 final</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类：被 final 修饰的类不能被继承</span><br><span class="line">方法：被 final 修饰的方法不能被子类重写</span><br><span class="line">属性：修饰常量，可以是编译时常量，也可以是运行时常量</span><br><span class="line">基本类型：值不变</span><br><span class="line">引用类型：址不变，值可变</span><br></pre></td></tr></table></figure><h3 id="4-2-static"><a href="#4-2-static" class="headerlink" title="4.2 static"></a>4.2 static</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">静态变量：又称为类变量，类所有的实例共享静态变量</span><br><span class="line">静态方法：在类加载的时候就已经存在，不依赖任何实例，因此静态方法必须有实现，而不能是抽象方法。方法中若要出现属性，为静态属性</span><br><span class="line">静态代码块：在类初始化时运行一次，且仅运行一次</span><br><span class="line">静态内部类：不依赖外部类，不用实例化外部类对象，就可以创建</span><br><span class="line">静态导包：好处在于使用静态的方法或属性时，不必加上类名称，但降低了可读性</span><br><span class="line">初始化顺序：</span><br><span class="line">静态变量和静态代码块优先实例变量和普通代码块</span><br><span class="line">静态变量和静态代码块的顺序取决于它们在代码中的位置</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-Object"><a href="#5-Object" class="headerlink" title="5. Object"></a>5. Object</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">equals（）：</span><br><span class="line">等价：满足自反性、对称性、传递性、一致性，与 null 相比为 false</span><br><span class="line">等价与相等：</span><br><span class="line">基本数据类型：使用 == 比较值是否相等，没有 equals()</span><br><span class="line">引用数据类型：使用 == 比较引用的是否是同一个对象，而 equals（）判断两者引用对象的值是否相等</span><br><span class="line">hashCode（）：</span><br><span class="line">返回哈希值。等价的两个对象散列值一定相同，相同的散列值的连个对象不一定等价，因为计算哈希值具有随机性。</span><br><span class="line">HashSet 和 HashMap 等集合类使用 hashCode（）方法计算存储位置，未避免位置的重复，要求哈希函数把所有域的值都考虑，将每个域当成 R 进制的某一位，组成一个 R 进制的整数。R 一般取 31</span><br><span class="line">toString（）：</span><br><span class="line">打印对象时，回调用此方法</span><br><span class="line">clone（）：</span><br><span class="line">在 Object 中用 protected 修饰，子类重写了该方法还需要实现 Cloneable 接口。克隆分为浅拷贝和深拷贝，浅拷贝只能拷贝基本数据类型</span><br><span class="line">，引用数据类型指向原有地址。深拷贝不建议在 clone（）方法中实现，可以使用构造函数、工厂来进行深拷贝</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-修饰符"><a href="#6-修饰符" class="headerlink" title="6. 修饰符"></a>6. 修饰符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java 中有三个访问权限修饰符：</span><br><span class="line">private：仅在当前类中有效</span><br><span class="line">protected：在当前类的同包下和子类</span><br><span class="line">public：所有</span><br><span class="line">default：同包下可见</span><br></pre></td></tr></table></figure><h2 id="7-类"><a href="#7-类" class="headerlink" title="7. 类"></a>7. 类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类是一组相关属性和行为的集合，使用属性描述事物的状态，用行为描述事物的动作</span><br></pre></td></tr></table></figure><h2 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. 对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是类的具体表现</span><br></pre></td></tr></table></figure><h2 id="9-封装"><a href="#9-封装" class="headerlink" title="9. 封装"></a>9. 封装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将类的属性或行为隐藏，外界不能直接访问，可以通过提供的公共方法访问</span><br></pre></td></tr></table></figure><h2 id="10-继承"><a href="#10-继承" class="headerlink" title="10. 继承"></a>10. 继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类继承父类的属性和行为，子类具备父类的非私有属性和行为，子类和父类之间的关系是 is a 。是多态的前提</span><br></pre></td></tr></table></figure><h3 id="10-1-抽象类"><a href="#10-1-抽象类" class="headerlink" title="10.1 抽象类"></a>10.1 抽象类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类使用 abstract 关键字修饰，标明当前类是抽象类，抽象类不能被实例化，只能被继承</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">子类和父类之间的关系是 is a </span><br><span class="line">super：</span><br><span class="line">可以使用 super() 函数访问父类的构造函数，或者使用 super.xxx() 调用父类中的方法</span><br></pre></td></tr></table></figure><h2 id="11-实现"><a href="#11-实现" class="headerlink" title="11. 实现"></a>11. 实现</h2><h3 id="11-1-接口"><a href="#11-1-接口" class="headerlink" title="11.1 接口"></a>11.1 接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，不能有任何的方法实现。从 Java 8 开始，接口也可以拥有默认的方法实现，接口的成员（字段）默认都是 public、static、final 的，方法为 public， 并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private。</span><br><span class="line">实现类和接口之间的关系是 Like a</span><br></pre></td></tr></table></figure><h2 id="12-多态"><a href="#12-多态" class="headerlink" title="12. 多态"></a>12. 多态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">同一行为，有多种不同的体现</span><br><span class="line">继承是多态的前提，具体表现为 父类引用指向子类</span><br><span class="line">向上转型：子类转向父类</span><br><span class="line">向下转型：父类转向子类</span><br></pre></td></tr></table></figure><h2 id="13-重写与重载"><a href="#13-重写与重载" class="headerlink" title="13. 重写与重载"></a>13. 重写与重载</h2><h3 id="13-1-重写"><a href="#13-1-重写" class="headerlink" title="13.1 重写"></a>13.1 重写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指子类对父类中方法进行重新编写，重写时有三个限制条件：</span><br><span class="line">1. 子类方法的权限修饰符必须大于等于父类的修饰符</span><br><span class="line">2. 子类的返回类型必须父类的返回类型或其子类</span><br><span class="line">3. 子类抛出的同样时父类的异常或其子类</span><br><span class="line">@Override 注解 可以帮助我们检查是否满足限制条件</span><br></pre></td></tr></table></figure><h3 id="13-2-重载"><a href="#13-2-重载" class="headerlink" title="13.2 重载"></a>13.2 重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指同一个类中，多个方法名称相同，参数的个数、类型的顺序的不同</span><br></pre></td></tr></table></figure><h2 id="14-反射"><a href="#14-反射" class="headerlink" title="14. 反射"></a>14. 反射</h2><p>待阅读文章：</p><p>​    <a href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析Java反射</a>、<a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">官方说明</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">每个类都有一个 Class 对象，包含了与类有关的信息。</span><br><span class="line">类加载可以理解为 Class 对象的加载，且仅在第一次使用时才加载，也可以使用 Class。forName（&quot;&quot;） 来加载类对象，该方法返回一个 Class 对象。</span><br><span class="line">Class 和 java.lang.reflect 共同对反射提供支持， java.lang.reflect 库中包含三各类：</span><br><span class="line">Field：可以使用 get（） 和 set（）方法读取和修改 Field 对象关联的字段</span><br><span class="line">Method：使用 invoke（）方法调用与 Method 对象关联的方法</span><br><span class="line">Constructor：可以用 Constructor 的 newInstance（）方法创建对象</span><br><span class="line">优点：</span><br><span class="line">可扩展性高、</span><br><span class="line">缺点：</span><br><span class="line">性能开销大，反射涉及动态类型的解析，JVM 无法对代码优化。</span><br><span class="line">内部暴露，反射允许代码执行不被允许的操作，（如私有属性和发方法）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15-异常"><a href="#15-异常" class="headerlink" title="15. 异常"></a>15. 异常</h2><p>待阅读文章：</p><p>​    <a href="https://www.cnblogs.com/Qian123/p/5715402.html">Java 异常处理</a>、<a href="https://www.journaldev.com/2167/java-exception-interview-questions-and-answers">Java Exception</a></p><p><img src="Untitled.assets/690102-20160728164909622-1770558953.png" alt="img" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable 表示任何可以作为异常抛出的类，分为两种：</span><br><span class="line">Error：JVM 无法处理的错误</span><br><span class="line">Exception：</span><br><span class="line">受检异常：需要用 try...catch... 语句捕获并处理，不影响程序的正常运行</span><br><span class="line">非受检异常：程序运行时错误</span><br></pre></td></tr></table></figure><h2 id="16-泛型"><a href="#16-泛型" class="headerlink" title="16. 泛型"></a>16. 泛型</h2><p>待阅读文章：</p><p>​    <a href="https://www.cnblogs.com/Blue-Keroro/p/8875898.html">Java 泛型详解</a>、<a href="https://cloud.tencent.com/developer/article/1033693">10 道 Java 泛型面试题</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</span><br></pre></td></tr></table></figure><h2 id="17-注解"><a href="#17-注解" class="headerlink" title="17. 注解"></a>17. 注解</h2><p>待阅读文章：</p><p>​    <a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">注解实现原理</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</span><br></pre></td></tr></table></figure><h2 id="18-JDK-1-7-和-1-8-的区别"><a href="#18-JDK-1-7-和-1-8-的区别" class="headerlink" title="18. JDK 1.7 和 1.8 的区别"></a>18. JDK 1.7 和 1.8 的区别</h2><p>待阅读文章：</p><p><a href="https://selfgrowth.com/articles/difference-between-java-18-and-java-17">1.8 与 1.7 的区别</a></p><h3 id="18-1-JDK1-8"><a href="#18-1-JDK1-8" class="headerlink" title="18.1 JDK1.8"></a>18.1 JDK1.8</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lambda Expressions</span><br><span class="line">Pipelines and Streams</span><br><span class="line">Date and Time API</span><br><span class="line">Default Methods</span><br><span class="line">Type Annotations</span><br><span class="line">Nashhorn JavaScript Engine</span><br><span class="line">Concurrent Accumulators</span><br><span class="line">Parallel operations</span><br><span class="line">PermGen Error Removed</span><br></pre></td></tr></table></figure><h3 id="18-2-JDK1-7"><a href="#18-2-JDK1-7" class="headerlink" title="18.2 JDK1.7"></a>18.2 JDK1.7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Strings in Switch Statement</span><br><span class="line">Type Inference for Generic Instance Creation</span><br><span class="line">Multiple Exception Handling</span><br><span class="line">Support for Dynamic Languages</span><br><span class="line">Try with Resources</span><br><span class="line">Java nio Package</span><br><span class="line">Binary Literals, Underscore in literals</span><br><span class="line">Diamond Syntax</span><br></pre></td></tr></table></figure><h2 id="19-JRE-or-JDK"><a href="#19-JRE-or-JDK" class="headerlink" title="19. JRE or JDK"></a>19. JRE or JDK</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。</span><br><span class="line">JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/26/hello-world/"/>
      <url>2021/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
